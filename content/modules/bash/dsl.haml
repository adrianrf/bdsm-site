<!DOCTYPE html>
<html>
<head>
    <meta http-eqiv='content-type' content='text/html;charset=utf-8'>
    <title>dsl</title>
    <link rel=stylesheet href="http://jashkenas.github.com/docco/resources/docco.css">
</head>
<body>
<div id=container>
    <div id=background></div>
    <table cellspacing=0 cellpadding=0>
    <thead>
      <tr>
        <th class=docs><h1>dsl</h1></th>
        <th class=code></th>
      </tr>
    </thead>
    <tbody>
        <tr><td class='docs'><h1>Array Module</h1>

</td><td class=code><div class=highlight><pre>
<span class="c">#!/usr/bin/env bash</span>


</pre></div></td></tr><tr><td class=docs>

<h2>array<em>is</em>nonempty()</h2>

<p>Checks to see if an array with the name given as the first parameter
is nonempty.</p>

<h3>Input Parameters</h3>

<p>The first parameter is the name of the array variable.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 if the array is non-empty.
1 if the array is empty.</p>

<h3>Failure Scenarios</h3>

<p>Fails if the array name, the first parameter, is not given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ the_array=(1 2 3 4 5)
user$ array_is_nonempty the_array
user$ echo $?
0

user$ the_array=()
user$ array_is_nonempty the_array
user$ echo $?
1
</code></pre>

</td><td class=code><div class=highlight><pre>
array_is_nonempty<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_array_name</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span>

  <span class="k">if </span>variable_is_nonempty _array_name
  <span class="k">then</span>
<span class="k">    </span><span class="nb">eval</span> <span class="s2">&quot;(( \${#${_array_name}[@]} &gt; 0 ))&quot;</span>
  <span class="k">else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot push onto array as an array name was not given.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>array<em>is</em>empty()</h2>

<p>Checks to see if an array with the name given as the first parameter is empty.</p>

<h3>Input Parameters</h3>

<p>The first parameter is the name of the array variable.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 if the array is empty.
1 if the array is non-empty.</p>

<h3>Failure Scenarios</h3>

<p>Fails if the array name, the first parameter, is not given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ the_array=()
user$ array_is_empty the_array
user$ echo $?
0

user$ the_array=(1 2 3 4 5)
user$ array_is_empty the_array
user$ echo $?
1
</code></pre>

</td><td class=code><div class=highlight><pre>
array_is_empty<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_array_name</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span>

  <span class="k">if </span>variable_is_nonempty _array_name
  <span class="k">then</span>
<span class="k">    </span><span class="nb">eval</span> <span class="s2">&quot;(( \${#${_array_name}[@]} == 0 ))&quot;</span>
  <span class="k">else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot push onto array as an array name was not given.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>array_length()</h2>

<p>Return the length of the given array.</p>

<h3>Input Parameters</h3>

<p>First parameter is the name of the array variable.</p>

<h3>Stream Outputs</h3>

<p>Prints the length of the named array to the STDOUT stream of the calling
environment.</p>

<h3>Return Codes</h3>

<p>returns 0</p>

<h3>Failure Scenarios</h3>

<p>Fails if the array name, first parameter, is not given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ the_array=(1 2 3 4 5)
user$ array_length the_array
5
</code></pre>

</td><td class=code><div class=highlight><pre>
array_length<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_array_name</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span>

  <span class="k">if </span>variable_is_nonempty _array_name
  <span class="k">then</span>
<span class="k">    </span><span class="nb">eval</span> <span class="s2">&quot;printf \&quot;%s\\n\&quot; \&quot;\${#${_array_name}[@]}\&quot;&quot;</span>
  <span class="k">else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot push onto array as an array name was not given.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>array<em>last</em>element()</h2>

<p>Print the last element of the given array.</p>

<h3>Input Parameters</h3>

<p>First parameter is the name of the array variable.</p>

<h3>Stream Outputs</h3>

<p>Prints the last element of the named array to the STDOUT stream of the
calling environment.</p>

<h3>Failure Scenarios</h3>

<p>Fails if the array name, first parameter, is not given.</p>

<h3>Return Codes</h3>

<p>0 denoting success</p>

<h3>Usage Examples</h3>

<pre><code>$ the_array=(one two three four five)
$ array_last_element the_array
five
</code></pre>

</td><td class=code><div class=highlight><pre>
array_last_element<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_array_name</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span> _length

  <span class="k">if </span>variable_is_nonempty _array_name
  <span class="k">then</span>
<span class="k">    </span><span class="nb">eval</span> <span class="s2">&quot;_length=\${#${_array_name}[@]}&quot;</span>

    <span class="nb">eval</span> <span class="s2">&quot;printf \&quot;%s\\n\&quot; \&quot;\${${_array_name}[${_length}]}\&quot;&quot;</span>
  <span class="k">else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot push onto array as an array name was not given.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>array<em>first</em>element()</h2>

<p>Print the first element of the given array.</p>

<h3>Input Parameters</h3>

<p>First parameter is the name of the array variable.</p>

<h3>Stream Outputs</h3>

<p>Prints the first element of the named array to the STDOUT stream of the
calling environment.</p>

<h3>Return Codes</h3>

<p>0 denoting success</p>

<h3>Failure Scenarios</h3>

<p>Fails if the array name, the first parameter, is not given.</p>

<h3>Usage Examples</h3>

<pre><code>$ the_array=(one two three four five)
$ array_first_element the_array
one
</code></pre>

</td><td class=code><div class=highlight><pre>
array_first_element<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_array_name</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span> _length

  <span class="k">if </span>variable_is_nonempty _array_name
  <span class="k">then</span>
<span class="k">    </span><span class="nb">eval</span> <span class="s2">&quot;printf \&quot;%s\\n\&quot; \&quot;\${${_array_name}[0]}\&quot;&quot;</span>
  <span class="k">else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot push onto array as an array name was not given.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>array_push()</h2>

<p>Appends one or more elements to the array with the given name.</p>

<h3>Input Parameters</h3>

<p>The first parameter is the name of the array variable.
  Remaining parameters are the elements to be appended to the array.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Returns</h3>

<p>0 denoting success</p>

<h3>Failure Scenarios</h3>

<p>Fails if the array name, the first parameter, is not given.
Fails if no elements were given (second paramater and beyond).</p>

<h3>Usage Examples</h3>

<pre><code>$ the_array=(1 2 3 4 5)
$ array_push the_array 6
$ array_join the_array # print the contents of the array, space separated
1 2 3 4 5 6
</code></pre>

</td><td class=code><div class=highlight><pre>
array_push<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_array_name</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span>
  <span class="nb">shift</span>

<span class="nb">  </span><span class="k">if </span>variable_is_nonempty _array_name
  <span class="k">then</span>
<span class="k">    </span><span class="nb">eval</span> <span class="s2">&quot;(( \${#${_array_name}[@]} &gt; 0 ))&quot;</span>

    <span class="nb">local </span>_element <span class="nv">_elements</span><span class="o">=(</span><span class="s2">&quot;$@&quot;</span><span class="o">)</span>

    <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">_elements</span><span class="p">[@]</span><span class="k">}</span> <span class="o">==</span> 0 <span class="o">))</span>
    <span class="k">then</span>
<span class="k">      </span>fail <span class="s2">&quot;Cannot push elements onto array as no elements were given.&quot;</span>
    <span class="k">fi</span>

<span class="k">    for </span>_element in <span class="s2">&quot;${_elements[@]}&quot;</span>
    <span class="k">do</span>
<span class="k">      </span><span class="nb">eval</span> <span class="s2">&quot;${_array_name}+=(\${_element})&quot;</span>
    <span class="k">done</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot push elements onto array as an array name was not given.&quot;</span>
  <span class="k">fi</span>

<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>array_append()</h2>

<p>Return the length of the given array.</p>

<h3>Input Parameters</h3>

<p>The first parameter is the name of the array variable.
Remaining parameters are the elements to append to the end of the array.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Returns</h3>

<p>0 denoting success</p>

<h3>Failure Scenarios</h3>

<p>Fails if the array name, the first parameter, is not given.
Fails if no elements were given to append to the array.</p>

<h3>Usage Examples</h3>

<pre><code>user$ the_array=(1)
user$ array_append the_array 2 3 4 5
user$ array_join the_array # print the contents of the array,
space separated.
1 2 3 4 5
</code></pre>

</td><td class=code><div class=highlight><pre>
array_append<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_array_name</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span>

  <span class="k">if </span>variable_is_nonempty _array_name
  <span class="k">then</span>
<span class="k">    </span><span class="nb">shift</span>
<span class="nb">    local </span>_element <span class="nv">_elements</span><span class="o">=(</span><span class="s2">&quot;$@&quot;</span><span class="o">)</span>

    <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">_elements</span><span class="p">[@]</span><span class="k">}</span> <span class="o">==</span> 0 <span class="o">))</span>
    <span class="k">then</span>
<span class="k">      </span>fail <span class="s2">&quot;Cannot push elements onto array as no elements were given.&quot;</span>
    <span class="k">fi</span>

<span class="k">    for </span>_element in <span class="s2">&quot;${_elements[@]}&quot;</span>
    <span class="k">do</span>
<span class="k">      </span><span class="nb">eval</span> <span class="s2">&quot;${_array_name}+=(\${_element})}&quot;</span>
    <span class="k">done</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot push onto array as an array name was not given.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>array_shift()</h2>

<p>Removes the first element of the array and prints it.</p>

<h3>Input Parameters</h3>

<p>The first parameter is the name of the array variable.</p>

<h3>Stream Outputs</h3>

<p>Prints the first element of the named array to the STDOUT stream of the
  calling environment.</p>

<h3>Usage Examples</h3>

<pre><code>user$ cat $HOME/test
#!/usr/bin/env bash
source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework.
modules array

my_array=(1 2 3 4)
echo ${my_array[@]}
array_shift my_array
echo ${my_array[@]}

user$ $HOME/test
1 2 3 4
1
2 3 4
</code></pre>

</td><td class=code><div class=highlight><pre>
array_shift<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_array_name</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span> <span class="nv">new_array</span><span class="o">=()</span> index first_element

  <span class="k">if </span>variable_is_nonempty _array_name
  <span class="k">then</span>
<span class="k">    </span><span class="nb">shift</span>
<span class="nb">    eval</span> <span class="s2">&quot;</span>
<span class="s2">    first_element=\${${_array_name}[0]}</span>

<span class="s2">    for (( index=1; index &lt; \${#${_array_name}[@]}; index++ ))</span>
<span class="s2">    do</span>
<span class="s2">      new_array+=(\${${_array_name}[\${index}]})</span>
<span class="s2">    done</span>

<span class="s2">    ${_array_name}=(\&quot;\${new_array[@]}\&quot;)</span>
<span class="s2">    &quot;</span>
    <span class="nb">printf</span> <span class="s2">&quot;%s&quot;</span> <span class="s2">&quot;${first_element}&quot;</span>
  <span class="k">else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot shift from array as an array name was not given.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>array_unshift()</h2>

<p>Prepends one or more elements to the array whose name is given, in the order
  given.</p>

<h3>Input Parameters Parameters</h3>

<p>The first parameter is the name of the array variable.
  Remaining parameters are the elements to prepend to the array.</p>

<h3>Stream Outputs</h3>

<p>None.
  Yields a failure message if no array name was given.
  Yields a failure message if no elements were given to unshift.</p>

<h3>Return Codes</h3>

<p>0 denoting success</p>

<h3>Usage Examples</h3>

<pre><code>$ the_array=(2 3 4 5)
$ array_unshift 1
user$ array_join the_array # print contents of the array, space separated.
1 2 3 4 5

$ the_array=(4 5)
$ array_unshift 3 2 1
user$ array_join the_array # print contents of the array, space separated.
1 2 3 4 5
</code></pre>

</td><td class=code><div class=highlight><pre>
array_unshift<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_array_name</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span>

  <span class="k">if </span>variable_is_nonempty _array_name
  <span class="k">then</span>
<span class="k">    </span><span class="nb">shift</span>

<span class="nb">    local </span>_element <span class="nv">_elements</span><span class="o">=(</span><span class="s2">&quot;$@&quot;</span><span class="o">)</span>

    <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">_elements</span><span class="p">[@]</span><span class="k">}</span> <span class="o">==</span> 0 <span class="o">))</span>
    <span class="k">then</span>
<span class="k">      </span>fail <span class="s2">&quot;Cannot push elements onto array as no elements were given.&quot;</span>
    <span class="k">fi</span>

<span class="k">    for </span>_element in <span class="s2">&quot;${_elements[@]}&quot;</span>
    <span class="k">do</span>
<span class="k">      </span><span class="nb">eval</span> <span class="s2">&quot;${_array_name}=(\&quot;${_element}\&quot; \&quot;\${${_array_name}[@]}\&quot;)&quot;</span>
    <span class="k">done</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot push onto array as an array name was not given.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>array_join()</h2>

<p>Joins the named array into a string separated by either a space or
a given string.</p>

<h3>Input Parameters</h3>

<p>The first parameter is the name of the array variable.
The second parameter is the separator between elements in the string, this is
optional and defaults to a space.</p>

<h3>Stream Outputs</h3>

<p>Prints the elements of the named array, separated by either the 2nd parameter
if given or else a space character, to the STDOUT stream of the calling
environment.</p>

<h3>Return Codes</h3>

<p>0 denoting success</p>

<h3>Failure Scenarios</h3>

<p>Fails if the array name, the first parameter, is not given.</p>

<h3>Usage Examples</h3>

<pre><code>$ the_array=(1 2 3 4 5)
$ array_join the_array
1 2 3 4 5

$ array_join the_array '.'
1.2.3.4.5
</code></pre>

</td><td class=code><div class=highlight><pre>
array_join<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_array_name</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span>

  <span class="k">if </span>variable_is_nonempty _array_name
  <span class="k">then</span>
<span class="k">    </span><span class="nb">shift</span>
<span class="nb">    local </span><span class="nv">_separator</span><span class="o">=</span><span class="s2">&quot;${1:-&#39; &#39;}&quot;</span>

    <span class="nb">eval</span> <span class="s2">&quot;</span>
<span class="s2">    for (( index=0 ; index &lt; \${#${_array_name}[@]} ; index++ )) ;</span>
<span class="s2">    do (( index &gt;  0 )) &amp;&amp; printf \&quot;%s\&quot;${_separator}\&quot;\&quot; ;</span>
<span class="s2">      printf \&quot;%s\&quot; \&quot;\${${_array_name}[\${index}]}\&quot; ;</span>
<span class="s2">    done&quot;</span>
  <span class="k">else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot join array as an array name was not given.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>array_largest()</h2>

<p>Outputs the first string in the array with the largest length.</p>

<h3>Input Parameters</h3>

<p>The first element is an array variable name.</p>

<h3>Stream Outputs</h3>

<p>Prints the largest elements of the named array to the STDOUT
stream of the calling environment.</p>

<h3>Return Codes</h3>

<p>0 denoting success</p>

<h3>Failure Scenarios</h3>

<p>Fails if the array name, the first parameter, is not given.</p>

<h3>Usage Examples</h3>

<pre><code>$ the_array=(billie bob joe)
$ array_largest the_array
billie
</code></pre>

</td><td class=code><div class=highlight><pre>
array_largest<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_array_name</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span> _index <span class="nv">_largest</span><span class="o">=</span><span class="s2">&quot;&quot;</span>

  <span class="k">if </span>variable_is_nonempty _array_name
  <span class="k">then</span>
<span class="k">    </span><span class="nb">eval</span> <span class="s2">&quot;</span>
<span class="s2">    for (( _index=0 ; _index &lt; \${#${_array_name}[@]} ; _index++ ))</span>
<span class="s2">    do</span>
<span class="s2">      if (( \${#${_array_name}[\${_index}]} &gt; \${#_largest} ))</span>
<span class="s2">      then</span>
<span class="s2">        _largest=\${${_array_name}[\${_index}]}</span>
<span class="s2">      fi</span>
<span class="s2">    done</span>
<span class="s2">    &quot;</span>
    <span class="nb">printf</span> <span class="s2">&quot;%s&quot;</span> <span class="s2">&quot;${_largest}&quot;</span>

  <span class="k">else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot find largest element as an array variable name was not given.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>array<em>sort</em>desc()</h2>

<p>Sorts the named array contents in descending order.</p>

<h3>Input Parameters</h3>

<p>An array variable name.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 denoting success</p>

<h3>Failure Scenarios</h3>

<p>Fails if the array name, the first parameter, is not given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ cat $HOME/test
#!/usr/bin/env bash
source "/usr/local/bdsm/modules/bash/core/initialize" # BDSM framework
modules array

arr=(c a d e f b h j i )
array_sort_desc arr
array_join arr
echo

user$ $HOME/test
j i h f e d c b a
</code></pre>

</td><td class=code><div class=highlight><pre>
array_sort_desc<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_array_name</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span> _index <span class="nv">_largest</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
  <span class="k">if </span>variable_is_nonempty _array_name
  <span class="k">then</span>
<span class="k">    </span><span class="nb">eval</span> <span class="s2">&quot;${_array_name}=(\$(</span>
<span class="s2">    echo \&quot;\${${_array_name}[@]}\&quot; | tr &#39; &#39; \&quot;\n\&quot; | sort -r</span>
<span class="s2">    ))&quot;</span>
  <span class="k">else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot sort an array in decending order as an array&quot;</span><span class="se">\</span>
      <span class="s2">&quot;variable name was not given.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>array<em>sort</em>asc()</h2>

<p>Sorts the named array contents in ascending order.</p>

<h3>Input Parameters</h3>

<p>An array variable name.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 denoting success</p>

<h3>Failure Scenarios</h3>

<p>Fails if the array name, the first parameter, is not given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ cat $HOME/test
#!/usr/bin/env bash
source "/usr/local/bdsm/modules/bash/core/initialize" # BDSM framework
modules array

arr=(c a d e f b h j i )
array_sort_asc arr
array_join arr
echo

user$ $HOME/test
a b c d e f h i j
</code></pre>

</td><td class=code><div class=highlight><pre>
array_sort_asc<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_array_name</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span> _index <span class="nv">_largest</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
  <span class="k">if </span>variable_is_nonempty _array_name
  <span class="k">then</span>
<span class="k">    </span><span class="nb">eval</span> <span class="s2">&quot;${_array_name}=(\$(</span>
<span class="s2">    echo \&quot;\${${_array_name}[@]}\&quot; | tr &#39; &#39; \&quot;\n\&quot; | sort</span>
<span class="s2">    ))&quot;</span>
  <span class="k">else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot sort an array in ascending order as an array &quot;</span><span class="se">\</span>
      <span class="s2">&quot;variable name was not given.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>


</pre></div></td></tr><tr><td class=docs>

<h2>array_unique()</h2>

<p>Sorts the named array contents in ascending order.</p>

<h3>Input Parameters</h3>

<p>An array variable name.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 denoting success</p>

<h3>Failure Scenarios</h3>

<p>Fails if the array name, the first parameter, is not given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ cat $HOME/test
#!/usr/bin/env bash
source "/usr/local/bdsm/modules/bash/core/initialize" # BDSM framework
modules array

arr=(a a a b b c c c c d d d d d d)
array_unique arr
array_join arr
echo

user$ $HOME/test
a b c d
</code></pre>

</td><td class=code><div class=highlight><pre>
array_unique<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_array_name</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span> _index <span class="nv">_largest</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
  <span class="k">if </span>variable_is_nonempty _array_name
  <span class="k">then</span>
<span class="k">    </span><span class="nb">eval</span> <span class="s2">&quot;${_array_name}=(\$(</span>
<span class="s2">    echo \&quot; \${${_array_name}[@]} \&quot; | awk -v RS=&#39; &#39; -v ORS=&#39; &#39; &#39;!(\$0 in a){a[\$0];print}&#39;</span>
<span class="s2">    ))&quot;</span>
  <span class="k">else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot sort an array in ascending order as an array &quot;</span><span class="se">\</span>
      <span class="s2">&quot;variable name was not given.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>


</td><td class=code><div class=highlight><pre>
</pre></div></td></tr><tr><td class=docs>

</pre></div></td></tr><tr><td class=docs>
</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs></td><td class='code'></td></tr>
    </tbody>
    </table>
</div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
    <meta http-eqiv='content-type' content='text/html;charset=utf-8'>
    <title>dsl</title>
    <link rel=stylesheet href="http://jashkenas.github.com/docco/resources/docco.css">
</head>
<body>
<div id=container>
    <div id=background></div>
    <table cellspacing=0 cellpadding=0>
    <thead>
      <tr>
        <th class=docs><h1>dsl</h1></th>
        <th class=code></th>
      </tr>
    </thead>
    <tbody>
        <tr><td class='docs'><h2>bdsm_exports()</h2>

<p>Exports bdsm framework relevant environment variables for extension action
processes.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ bdsm_exports
</code></pre>

</td><td class=code><div class=highlight><pre>
<span class="c">#!/usr/bin/env bash</span>

bdsm_exports<span class="o">()</span>
<span class="o">{</span> <span class="c"># TODO: Filter this list of exports down.</span>
  <span class="nb">export </span>action archives_path bdsm_path branch config_path database database_name debug_flag environment error_message extension extension_action extension_args extension_bin_path extension_config_path extension_modules_path extension_path extension_templates_path extensions_path flags framework head_flag hooks_flag keep_releases modules_path old_releases parse_break paths prefix_path previous_path project project_path release_path remote repository result revision shared_path src_path templates_path timestamp tmp_path trace_flag user extension_log_path
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>bdsm_version()</h2>

<p>Reads the currently installed bdsm version into the variable 'bdsm_version'.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>The variable 'bdsm_version' will be set after the function is executed.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ bdsm_version
user$ echo $bdsm_version
69.69.69
</code></pre>

</td><td class=code><div class=highlight><pre>
bdsm_version<span class="o">()</span>
<span class="o">{</span>
  <span class="k">if </span>file_is_nonempty <span class="s2">&quot;$bdsm_path/VERSION&quot;</span>
  <span class="k">then</span>
<span class="k">    </span><span class="nb">read</span> -r bdsm_version &lt; <span class="s2">&quot;$bdsm_path/VERSION&quot;</span>
  <span class="k">else</span>
<span class="k">    </span><span class="nv">bdsm_version</span><span class="o">=</span><span class="s2">&quot;?.?.?&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>NIY()</h2>

<p>Prints a failure message and backtrace to the screen letting the caller know
that the requested feature has not yet been implemented.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Prints "This feature has not yet been implemented." to STDERR of the calling
environment.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>None, only exit is through failure.</p>

<h3>Failure Scenarios</h3>

<p>Fails always.</p>

<h3>Usage Examples</h3>

<pre><code>user$ cat $HOME/test
#!/usr/bin/env bash
source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
NIY

user$ $HOME/test
ERROR: This feature has not yet been implemented.
Backtrace:
   Trace   Line Function             File
      3.    262 fail()               /usr/local/bdsm/modules/bash/logging/dsl
      2.      5 NIY()                /usr/local/bdsm/modules/bash/extensions/dsl
      1.      5 main()               /Users/wayneeseguin/test
 &gt; modules/bash/logging/dsl fail() 263 $ exit 1
</code></pre>

</td><td class=code><div class=highlight><pre>
NIY<span class="o">()</span>
<span class="o">{</span>
  fail <span class="s2">&quot;This feature has not yet been implemented.\n${*:-}&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<p>Allow for method_missing when a command is not found during lookup.</p>

</td><td class=code><div class=highlight><pre>
<span class="k">if</span> <span class="o">((</span> <span class="k">${</span><span class="nv">BASH_VERSINFO</span><span class="p">[0]</span><span class="k">}</span> &gt; 3 <span class="o">))</span>
<span class="k">then</span>
<span class="k">  </span>command_not_found<span class="o">()</span>
  <span class="o">{</span>
    <span class="nb">echo</span> <span class="s2">&quot;bash: $1: command not found ($*)&quot;</span> &gt;&amp;2
    <span class="k">return </span>127
  <span class="o">}</span>

  command_not_found_handle<span class="o">()</span>
  <span class="o">{</span>
    <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${MC_SID}&quot;</span> <span class="o">||</span> ! -t 1 <span class="o">]]</span>
    <span class="k">then</span> <span class="c"># do not run when inside Midnight Commander or within a Pipe</span>
      command_not_found <span class="s2">&quot;$@&quot;</span>
    <span class="k">fi</span>

<span class="k">    if</span> <span class="o">[[</span> <span class="nv">$MACHTYPE</span> <span class="o">=</span> *linux* <span class="o">]]</span>
    <span class="k">then</span> <span class="c"># do not run when within a subshell, Linux version.</span>
      <span class="nb">local </span>cmd state remainder
      <span class="nb">local</span> -i pid ppid pgrp session tty_nr tpgid
      <span class="nb">read </span>pid cmd state ppid pgrp session tty_nr tpgid remainder &lt; /proc/self/stat
      <span class="k">if</span> <span class="o">((</span> <span class="nv">$$</span> <span class="o">==</span> <span class="k">${</span><span class="nv">tpgid</span><span class="k">}</span> <span class="o">))</span>
      <span class="k">then</span>
<span class="k">        </span>command_not_found <span class="s2">&quot;$@&quot;</span>
      <span class="k">fi</span>
<span class="k">    fi</span>

<span class="k">    if </span><span class="nb">command</span> -v method_missing
    <span class="k">then</span> <span class="c"># Pass to method_missing.</span>
      method_missing <span class="s2">&quot;$@&quot;</span>
    <span class="k">else</span> <span class="c"># Default behavior.</span>
      command_not_found <span class="s2">&quot;$@&quot;</span>
    <span class="k">fi</span>
  <span class="o">}</span>
<span class="k">fi</span>



</td><td class=code><div class=highlight><pre>
</pre></div></td></tr><tr><td class=docs>

</pre></div></td></tr><tr><td class=docs>
</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs></td><td class='code'></td></tr>
    </tbody>
    </table>
</div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
    <meta http-eqiv='content-type' content='text/html;charset=utf-8'>
    <title>dsl</title>
    <link rel=stylesheet href="http://jashkenas.github.com/docco/resources/docco.css">
</head>
<body>
<div id=container>
    <div id=background></div>
    <table cellspacing=0 cellpadding=0>
    <thead>
      <tr>
        <th class=docs><h1>dsl</h1></th>
        <th class=code></th>
      </tr>
    </thead>
    <tbody>
        <tr><td class='docs'><h2>read_default()</h2>

<p>Reads default values from an extension's config/defaults file.</p>

<h3>Input Parameters</h3>

<p>First parameter is the defaults file key to read (key=value).
Second parameter is the variable name to store the retrieved value in.
Remaining parameters are parsed out as token, value and prefix
  into|as <variable name>
  prefix <name>
  <variable> # If no specifier.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>A variable will be set to the value, if the value is nonempty. If no variable
name is specified the variable will be assigned the same name as the key.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Fails if no arguments are passed in, at least need to specify a key.</p>

<h3>Usage Examples</h3>

<pre><code>user$ read_default "version" prefix "package" # extension is nginx for example
user$ echo $package_version
1.0.0
</code></pre>

<h3>Notes</h3>

<p>read_default respects a tiered default file scheme,</p>

<p>"/etc/bdsm/${extension}/defaults"
  "$HOME/.bdsm/${extension}/defaults"
  "${extension<em>config</em>path}/defaults"</p>

</td><td class=code><div class=highlight><pre>
<span class="c">#!/usr/bin/env bash</span>

read_default<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>key variable token value prefix _file _files _temp

  <span class="nv">key</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${key}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;$extension $action read_default() no arguments passed! &quot;</span>
  <span class="k">else</span>
<span class="k">    </span><span class="nb">shift</span>
<span class="nb">  </span><span class="k">fi</span>

<span class="k">  while</span> <span class="o">((</span> <span class="nv">$# </span>&gt; 0 <span class="o">))</span>
  <span class="k">do</span>
<span class="k">    </span><span class="nv">token</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span>
    <span class="nb">shift</span>
<span class="nb">    </span><span class="k">case</span> <span class="s2">&quot;$token&quot;</span> in
      into|as<span class="o">)</span>
        <span class="nv">variable</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span>
        <span class="nb">shift</span>
        ;;
      prefix<span class="o">)</span>
        <span class="nv">prefix</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span>
        <span class="nb">shift</span>
        ;;
      *<span class="o">)</span>
        <span class="nv">variable</span><span class="o">=</span><span class="s2">&quot;$token&quot;</span>
        <span class="nb">break</span>
      ;;
    <span class="k">esac</span>
<span class="k">  done</span>

<span class="k">  if</span> <span class="o">[[</span> -z <span class="s2">&quot;${variable:-}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    if</span> <span class="o">[[</span> -n <span class="s2">&quot;${prefix:-}&quot;</span> <span class="o">]]</span>
    <span class="k">then</span>
<span class="k">      </span><span class="nb">true</span> <span class="s2">&quot;${variable:=&quot;</span><span class="k">${</span><span class="nv">prefix</span><span class="k">:-}</span>_<span class="nv">$key</span><span class="s2">&quot;}&quot;</span>
    <span class="k">else</span>
<span class="k">      </span><span class="nb">true</span> <span class="s2">&quot;${variable:=&quot;</span><span class="nv">$key</span><span class="s2">&quot;}&quot;</span>
    <span class="k">fi</span>
<span class="k">  fi</span>

<span class="k">  </span><span class="nv">_files</span><span class="o">=(</span>
    <span class="s2">&quot;/etc/bdsm/${extension}/defaults&quot;</span>
    <span class="s2">&quot;$HOME/.bdsm/${extension}/defaults&quot;</span>
    <span class="s2">&quot;${extension_config_path}/defaults&quot;</span>
  <span class="o">)</span>

  <span class="k">for </span>_file in <span class="s2">&quot;${_files[@]}&quot;</span>
  <span class="k">do</span>
<span class="k">    if </span>file_is_nonempty <span class="s2">&quot;${_file}&quot;</span>
    <span class="k">then</span>
<span class="k">      </span><span class="nv">_temp</span><span class="o">=</span><span class="s2">&quot;$(hash_file &quot;</span><span class="k">${</span><span class="nv">_file</span><span class="k">}</span><span class="s2">&quot; &quot;</span><span class="k">${</span><span class="nv">key</span><span class="k">}</span><span class="s2">&quot;)&quot;</span>

      <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_temp}&quot;</span> <span class="o">]]</span>
      <span class="k">then</span>
<span class="k">        </span><span class="nv">value</span><span class="o">=</span><span class="s2">&quot;${_temp}&quot;</span>
      <span class="k">fi</span>
<span class="k">    fi</span>
<span class="k">  done</span>

<span class="k">  </span><span class="nb">eval</span> <span class="s2">&quot;${variable}=\&quot;${value}\&quot;&quot;</span>
<span class="o">}</span>



</td><td class=code><div class=highlight><pre>
</pre></div></td></tr><tr><td class=docs>

</pre></div></td></tr><tr><td class=docs>
</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs></td><td class='code'></td></tr>
    </tbody>
    </table>
</div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
    <meta http-eqiv='content-type' content='text/html;charset=utf-8'>
    <title>dsl</title>
    <link rel=stylesheet href="http://jashkenas.github.com/docco/resources/docco.css">
</head>
<body>
<div id=container>
    <div id=background></div>
    <table cellspacing=0 cellpadding=0>
    <thead>
      <tr>
        <th class=docs><h1>dsl</h1></th>
        <th class=code></th>
      </tr>
    </thead>
    <tbody>
        <tr><td class='docs'><h2>command_exists()</h2>

<p>Checks to see whether a command exists within the current environment and PATH</p>

<h3>Input Parameters</h3>

<p>First parameter is a command name.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>none.</p>

<h3>return codes</h3>

<p>0 if the command was found in the current environment
1 if the command was not found in the current environment</p>

<h3>failure scenarios</h3>

<p>Fails if no command name was given.</p>

<h3>usage examples</h3>

<pre><code>user$ command_exists adsf
user$ echo $?
1

user$ command_exists ls
user$ echo $?
0
</code></pre>

</td><td class=code><div class=highlight><pre>
<span class="c">#!/usr/bin/env bash</span>

command_exists<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_name</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_name}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    if </span><span class="nb">command</span> -v <span class="s2">&quot;${_name}&quot;</span> &gt; /dev/null 2&gt;&amp;1
    <span class="k">then</span>
<span class="k">      return </span>0
    <span class="k">else</span>
<span class="k">      return </span>1
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot test if command exists as no command name was given.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>is<em>a</em>function()</h2>

<p>Checks to see whether a named function exists within the current environment</p>

<h3>Input Parameters</h3>

<p>First parameter is a function name.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>none.</p>

<h3>return codes</h3>

<p>0 if the function exists
1 if the function does not exist</p>

<h3>failure scenarios</h3>

<p>Fails if no function name was given.</p>

<h3>usage examples</h3>

<pre><code>user$ is_a_function rvm
user$ echo $?
0

user$ is_a_function asdf
user$ echo $?
1

user$ is_a_function ls
user$ echo $?
1
</code></pre>

</td><td class=code><div class=highlight><pre>
is_a_function<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_name</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_name}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    if </span><span class="nb">declare</span> -f <span class="s2">&quot;${_name}&quot;</span> &gt;/dev/null 2&gt;&amp;1
    <span class="k">then</span>
<span class="k">      return </span>0
    <span class="k">else</span>
<span class="k">      return </span>1
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot test if function exists as no function name was given.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>shell<em>is</em>interactive()</h2>

<p>Checks if the currently running shell is interactive (user controlled).</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>none.</p>

<h3>return codes</h3>

<p>0 if the shell is interactive (user controlled)
1 if the shell is not interactive</p>

<h3>failure scenarios</h3>

<p>None currently.</p>

<h3>usage examples</h3>

<p>user$ cat $HOME/test</p>

<h1>!/usr/bin/env bash</h1>

<p>source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
modules environment # Load the trace module.</p>

<p>if shell<em>is</em>interactive
then
  echo "Shell is Interactive! "
else
  echo "Shell is Not Interactive! "
fi</p>

<p>user$ "$HOME/test"
Shell is Not Interactive!</p>

<p>user$ source "$HOME/test"
Shell is Interactive!</p>

</td><td class=code><div class=highlight><pre>
shell_is_interactive<span class="o">()</span>
<span class="o">{</span>
  <span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;$-&quot;</span> <span class="o">=</span> *i* <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    return </span>0
  <span class="k">else</span>
<span class="k">    return </span>1
  <span class="k">fi</span>
<span class="o">}</span>



</td><td class=code><div class=highlight><pre>
</pre></div></td></tr><tr><td class=docs>

</pre></div></td></tr><tr><td class=docs>
</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs></td><td class='code'></td></tr>
    </tbody>
    </table>
</div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
    <meta http-eqiv='content-type' content='text/html;charset=utf-8'>
    <title>dsl</title>
    <link rel=stylesheet href="http://jashkenas.github.com/docco/resources/docco.css">
</head>
<body>
<div id=container>
    <div id=background></div>
    <table cellspacing=0 cellpadding=0>
    <thead>
      <tr>
        <th class=docs><h1>dsl</h1></th>
        <th class=code></th>
      </tr>
    </thead>
    <tbody>
        <tr><td class='docs'><h2>extension_action()</h2>

<p>Load the environment for a given extension action and then call it.
This is the main function for BDSM.</p>

<h3>Input Parameters</h3>

<p>One or more extension names.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>The current extension's initialize file will be resourced into the current
environment.</p>

<h3>Return Codes</h3>

<p>0 for success
1 for failure</p>

<h3>Failure Scenarios</h3>

<p>Fails if no extension was given.
Fails if no action was given.</p>

<h3>Usage Examples</h3>

<pre><code>$ cat $HOME/test
#!/usr/bin/env bash
source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
modules extensions
extension_action ext list

$  $HOME/test
bash fossil git libevent nginx p7zip postgresql rails redis srv tig tmux zeromq zlib
</code></pre>

</td><td class=code><div class=highlight><pre>
<span class="c">#!/usr/bin/env bash</span>

extension_action<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">result</span><span class="o">=</span>0

  <span class="nb">unset </span>extension action

  <span class="nb">export </span><span class="nv">extension</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${extension}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;&#39;extension&#39; is not set! Something has gone terribly wrong.&quot;</span>
  <span class="k">fi</span>

<span class="k">  </span><span class="nb">shift</span>

<span class="nb">  export </span><span class="nv">action</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${action}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;&#39;action&#39; is not set! Something has gone terribly wrong.&quot;</span>
  <span class="k">fi</span>

<span class="k">  </span><span class="nb">shift</span>

<span class="nb">  </span><span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">extension_args</span><span class="p">[@]</span><span class="k">}</span> <span class="o">==</span> 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    </span><span class="nv">extension_args</span><span class="o">=</span><span class="s2">&quot;$@&quot;</span>
  <span class="k">fi</span>
<span class="k">  </span><span class="nb">export </span>extension_args

  <span class="nv">extension_path</span><span class="o">=</span><span class="s2">&quot;$extensions_path/$extension&quot;</span>
  <span class="nv">extension_config_path</span><span class="o">=</span><span class="s2">&quot;$extensions_path/$extension/config&quot;</span>
  <span class="nv">extension_templates_path</span><span class="o">=</span><span class="s2">&quot;$extensions_path/$extension/templates&quot;</span>
  <span class="nv">extension_modules_path</span><span class="o">=</span><span class="s2">&quot;$extensions_path/$extension/modules&quot;</span>
  <span class="nv">extension_bin_path</span><span class="o">=</span><span class="s2">&quot;$extensions_path/$extension/bin&quot;</span>
  <span class="nv">extension_log_path</span><span class="o">=</span><span class="s2">&quot;$log_path/$extension&quot;</span>

  <span class="nv">paths</span><span class="o">=</span><span class="k">$(</span>env | awk -F<span class="o">=</span> -v <span class="nv">ORS</span><span class="o">=</span><span class="s1">&#39; &#39;</span> <span class="s1">&#39;/_path/{print $1}&#39;</span><span class="k">)</span>
  <span class="nv">flags</span><span class="o">=</span><span class="k">$(</span>env | awk -F<span class="o">=</span> -v <span class="nv">ORS</span><span class="o">=</span><span class="s1">&#39; &#39;</span> <span class="s1">&#39;/_flag/{print $1}&#39;</span><span class="k">)</span>

  enter <span class="s2">&quot;${extension_path}&quot;</span> <span class="o">||</span>
    fail <span class="s2">&quot;Could not enter the extension directory!\n    (${extension_path})&quot;</span>

  bdsm_exports

  <span class="nv">action_file</span><span class="o">=</span><span class="s2">&quot;${extension_path}/bin/${action}&quot;</span>

  file_exists <span class="s2">&quot;${action_file}&quot;</span> <span class="o">||</span>
    fail <span class="s2">&quot;Action binary/file ${action} missing for extension ${extension}\n    (${action_file})&quot;</span>

  <span class="nv">action_file_type</span><span class="o">=</span><span class="s2">&quot;$(file &quot;</span><span class="nv">$action_file</span><span class="s2">&quot;)&quot;</span>

  <span class="k">case</span> <span class="s2">&quot;${action_file_type}&quot;</span> in

    *sh<span class="o">[[</span>:space:<span class="o">]]</span>script*|*POSIX<span class="o">[[</span>:space:<span class="o">]]</span>shell*|*Bourne-Again*<span class="o">)</span>
      <span class="nv">action_type</span><span class="o">=</span><span class="s2">&quot;bash&quot;</span>
      ;;

    *ASCII*<span class="o">)</span>
</pre></div></td></tr><tr><td class=docs>

<p>Launch with helper dsl, if possible.</p>

</td><td class=code><div class=highlight><pre>
      <span class="nv">extension</span><span class="o">=</span><span class="s2">&quot;${action_file//.}&quot;</span>

      <span class="k">case</span> <span class="s2">&quot;${extension}&quot;</span> in
        bash|sh<span class="o">)</span>
          <span class="nv">action_type</span><span class="o">=</span><span class="s2">&quot;bash&quot;</span>
          <span class="c">#rb) action_type=&quot;ruby&quot;   ;;</span>
          ;;
        *<span class="o">)</span>
          <span class="nb">read</span> -r shebang &lt; <span class="s2">&quot;${action_file}&quot;</span>

          <span class="k">case</span> <span class="s2">&quot;${shebang}&quot;</span> in
            *ruby|*rbx|*jruby|*macruby<span class="o">)</span>
              <span class="nv">binary</span><span class="o">=</span><span class="s2">&quot;${shebang##*(#|!)}&quot;</span>
              <span class="nv">binary</span><span class="o">=</span><span class="s2">&quot;${binary##* }&quot;</span>
              <span class="nv">action_type</span><span class="o">=</span><span class="s2">&quot;ruby&quot;</span>
              ;;
            *<span class="o">)</span>
              <span class="k">if</span> <span class="o">[[</span> -x <span class="s2">&quot;${action_file}&quot;</span> <span class="o">]]</span> ; <span class="k">then</span>
<span class="k">                </span><span class="nv">action_type</span><span class="o">=</span><span class="s2">&quot;binary&quot;</span>
              <span class="k">else</span>
<span class="k">                </span><span class="nv">action_type</span><span class="o">=</span><span class="s2">&quot;not executable&quot;</span>
              <span class="k">fi</span>
              ;;
          <span class="k">esac</span>
          ;;
      <span class="k">esac</span>
<span class="k">      </span><span class="nv">result</span><span class="o">=</span><span class="nv">$?</span>
      ;;

    cannot<span class="o">[[</span>:space:<span class="o">]]</span>open<span class="o">)</span>
      <span class="nv">action_type</span><span class="o">=</span><span class="s2">&quot;dne&quot;</span>
      ;;

    *<span class="o">)</span>
      <span class="k">if </span>file_is_executable <span class="s2">&quot;${action_file}&quot;</span> ; <span class="k">then</span>
<span class="k">        </span><span class="nv">action_type</span><span class="o">=</span><span class="s2">&quot;binary&quot;</span>
      <span class="k">else</span>
<span class="k">        </span><span class="nv">action_type</span><span class="o">=</span><span class="s2">&quot;noexec&quot;</span>
      <span class="k">fi</span>
      ;;
  <span class="k">esac</span> <span class="o">||</span> <span class="nv">result</span><span class="o">=</span><span class="nv">$?</span>

</pre></div></td></tr><tr><td class=docs>

<p>Now based on the determined action_type we launch the extension.</p>

</td><td class=code><div class=highlight><pre>
  <span class="k">case</span> <span class="s2">&quot;${action_type}&quot;</span> in
    bash<span class="o">)</span>
      <span class="o">(</span>
      enable_backtrace
      <span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;${action}&quot;</span> <span class="o">=</span> <span class="s2">&quot;help&quot;</span> <span class="o">]]</span>
      <span class="k">then</span> <span class="c"># Load the help module also.</span>
        modules core <span class="nb">help</span>
<span class="nb">      </span><span class="k">else</span>
<span class="k">        </span>modules core
      <span class="k">fi</span>

<span class="k">      </span>source_files <span class="se">\</span>
        <span class="s2">&quot;${extension_modules_path}/bash/dsl&quot;</span> <span class="se">\</span>
        <span class="s2">&quot;${extension_modules_path}/bash/initialize&quot;</span> <span class="se">\</span>
        <span class="s2">&quot;${extension_modules_path}/bash/cli&quot;</span>

      . <span class="s2">&quot;${action_file}&quot;</span>
      <span class="o">)</span> <span class="o">||</span> <span class="nv">result</span><span class="o">=</span><span class="nv">$?</span>
      <span class="k">return</span> <span class="nv">$result</span>
      ;;

    ruby<span class="o">)</span>
      <span class="nv">requires</span><span class="o">=()</span>
      <span class="k">for </span>script in dsl initialize
      <span class="k">do</span>
<span class="k">        </span>requires+<span class="o">=(</span> <span class="s2">&quot;-r${modules_path}/ruby/core/${script}.rb&quot;</span> <span class="o">)</span>
      <span class="k">done</span>

      <span class="s2">&quot;${binary:-ruby}&quot;</span> -I<span class="s2">&quot;${modules_path}/ruby&quot;</span> -I<span class="s2">&quot;${extension_modules_path}/ruby&quot;</span> <span class="se">\</span>
        <span class="k">${</span><span class="nv">requires</span><span class="p">[@]</span><span class="k">}</span> <span class="s2">&quot;${action_file}&quot;</span>
      ;;
</pre></div></td></tr><tr><td class=docs>

<p>python|lua|javascript)
  ADD "${modules<em>path}/${action</em>type}/" to the lib path so the script can require "bdsm"
 "${action_file}"
 ;;</p>

</td><td class=code><div class=highlight><pre>
    dne|noexec<span class="o">)</span>
      fail <span class="s2">&quot;Processing ${action} failed, file type is unknown, file does not exist or file is not executable.&quot;</span>
      ;;
    binary|*<span class="o">)</span>
      <span class="s2">&quot;${action_file}&quot;</span> <span class="s2">&quot;${extension_action}&quot;</span> <span class="s2">&quot;${extension_args[@]}&quot;</span>
      ;;
  <span class="k">esac</span> <span class="o">||</span> <span class="nv">result</span><span class="o">=</span><span class="nv">$?</span>

  <span class="k">return</span> <span class="nv">$result</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>extension_reload()</h2>

<p>Reloads (re-sources) the current extension's DSL and initialization files.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>The current extension's DSL and initialization files are re-sourced into the
calling environment.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No current failure scenarios.</p>

<h3>Usage Examples</h3>

<pre><code>user$ extension_reload
</code></pre>

</td><td class=code><div class=highlight><pre>
extension_reload<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_path</span><span class="o">=</span><span class="s2">&quot;${extension_modules_path}/bash&quot;</span>

  source_files <span class="s2">&quot;${_path}/dsl&quot;</span> <span class="s2">&quot;${_path}/initialize&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>extension_reinitialize()</h2>

<p>Reinitializes the current extension.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>The current extension's initialize file will be resourced into the current
environment.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ extension_reinitialize
</code></pre>

</td><td class=code><div class=highlight><pre>
extension_reinitialize<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_path</span><span class="o">=</span><span class="s2">&quot;${extension_modules_path}/bash&quot;</span>

  source_files <span class="s2">&quot;${_path}/initialize&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>extension_version()</h2>

<p>Outputs the named extension's version</p>

<h3>Input Parameters</h3>

<p>First parameter must be the name of an extension.</p>

<h3>Stream Outputs</h3>

<p>The extension-version string for the named extension.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if the extension name is not given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ extension_reinitialize
</code></pre>

</td><td class=code><div class=highlight><pre>
extension_version<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_extension</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  variable_is_nonempty <span class="o">||</span>
    fail <span class="s2">&quot;Can not retrieve extension version as no extension was given.&quot;</span>

  <span class="nb">shift</span>
<span class="nb">  true</span> <span class="k">${</span><span class="nv">extension_path</span><span class="p">:=</span><span class="s2">&quot;${extensions_path}/${_extension}&quot;</span><span class="k">}</span>

  <span class="k">if </span>file_exists <span class="s2">&quot;${extension_path}/VERSION&quot;</span>
  <span class="k">then</span>
<span class="k">    </span><span class="nb">read</span> -r extension_version &lt; <span class="s2">&quot;${extension_path}/VERSION&quot;</span>
  <span class="k">else</span>
<span class="k">    </span><span class="nv">extension_version</span><span class="o">=</span><span class="s2">&quot;head&quot;</span>
  <span class="k">fi</span>

<span class="k">  </span>log <span class="s2">&quot;${extension}-${extension_version}&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>extension_licence()</h2>

<p>Emits the extension's license file, if it exists.</p>

<h3>Input Parameters</h3>

<p>First parameter may optionally be an extension name.</p>

<h3>Stream Outputs</h3>

<p>If the extension has a LICENSE file then it wil be printed to STDOUT.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently exist.</p>

<h3>Usage Examples</h3>

<pre><code>$ cat $HOME/test
!/usr/bin/env bash
source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
modules extensions
extension_license postgresql

$ $HOME/test
Copyright (c) 2009-2011 Wayne E. Seguin

Licensed under the Apache License, Version 2.0 (the \"License\");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an \"AS IS\" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
</code></pre>

</td><td class=code><div class=highlight><pre>
extension_license<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_extension</span><span class="o">=</span><span class="s2">&quot;${1:-${extension}}&quot;</span>

  variable_is_nonempty _extension <span class="o">||</span>
    fail <span class="s2">&quot;Can not display extension license as an extension was not given.&quot;</span>

  cat -v <span class="s2">&quot;${extensions_path}/${_extension}/LICENSE&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>extensions_installed()</h2>

<p>Lists the extensions installed on the currently running process's system.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>The names of the currently installed non-core extensions are printed to the
calling environment's STDOUT.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>$ cat $HOME/test
#!/usr/bin/env bash
source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
modules extensions
extensions_installed

$ $HOME/test
bash fossil git libevent nginx p7zip postgresql rails redis tig tmux zeromq zlib
</code></pre>

</td><td class=code><div class=highlight><pre>
extensions_installed<span class="o">()</span>
<span class="o">{</span>
  extensions_in <span class="s2">&quot;${extensions_path}&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>extensions_available()</h2>

<p>Lists the extensions available to install on the currently running process's
system.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>The names of the available to install non-core extensions are printed to the
calling environment's STDOUT.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code> $ cat $HOME/test
 #!/usr/bin/env bash
 source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
 modules extensions
 extensions_available
</code></pre>

</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs>

<pre><code> $  $HOME/test
 ack androidsdk apache bash bcrypt cacti cmake ctags curl deploy erlang fossil freetype ghc ghostscript git god iconv imagemagick jpeg keepalived lcms libevent libpng libwmf libxml2 libxslt logrotate lua memcached mercurial mongodb monit mysql nginx node npm openpkg openssl p7zip passenger pcre perl postgresql r rails rainbows readline redis riak rsync rvm screen sphinx sqlite3 subversion system thin tiff tig tmux unicorn unrar zeromq zlib zsh
</code></pre>

</td><td class=code><div class=highlight><pre>
extensions_available<span class="o">()</span>
<span class="o">{</span>
  extensions_in <span class="s2">&quot;${extensions_src_path}&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>extensions<em>in</em>development()</h2>

<p>Lists the extensions available in the development repository, if set.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>The names of the available to install non-core development repository
extensions are printed to the calling environment's STDOUT, if defined.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code> $ cat $HOME/test
 #!/usr/bin/env bash
 source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
 modules extensions
 extensions_in_development
</code></pre>

</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs>

<pre><code> $  $HOME/test
 ack androidsdk apache bash bcrypt cacti cmake ctags curl deploy erlang fossil freetype ghc ghostscript git god iconv imagemagick jpeg keepalived lcms libevent libpng libwmf libxml2 libxslt logrotate lua memcached mercurial mongodb monit mysql nginx node npm openpkg openssl p7zip passenger pcre perl postgresql r rails rainbows readline redis riak rsync rvm screen sphinx sqlite3 subversion system thin tiff tig tmux unicorn unrar zeromq zlib zsh
</code></pre>

</td><td class=code><div class=highlight><pre>
extensions_in_development<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">true</span> <span class="s2">&quot;${extensions_development_path:=&quot;</span><span class="k">${</span><span class="nv">extensions_src_path</span><span class="k">}</span><span class="s2">&quot;}&quot;</span>

  list_extensions_in <span class="s2">&quot;${extensions_development_path}&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>extensions_in()</h2>

<p>Lists the extensions in a given directory.</p>

<h3>Input Parameters</h3>

<p>First parameter is a full path a BDSM extensions directory.
  (example: /usr/local/bdsm/extensions)</p>

<h3>Stream Outputs</h3>

<p>The names of the extensions in the given directory are printed to the
calling environment's STDOUT.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>$ cat $HOME/test
#!/usr/bin/env bash
source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
modules extensions
extensions_in /usr/local/bdsm/extensions

$  $HOME/test
bash fossil git libevent nginx p7zip postgresql rails redis tig tmux zeromq zlib
</code></pre>

</td><td class=code><div class=highlight><pre>
extensions_in<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_path</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  directory_exists <span class="s2">&quot;${_path}&quot;</span> <span class="o">||</span>
    fail <span class="s2">&quot;Cannot list extensions in &#39;${_path}&#39; as the directory does not exist.&quot;</span>

  <span class="nv">_files</span><span class="o">=(</span><span class="k">$(</span>find <span class="s2">&quot;${_path}&quot;</span> -mindepth 2 -maxdepth 2 -name <span class="s1">&#39;VERSION&#39;</span> -type f<span class="k">)</span><span class="o">)</span>

  <span class="nv">extensions</span><span class="o">=()</span>

  <span class="k">for </span>_file in <span class="s2">&quot;${_files[@]}&quot;</span>
  <span class="k">do</span>
<span class="k">    </span><span class="nv">extension_source_path</span><span class="o">=</span><span class="s2">&quot;${_file/%\/VERSION}&quot;</span>
    <span class="nv">extension_name</span><span class="o">=</span><span class="s2">&quot;${extension_source_path//*\/}&quot;</span>

    <span class="k">case</span> <span class="k">${</span><span class="nv">extension_name</span><span class="k">}</span> in
      <span class="o">(</span>core|ext|mod|pkg|srv|svc|<span class="o">[[=</span>.<span class="o">=]]</span>*<span class="o">)</span>
        <span class="nb">true</span> <span class="c"># Ignore core extensions, they are updated with BDSM itself.</span>
        ;;

      <span class="o">(</span>*<span class="o">)</span>
        extensions<span class="o">[</span><span class="k">${#</span><span class="nv">extensions</span><span class="p">[@]</span><span class="k">}</span><span class="o">]=</span><span class="s2">&quot;${extension_name//*\//}&quot;</span>
        ;;
    <span class="k">esac</span>
<span class="k">  done</span>

<span class="k">  </span><span class="nv">extensions</span><span class="o">=</span><span class="s2">&quot;${extensions[@]}&quot;</span>

  <span class="nb">printf</span> <span class="s2">&quot;${extensions}&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>extension_actions()</h2>

<p>Lists actions exposed by the named extension.</p>

<h3>Input Parameters</h3>

<p>First parameter is the name of the extension to list actions for.</p>

<h3>Stream Outputs</h3>

<p>The names of the extensions in the given directory are printed to the
calling environment's STDOUT.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Fails if no extension name is given.</p>

<h3>Usage Examples</h3>

<pre><code> $ cat $HOME/test
 #!/usr/bin/env bash
 source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
 modules extensions
 extension_actions "postgresql"

 $ $HOME/test
 backup configure help initialize install restart start status stop uninstall upgrade
</code></pre>

</td><td class=code><div class=highlight><pre>
extension_actions<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_extension</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  <span class="o">[[</span> -n <span class="s2">&quot;${_extension}&quot;</span> <span class="o">]]</span> <span class="o">||</span>
    fail <span class="s2">&quot;Cannot list actions for extension as no extension was given.&quot;</span>

  <span class="nb">local </span><span class="nv">_path</span><span class="o">=</span><span class="s2">&quot;$extensions_path/${_extension}/bin&quot;</span>

  directory_exists <span class="s2">&quot;${_path}&quot;</span> <span class="o">||</span> <span class="k">return </span>0

  <span class="nb">local </span><span class="nv">_files</span><span class="o">=(</span><span class="k">$(</span>find <span class="s2">&quot;${_path}&quot;</span> -mindepth 1 -maxdepth 1 -type f<span class="k">)</span><span class="o">)</span>
  <span class="nb">local </span>_file <span class="nv">_actions</span><span class="o">=()</span>

  <span class="k">for </span>_file in <span class="s2">&quot;${_files[@]}&quot;</span>
  <span class="k">do</span>
    <span class="o">[[</span> ! -x <span class="s2">&quot;${_file}&quot;</span> <span class="o">]]</span> <span class="o">||</span> _actions+<span class="o">=(</span><span class="s2">&quot;${_file//*\/}&quot;</span><span class="o">)</span>
  <span class="k">done</span>

<span class="k">  </span><span class="nv">_actions</span><span class="o">=</span><span class="s2">&quot;${_actions[@]}&quot;</span> <span class="c"># Convert from array to string.</span>

  <span class="nb">printf</span> <span class="s2">&quot;${_actions}&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>extension<em>is</em>installed()</h2>

<p>Tests if a given extension is installed.</p>

<h3>Input Parameters</h3>

<p>First parameter is an extension name.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 if the extension is installed.
1 if the extension is not installed.</p>

<h3>Failure Scenarios</h3>

<p>Fails if no extension name is given.</p>

<h3>Usage Examples</h3>

<pre><code>$ cat $HOME/test
#!/usr/bin/env bash
source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
modules extensions
extensions_installed
echo
for extension in postgresql asdf
do
  if extension_is_installed "${extension}"
  then
    echo "${extension} is installed! "
  else
    echo "${extension} is NOT installed! "
  fi
done

$  $HOME/test
bash fossil git libevent mysql nginx node npm p7zip postgresql rails redis tig tmux zeromq zlib
postgresql is installed!
asdf is NOT installed!
</code></pre>

</td><td class=code><div class=highlight><pre>
extension_is_installed<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_name</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  <span class="o">[[</span> -n <span class="s2">&quot;${_name}&quot;</span> <span class="o">]]</span> <span class="o">||</span>
    fail <span class="s2">&quot;Can not check for an installed extension as no extension name was given.&quot;</span>

  <span class="nb">local </span><span class="nv">_extensions</span><span class="o">=</span><span class="s2">&quot; $(extensions_in &quot;</span><span class="k">${</span><span class="nv">extensions_path</span><span class="k">}</span><span class="s2">&quot;) &quot;</span>

  <span class="k">case</span> <span class="s2">&quot;${_extensions}&quot;</span> in
    <span class="o">(</span>*<span class="o">[[</span>:space:<span class="o">]]</span><span class="k">${</span><span class="nv">_name</span><span class="k">}</span><span class="o">[[</span>:space:<span class="o">]]</span>*<span class="o">)</span>
      <span class="k">return </span>0
      ;;
    <span class="o">(</span>*<span class="o">)</span>
      <span class="k">return </span>1
      ;;
  <span class="k">esac</span>
<span class="o">}</span>


</pre></div></td></tr><tr><td class=docs>

<h2>extensions_install()</h2>

<p>Installs the given extensions.</p>

<h3>Input Parameters</h3>

<p>One or more extension names.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>The named extensions will be installed to the filesystem in the BDSM
extensions directory.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if no extensions are passed in to install.</p>

<h3>Usage Examples</h3>

<pre><code>user$ extensions_install libevent tmux
</code></pre>

</td><td class=code><div class=highlight><pre>
extensions_install<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_extension
  <span class="nb">local </span><span class="nv">_extensions</span><span class="o">=(</span><span class="s2">&quot;$@&quot;</span><span class="o">)</span>

  <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">_extensions</span><span class="p">[@]</span><span class="k">}</span> <span class="o">==</span> 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot install extensions as no extensions were given to install.&quot;</span>
  <span class="k">fi</span>

</pre></div></td></tr><tr><td class=docs>

<p>We need to ensure that the extensions directory already exists before calling
install in parallel.</p>

</td><td class=code><div class=highlight><pre>
  extension_fetch <span class="s2">&quot;${extension_uri:=&quot;</span><span class="k">${</span><span class="nv">extensions_repository_url</span><span class="k">}</span><span class="s2">&quot;}&quot;</span>

  <span class="k">for </span>_extension in <span class="s2">&quot;${_extensions[@]}&quot;</span>
  <span class="k">do</span>
<span class="k">    case</span> <span class="s2">&quot;${_extension#\/}&quot;</span> in
      ext|srv|pkg|core|mod<span class="o">)</span>
        <span class="k">continue</span> <span class="c"># Skip core extensions.</span>
        ;;
    <span class="k">esac</span>

<span class="k">    if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_extension}&quot;</span> <span class="o">]]</span>
    <span class="k">then</span> <span class="c"># Skip any empty extensions / &#39;artifact&#39;.</span>
      <span class="k">continue</span>
<span class="k">    else</span>
      <span class="o">(</span> extension_install <span class="s2">&quot;${_extension}&quot;</span> <span class="o">)</span>&amp;
    <span class="k">fi</span>
<span class="k">  done</span>
<span class="k">  </span><span class="nb">wait</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>extension_install()</h2>

<p>Installs the given extension.</p>

<h3>Input Parameters</h3>

<p>First parameter is the name of the extension to install</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>The named extension will be installed to the filesystem in the BDSM
extension directory.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if no extension are passed in to install.</p>

<h3>Usage Examples</h3>

<pre><code>user$ extension_install redis
</code></pre>

</td><td class=code><div class=highlight><pre>
extension_install<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_extension</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_extension}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot install an extension as no extension name was given.&quot;</span>
  <span class="k">fi</span>

<span class="k">  if </span>extension_is_valid <span class="s2">&quot;${extension_src_path}/${_extension}&quot;</span>
  <span class="k">then</span>
<span class="k">    </span>log <span class="s2">&quot; - ${_extension}&quot;</span>
    copy_directories to <span class="s2">&quot;${bdsm_path}/extensions&quot;</span> <span class="s2">&quot;${extension_src_path}/${_extension}&quot;</span>

    log <span class="s2">&quot;${extension_uri}&quot;</span> to <span class="s2">&quot;${bdsm_path}/extensions/${_extension}/.uri&quot;</span>

</pre></div></td></tr><tr><td class=docs>

<p>TODO: Process extension dependencies...</p>

</td><td class=code><div class=highlight><pre>
  <span class="k">else</span>
<span class="k">    </span>error <span class="s2">&quot;${extension_src_path} is not a proper extension.</span>
<span class="s2">   The named extension is missing VERSION and/or bin/help files.</span>
<span class="s2">   Halting installation.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

extension_fetch_and_install<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_extension</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_extension}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot fetch and install an extension as no extension name was given.&quot;</span>
  <span class="k">fi</span>

<span class="k">  </span>extension_fetch <span class="s2">&quot;${extension_uri:=&quot;</span><span class="k">${</span><span class="nv">extensions_repository_url</span><span class="k">}</span><span class="s2">&quot;}&quot;</span>

  extension_install <span class="s2">&quot;${_extension}&quot;</span>
<span class="o">}</span>

extension_fetch<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_url</span><span class="o">=</span><span class="s2">&quot;${1:-$extension_uri}&quot;</span>
  <span class="nb">local </span><span class="nv">_identifier</span><span class="o">=</span><span class="s2">&quot;${_url//\//_}&quot;</span> <span class="c"># Convert &#39;/&#39; to an invalid url component &#39;_&#39;</span>
  <span class="nb">local </span><span class="nv">repo_path</span><span class="o">=</span><span class="s2">&quot;${repos_path}/${_identifier}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_url}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot fetch an extension from a url as no url was given&quot;</span>
  <span class="k">fi</span>

</pre></div></td></tr><tr><td class=docs>

<p>TODO: scm fetch vs tarball fetch</p>

</td><td class=code><div class=highlight><pre>
  scm_fetch <span class="s2">&quot;${_url}&quot;</span>

  scm_update <span class="s2">&quot;${_url}&quot;</span>

  <span class="nv">extension_src_path</span><span class="o">=</span><span class="s2">&quot;${repo_path}&quot;</span>
<span class="o">}</span>

extension_is_valid<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_path</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_path}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot determine if an extension is valid as the path to the extension was not given.&quot;</span>
  <span class="k">fi</span>

</pre></div></td></tr><tr><td class=docs>

<p>TODO: Add all extension requirement checks here.</p>

</td><td class=code><div class=highlight><pre>
  <span class="k">if</span> <span class="o">[[</span> -s <span class="s2">&quot;${_path}/VERSION&quot;</span> <span class="o">&amp;&amp;</span> -x <span class="s2">&quot;${_path}/bin/help&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    return </span>0
  <span class="k">else</span>
<span class="k">    return </span>1
  <span class="k">fi</span>
<span class="o">}</span>

extension_package<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_name</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_name}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot package an extension as no extension name was given.&quot;</span>
  <span class="k">fi</span>

<span class="k">  </span><span class="nb">local </span><span class="nv">_path</span><span class="o">=</span><span class="s2">&quot;${extensions_development_path:-&quot;</span><span class="nv">$extensions_src_path</span><span class="s2">&quot;}&quot;</span>

  enter <span class="s2">&quot;${_path}&quot;</span>

  <span class="k">if </span>extension_is_valid <span class="s2">&quot;${_path}/${_name}&quot;</span>
  <span class="k">then</span>
<span class="k">    </span><span class="nb">local </span><span class="nv">_version</span><span class="o">=</span><span class="s2">&quot;$(cat &quot;</span><span class="k">${</span><span class="nv">_name</span><span class="k">}</span>/VERSION<span class="s2">&quot;)&quot;</span>
    log <span class="s2">&quot;Packaging extension ${_name}&quot;</span>
    log <span class="s2">&quot;${_name}-${_version}:&quot;</span>

    <span class="k">for </span>archiver in <span class="s2">&quot;gzip&quot;</span> <span class="s2">&quot;bzip2 -z&quot;</span> <span class="s2">&quot;xz -z&quot;</span>
    <span class="k">do</span>
<span class="k">      if </span>command_exists <span class="k">${</span><span class="nv">archiver</span><span class="p">// *</span><span class="k">}</span>
      <span class="k">then</span>
<span class="k">        if </span>tar cf <span class="s2">&quot;${_name}-${_version}.tar&quot;</span> <span class="s2">&quot;${_name}/&quot;</span>
        <span class="k">then</span>
          <span class="k">${</span><span class="nv">archiver</span><span class="k">}</span> -f -9 <span class="s2">&quot;${_name}-${_version}.tar&quot;</span>
        <span class="k">else</span>
<span class="k">          </span>error <span class="s2">&quot;There was an error ($?) while trying to create a tar of the &#39;${_name}&#39; directory while packaging.&quot;</span>
        <span class="k">fi</span>
<span class="k">      fi</span>

<span class="k">      </span>ensure_paths_exist <span class="s2">&quot;${_path}/pkg&quot;</span>
      <span class="k">for </span>file in <span class="s2">&quot;${_name}-${_version}&quot;</span>.tar.*
      <span class="k">do</span>
<span class="k">        </span>log <span class="s2">&quot;  - ${file}&quot;</span>
        log <span class="s2">&quot;$( file_md5 &quot;</span><span class="k">${</span><span class="nv">file</span><span class="k">}</span><span class="s2">&quot; )&quot;</span> to <span class="s2">&quot;${file}.md5&quot;</span>
        log <span class="s2">&quot;  - ${file}.md5&quot;</span>
        move_files --force <span class="s2">&quot;${file}&quot;</span> <span class="s2">&quot;${file}.md5&quot;</span> to <span class="s2">&quot;${_path}/pkg&quot;</span>
      <span class="k">done</span>
<span class="k">    done</span>

<span class="k">    </span>log <span class="s2">&quot;Packaging complete (packages are located in &#39;${_path}/pkg&#39; )&quot;</span>
  <span class="k">else</span>
<span class="k">    </span>error <span class="s2">&quot;Cannot package extension &#39;${_name}&#39; as the extension is not valid.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>



</td><td class=code><div class=highlight><pre>
</pre></div></td></tr><tr><td class=docs>

</pre></div></td></tr><tr><td class=docs>
</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs></td><td class='code'></td></tr>
    </tbody>
    </table>
</div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
    <meta http-eqiv='content-type' content='text/html;charset=utf-8'>
    <title>dsl</title>
    <link rel=stylesheet href="http://jashkenas.github.com/docco/resources/docco.css">
</head>
<body>
<div id=container>
    <div id=background></div>
    <table cellspacing=0 cellpadding=0>
    <thead>
      <tr>
        <th class=docs><h1>dsl</h1></th>
        <th class=code></th>
      </tr>
    </thead>
    <tbody>
        <tr><td class='docs'><h1>Filesystem Module</h1>

</td><td class=code><div class=highlight><pre>
<span class="c">#!/usr/bin/env bash</span>


</pre></div></td></tr><tr><td class=docs>

<h2>source_files</h2>

<p>Safely source files only if they exists and are nonempty.</p>

<h3>Input Parameters</h3>

<p>One or more files.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>Nonempty files given will be sourced into the calling environment.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if no files are given to sources.</p>

<h3>Usage Examples</h3>

<pre><code>user$ source_files "$HOME/.dotfiles/scripts/functions"
</code></pre>

</td><td class=code><div class=highlight><pre>
source_files<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_file <span class="nv">_files</span><span class="o">=(</span><span class="s2">&quot;$@&quot;</span><span class="o">)</span>

  <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">_files</span><span class="p">[@]</span><span class="k">}</span> &gt; 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    for </span>_file in <span class="s2">&quot;${_files[@]}&quot;</span>
    <span class="k">do</span>
<span class="k">      </span><span class="nv">_file</span><span class="o">=</span><span class="k">${</span><span class="nv">_file</span><span class="p">/\~\//</span><span class="nv">$HOME</span><span class="p">\/</span><span class="k">}</span> <span class="c"># Expand ~/ to full value of $HOME</span>

      <span class="k">if </span>file_is_nonempty <span class="s2">&quot;${_file}&quot;</span>
      <span class="k">then</span>
<span class="k">        </span><span class="nb">source</span> <span class="s2">&quot;${_file}&quot;</span>
</pre></div></td></tr><tr><td class=docs>

<p>TODO: figure out how to see if 'source' itself failed or simply
returning nonzero code.
|| fail "Failed to source ${_file}."</p>

</td><td class=code><div class=highlight><pre>
      <span class="k">fi</span>
<span class="k">    done</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot source files as no files were given.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>nonempty_files</h2>

<p>Outputs a subset of the named files that are nonempty.</p>

<h3>Input Parameters</h3>

<p>One or more files.</p>

<h3>Stream Outputs</h3>

<p>Each nonempty filename parameter will be printed to STDOUT of the calling
environment.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if no file names are given as arguments.</p>

<h3>Usage Examples</h3>

<pre><code>user$ nonempty_files a $HOME/.bdmsrc c
/Users/wayneeseguin/.bdsmrc
</code></pre>

</td><td class=code><div class=highlight><pre>
nonempty_files<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_file <span class="nv">_files</span><span class="o">=(</span><span class="s2">&quot;$@&quot;</span><span class="o">)</span>

  <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">_files</span><span class="p">[@]</span><span class="k">}</span> &gt; 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    for </span>_file in <span class="s2">&quot;${_files[@]}&quot;</span>
    <span class="k">do</span>
<span class="k">      if </span>file_is_nonempty <span class="s2">&quot;${_file}&quot;</span>
      <span class="k">then</span>
<span class="k">        </span><span class="nb">printf</span> <span class="s2">&quot;${_file}\n&quot;</span>
      <span class="k">fi</span>
<span class="k">    done</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot return nonempty files as no files were given.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>ensure<em>paths</em>exist</h2>

<p>Iterates over the list of given paths, creates the directory if it
does not exist.</p>

<h3>Input Parameters</h3>

<p>A list of paths to create if missing.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>Paths that were given but do not exist will be created.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if no paths were given to.</p>

<h3>Usage Examples</h3>

<pre><code>user$ ls -a
. ..
user$ ensure_paths_exist a b c
user$ ls -a
. .. a b c
</code></pre>

</td><td class=code><div class=highlight><pre>
ensure_paths_exist<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_path <span class="nv">_paths</span><span class="o">=(</span><span class="s2">&quot;$@&quot;</span><span class="o">)</span>

  <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">_paths</span><span class="p">[@]</span><span class="k">}</span> &gt; 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    for </span>_path in <span class="s2">&quot;${_paths[@]}&quot;</span>
    <span class="k">do</span>
<span class="k">      if</span> ! directory_exists <span class="s2">&quot;${_path}&quot;</span>
      <span class="k">then</span>
<span class="k">        </span>mkdir -p <span class="s2">&quot;${_path}&quot;</span>
      <span class="k">fi</span>
<span class="k">    done</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot ensure paths exist as no paths were given.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>remove_files</h2>

<p>Removes the given files, if they exist.</p>

<h3>Input Parameters</h3>

<p>One or more file names/paths.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>The named files will no longer exist on the system, if they existed to begin
with.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if no files were named.
Fails if a named file is a directory.
Fails if a named file exists but is not a file.</p>

<h3>Usage Examples</h3>

<pre><code>user$ touch a b c
user$ ls -a
. .. a b c
user$ remove_files a b c
user$ ls
. ..
</code></pre>

</td><td class=code><div class=highlight><pre>
remove_files<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_file <span class="nv">_files</span><span class="o">=(</span><span class="s2">&quot;$@&quot;</span><span class="o">)</span>

  <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">_files</span><span class="p">[@]</span><span class="k">}</span> &gt; 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    for </span>_file in <span class="s2">&quot;${_files[@]}&quot;</span>
    <span class="k">do</span>
<span class="k">      if</span> <span class="o">[[</span> -f <span class="s2">&quot;${_file}&quot;</span> <span class="o">||</span> -L <span class="s2">&quot;${_file}&quot;</span> <span class="o">]]</span>
      <span class="k">then</span>
<span class="k">        </span>rm -f <span class="s2">&quot;${_file}&quot;</span>
      <span class="k">elif</span> <span class="o">[[</span> -d <span class="s2">&quot;${_file}&quot;</span> <span class="o">]]</span>
      <span class="k">then</span>
<span class="k">        </span>error <span class="s2">&quot;Cannot remove the file ${_file} as it is a directory.&quot;</span>
      <span class="k">elif</span> <span class="o">[[</span> -e <span class="s2">&quot;${_file}&quot;</span> <span class="o">]]</span>
      <span class="k">then</span>
<span class="k">        </span>error <span class="s2">&quot;Unknown filesystem entity type located at ${_file}, cannot remove.&quot;</span>
      <span class="k">else</span>
<span class="k">        </span><span class="nb">true</span> <span class="c"># already gone</span>
      <span class="k">fi</span>
<span class="k">    done</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot remove files as no files were given.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>remove</h2>

<p>Removes the given entries, if they exist.</p>

<h3>Input Parameters</h3>

<p>One or more file, directory or symlink names/paths.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>The named files will no longer exist on the system, if they existed to begin
with.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if no files were named.</p>

<h3>Usage Examples</h3>

<pre><code>user$ touch a
user$ mkdir b
user$ ln -s b c
user$ ls -a
. .. a b c
user$ remove a b c
user$ ls
. ..
</code></pre>

</td><td class=code><div class=highlight><pre>
remove<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_file <span class="nv">_files</span><span class="o">=(</span><span class="s2">&quot;$@&quot;</span><span class="o">)</span>

  <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">_files</span><span class="p">[@]</span><span class="k">}</span> &gt; 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    for </span>_file in <span class="s2">&quot;${_files[@]}&quot;</span>
    <span class="k">do</span>
<span class="k">      if</span> <span class="o">[[</span> -f <span class="s2">&quot;${_file}&quot;</span> <span class="o">||</span> -L <span class="s2">&quot;${_file}&quot;</span> <span class="o">||</span> -d <span class="s2">&quot;${_file}&quot;</span> <span class="o">]]</span>
      <span class="k">then</span>
<span class="k">        </span>rm -rf <span class="s2">&quot;${_file}&quot;</span>

      <span class="k">elif</span> <span class="o">[[</span> -e <span class="s2">&quot;${_file}&quot;</span> <span class="o">]]</span>
      <span class="k">then</span>
<span class="k">        </span>error <span class="s2">&quot;Unhandled filesystem entity type located at ${_file}, cannot remove. (File, link and directory types are handled)&quot;</span>
      <span class="k">fi</span>
<span class="k">    done</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot remove files as no files were given.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>remove_paths</h2>

<p>Function Description</p>

<h3>Input Parameters</h3>

<p>Positional Parameter listing and descriptions.</p>

<h3>Stream Outputs</h3>

<p>What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.</p>

<h3>Environmental effects</h3>

<p>What, if any, environmental side effects this function causes. 'None.' for none.</p>

<h3>Return Codes</h3>

<p>0 if ...
1 if ...</p>

<h3>Failure Scenarios</h3>

<p>Fails if ...</p>

<h3>Usage Examples</h3>

<pre><code>user$ {{ setup the scenario }}
user$ function_name {{ parameters }}
user$ {{ demonstrate the results}}
</code></pre>

</td><td class=code><div class=highlight><pre>
remove_paths<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_path <span class="nv">_paths</span><span class="o">=(</span><span class="s2">&quot;$@&quot;</span><span class="o">)</span>

  <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">_paths</span><span class="p">[@]</span><span class="k">}</span> &gt; 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    for </span>_path in <span class="s2">&quot;${_paths[@]}&quot;</span>
    <span class="k">do</span>
<span class="k">      if</span> <span class="o">[[</span> -f <span class="s2">&quot;${_path}&quot;</span> <span class="o">]]</span>
      <span class="k">then</span>
<span class="k">        </span>error <span class="s2">&quot;Cannot remove the path &#39;${_path}&#39; as it is a file.&quot;</span>

      <span class="k">elif</span> <span class="o">[[</span> -L <span class="s2">&quot;${_path}&quot;</span> <span class="o">]]</span>
      <span class="k">then</span>
<span class="k">        </span>rm -f <span class="s2">&quot;${_path}&quot;</span>

      <span class="k">elif</span> <span class="o">[[</span> -d <span class="s2">&quot;${_path}&quot;</span> <span class="o">]]</span>
      <span class="k">then</span>
<span class="k">        </span>rm -rf <span class="s2">&quot;${_path}&quot;</span>

      <span class="k">elif</span> <span class="o">[[</span> -e <span class="s2">&quot;${_path}&quot;</span> <span class="o">]]</span>
      <span class="k">then</span>
<span class="k">        </span>error <span class="s2">&quot;Unknown filesystem entity type at ${_path}, cannot remove.&quot;</span>

      <span class="k">else</span>
<span class="k">        </span><span class="nb">true</span> <span class="c"># already gone</span>
      <span class="k">fi</span>
<span class="k">    done</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot remove paths as no paths were given.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>ensure<em>files</em>exist</h2>

<p>Iterates over the list of given files, creates the directory if it
does not exist.</p>

<h3>Input Parameters</h3>

<p>A list of files to create if missing.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>files that were given but do not exist will be created.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if no files were given to.</p>

<h3>Usage Examples</h3>

<pre><code>user$ ls -a
. ..
user$ ensure_files_exist a b c
user$ ls -a
. .. a b c
</code></pre>

</td><td class=code><div class=highlight><pre>
ensure_files_exist<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_file <span class="nv">_files</span><span class="o">=(</span><span class="s2">&quot;$@&quot;</span><span class="o">)</span> _path

  <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">_files</span><span class="p">[@]</span><span class="k">}</span> &gt; 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    for </span>_file in <span class="s2">&quot;${_files[@]}&quot;</span>
    <span class="k">do</span>
<span class="k">      </span><span class="nv">_path</span><span class="o">=</span><span class="s2">&quot;${_file%\/*}&quot;</span>

      <span class="k">if</span> <span class="o">[[</span> ! -d <span class="s2">&quot;${_path}&quot;</span> <span class="o">]]</span>
      <span class="k">then</span>
<span class="k">        </span>mkdir -p <span class="s2">&quot;${_path}&quot;</span>
      <span class="k">fi</span>

<span class="k">      if</span> <span class="o">[[</span> ! -e <span class="s2">&quot;${_file}&quot;</span> <span class="o">]]</span>
      <span class="k">then</span>
<span class="k">        </span>touch <span class="s2">&quot;${_file}&quot;</span>
      <span class="k">fi</span>
<span class="k">    done</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot ensure files exist as no files were given.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>ensure<em>files</em>are_executable</h2>

<p>Sets the executable bits on a file if it is not executable.</p>

<h3>Input Parameters</h3>

<p>One or more file name/paths</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>Files that were given and not executable will have their execute bits set.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Fails if no files were given as parameters.
Fails if one of the files given was a directory.
Fails if one of the files given does not exist.
Fails if one of the files paths does not exist.</p>

<h3>Usage Examples</h3>

<pre><code>user$ ensure_files_are_executable /etc/rc.d/postgresql
</code></pre>

<p>TODO: change this to be a  fail function if one is not
      make this into make<em>files</em>executable or some such</p>

</td><td class=code><div class=highlight><pre>
ensure_files_are_executable<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_file <span class="nv">_files</span><span class="o">=(</span><span class="s2">&quot;$@&quot;</span><span class="o">)</span> _path

  <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">_files</span><span class="p">[@]</span><span class="k">}</span> &gt; 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    for </span>_file in <span class="s2">&quot;${_files[@]}&quot;</span>
    <span class="k">do</span>
<span class="k">      if</span> <span class="o">[[</span> -d <span class="s2">&quot;${_file}&quot;</span> <span class="o">]]</span>
      <span class="k">then</span>
<span class="k">        </span>fail <span class="s2">&quot;Cannot make the file &#39;${_file}&#39; executable as it is a directory.&quot;</span>
      <span class="k">fi</span>

<span class="k">      if</span> <span class="o">[[</span> ! -f <span class="s2">&quot;${_file}&quot;</span> <span class="o">]]</span>
      <span class="k">then</span>
<span class="k">        </span>fail <span class="s2">&quot;Cannot make the file &#39;${_file}&#39; executable as the file does not exist.&quot;</span>
      <span class="k">fi</span>

<span class="k">      </span><span class="nv">_path</span><span class="o">=</span><span class="s2">&quot;${_file%\/*}&quot;</span>

      <span class="k">if</span> ! <span class="o">[[</span> -n <span class="s2">&quot;${_path}&quot;</span> <span class="o">&amp;&amp;</span> ! -d <span class="s2">&quot;${_file}&quot;</span> <span class="o">]]</span>
      <span class="k">then</span>
<span class="k">        </span>fail <span class="s2">&quot;Cannot make the file &#39;${_file} executable as &#39;${_path}&#39; does not even exist.&quot;</span>
      <span class="k">fi</span>
<span class="k">      </span>chmod +x <span class="s2">&quot;${_file}&quot;</span>
    <span class="k">done</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot ensure files are executable as no files were given.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>link</h2>

<p>Create a symlink from source to target.</p>

<h3>Input Parameters</h3>

<p>First parameter is the source
Second parameter is the target</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>Symlink is created if no failure conditions are triggered.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if target exists and is a file.
Fails if target exists and is a directory.</p>

<h3>Usage Examples</h3>

<p>The following usages are equivalent</p>

<pre><code>user$ link from /home/user/.vim/vimrc to /home/user/.vimrc
user$ link /home/user/.vim/vimrc to /home/user/.vimrc
user$ link /home/user/.vim/vimrc /home/user/.vimrc
</code></pre>

</td><td class=code><div class=highlight><pre>
link<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>token _source _target <span class="nv">_force_flag</span><span class="o">=</span>0

  <span class="k">while</span> <span class="o">((</span> <span class="nv">$# </span>&gt; 0 <span class="o">))</span>
  <span class="k">do</span>
<span class="k">    </span><span class="nv">token</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span>
    <span class="nb">shift</span>

<span class="nb">    </span><span class="k">case</span> <span class="s2">&quot;${token}&quot;</span> in
      to<span class="o">)</span>
        <span class="nv">_target</span><span class="o">=</span><span class="s2">&quot;${1}&quot;</span>
        <span class="nb">shift</span>
        ;;
      from<span class="o">)</span>
        <span class="nv">_source</span><span class="o">=</span><span class="s2">&quot;${1}&quot;</span>
        <span class="nb">shift</span>
        ;;
      --force<span class="o">)</span>
        <span class="nv">_force_flag</span><span class="o">=</span>1
        ;;
      *<span class="o">)</span>
        <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_source}&quot;</span> <span class="o">]]</span>
        <span class="k">then</span>
<span class="k">          </span><span class="nv">_source</span><span class="o">=</span><span class="s2">&quot;$token&quot;</span>

        <span class="k">elif</span> <span class="o">[[</span> -z <span class="s2">&quot;${_target}&quot;</span> <span class="o">]]</span>
        <span class="k">then</span>
<span class="k">          </span><span class="nv">_target</span><span class="o">=</span><span class="s2">&quot;$token&quot;</span>
        <span class="k">fi</span>
        ;;
    <span class="k">esac</span>
<span class="k">  done</span>

<span class="k">  if</span> <span class="o">((</span> <span class="nv">_force_flag</span> <span class="o">==</span> 1 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    </span>remove <span class="s2">&quot;${_target}&quot;</span>
  <span class="k">fi</span>

</pre></div></td></tr><tr><td class=docs>

<p>TODO: What should we do if files already exist?</p>

</td><td class=code><div class=highlight><pre>
  <span class="k">if</span> <span class="o">[[</span> -f <span class="s2">&quot;${_target}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>error <span class="s2">&quot;Cannot link ${_source} to ${_target} exists and is a file!&quot;</span>

  <span class="k">elif</span> <span class="o">[[</span> -d <span class="s2">&quot;${_target}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>error <span class="s2">&quot;Cannot link ${_source} to ${_target} exists and is a directory&quot;</span>

  <span class="k">else</span>
<span class="k">    </span>ensure_paths_exist <span class="s2">&quot;${_target%\/*}&quot;</span>
    ln -fs <span class="s2">&quot;${_source}&quot;</span> <span class="s2">&quot;${_target}&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>move_directory</h2>

<p>Moves a directory from one location to another.
(This is also used to rename a directory.)</p>

<h3>Input Parameters</h3>

<p>The first parameter is the source directory name
The second parameter is the target directory name</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>If successful, a directory is renamed (moved).</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Fails if the source directory is not specified.
Fails if the target directory is not specified.</p>

<h3>Usage Examples</h3>

<pre><code>user$ move_directory "freetds-0.91rc"* to "freetds-0.91"
</code></pre>

</td><td class=code><div class=highlight><pre>
move_directory<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_source _target _mode _owner

  <span class="k">while</span> <span class="o">((</span> <span class="nv">$# </span>&gt; 0 <span class="o">))</span> ; <span class="k">do</span>
<span class="k">    </span><span class="nv">token</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span> ; <span class="nb">shift</span>
<span class="nb">    </span><span class="k">case</span> <span class="s2">&quot;${token}&quot;</span> in
      to<span class="o">)</span>
        <span class="nv">_target</span><span class="o">=</span><span class="s2">&quot;${1}&quot;</span>
        <span class="nb">shift</span>
        ;;

      from<span class="o">)</span>
        <span class="nv">_source</span><span class="o">=</span><span class="s2">&quot;${1}&quot;</span>
        <span class="nb">shift</span>
        ;;

      mode<span class="o">)</span>
         <span class="nv">_mode</span><span class="o">=</span><span class="s2">&quot;${1}&quot;</span>
         <span class="nb">shift</span>
        ;;

      owner<span class="o">)</span>
         <span class="nv">_owner</span><span class="o">=</span><span class="s2">&quot;${1}&quot;</span>
         <span class="nb">shift</span>
        ;;

      *<span class="o">)</span>
        <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_source}&quot;</span> <span class="o">]]</span>
        <span class="k">then</span>
<span class="k">          </span><span class="nv">_source</span><span class="o">=</span><span class="s2">&quot;$token&quot;</span>

        <span class="k">elif</span> <span class="o">[[</span> -z <span class="s2">&quot;${_target}&quot;</span> <span class="o">]]</span>
        <span class="k">then</span>
<span class="k">          </span><span class="nv">_target</span><span class="o">=</span><span class="s2">&quot;$token&quot;</span>
</pre></div></td></tr><tr><td class=docs>

<p>When we have a target we are done.</p>

</td><td class=code><div class=highlight><pre>
          <span class="nb">break</span>
<span class="nb">        </span><span class="k">fi</span>
        ;;
    <span class="k">esac</span>
<span class="k">  done</span>

<span class="k">  if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_source}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot move file as the source and target must be specified. &quot;</span>
  <span class="k">fi</span>

<span class="k">  if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_target}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot move file as the source and target must be specified. &quot;</span>
  <span class="k">fi</span>

<span class="k">  </span>mv <span class="s2">&quot;${_source}&quot;</span> <span class="s2">&quot;${_target}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_mode:-}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>chmod -R <span class="s2">&quot;${_mode}&quot;</span> <span class="s2">&quot;${_target}&quot;</span>
  <span class="k">fi</span>

<span class="k">  if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_owner:-}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>chown -R <span class="s2">&quot;${_owner}&quot;</span> <span class="s2">&quot;${_target}&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>move_file</h2>

<p>Moves a file from one location to another.
(This is also used to rename a file.)</p>

<h3>Input Parameters</h3>

<p>The first parameter is the source file name
The second parameter is the target file name</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>If successful, a file is renamed (moved).</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Fails if the source file is not specified.
Fails if the target file is not specified.</p>

<h3>Usage Examples</h3>

<pre><code>user$ move_file "$HOME/.bashrc" to "$HOME/.bashrc.orig"
</code></pre>

</td><td class=code><div class=highlight><pre>
move_file<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_source _target _mode _owner

  <span class="k">while</span> <span class="o">((</span> <span class="nv">$# </span>&gt; 0 <span class="o">))</span> ; <span class="k">do</span>
<span class="k">    </span><span class="nv">token</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span> ; <span class="nb">shift</span>
<span class="nb">    </span><span class="k">case</span> <span class="s2">&quot;${token}&quot;</span> in
      to<span class="o">)</span>
        <span class="nv">_target</span><span class="o">=</span><span class="s2">&quot;${1}&quot;</span>
        <span class="nb">shift</span>
        ;;
      from<span class="o">)</span>
        <span class="nv">_source</span><span class="o">=</span><span class="s2">&quot;${1}&quot;</span>
        <span class="nb">shift</span>
        ;;
      mode<span class="o">)</span>
         <span class="nv">_mode</span><span class="o">=</span><span class="s2">&quot;${1}&quot;</span>
         <span class="nb">shift</span>
        ;;
      owner<span class="o">)</span>
         <span class="nv">_owner</span><span class="o">=</span><span class="s2">&quot;${1}&quot;</span>
         <span class="nb">shift</span>
        ;;

      *<span class="o">)</span>
        <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_source}&quot;</span> <span class="o">]]</span>
        <span class="k">then</span>
<span class="k">          </span><span class="nv">_source</span><span class="o">=</span><span class="s2">&quot;$token&quot;</span>

        <span class="k">elif</span> <span class="o">[[</span> -z <span class="s2">&quot;${_target}&quot;</span> <span class="o">]]</span>
        <span class="k">then</span>
<span class="k">          </span><span class="nv">_target</span><span class="o">=</span><span class="s2">&quot;$token&quot;</span>
          <span class="nb">break</span>
<span class="nb">        </span><span class="k">fi</span>
        ;;
    <span class="k">esac</span>
<span class="k">  done</span>

<span class="k">  if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_source}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot move file as the source and target must be specified. &quot;</span>
  <span class="k">fi</span>

<span class="k">  if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_target}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot move file as the source and target must be specified. &quot;</span>
  <span class="k">fi</span>

<span class="k">  </span>mv <span class="s2">&quot;${_source}&quot;</span> <span class="s2">&quot;${_target}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_mode:-}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>chmod <span class="s2">&quot;${_mode}&quot;</span> <span class="s2">&quot;${_target}&quot;</span>
  <span class="k">fi</span>

<span class="k">  if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_owner:-}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>chown <span class="s2">&quot;${_owner}&quot;</span> <span class="s2">&quot;${_target}&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>copy_file</h2>

<p>Copys a file from one location to another.
(This is also used to rename a file.)</p>

<h3>Input Parameters</h3>

<p>The first parameter is the source file name
The second parameter is the target file name</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>If successful, a file is renamed (copyd).</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Fails if the source file is not specified.
Fails if the target file is not specified.</p>

<h3>Usage Examples</h3>

<pre><code>user$ copy_file "$HOME/.bashrc" to "$HOME/.bashrc.orig"
</code></pre>

</td><td class=code><div class=highlight><pre>
copy_file<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_source _target

  <span class="k">while</span> <span class="o">((</span> <span class="nv">$# </span>&gt; 0 <span class="o">))</span> ; <span class="k">do</span>
<span class="k">    </span><span class="nv">token</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span>
    <span class="nb">shift</span>
<span class="nb">    </span><span class="k">case</span> <span class="s2">&quot;${token}&quot;</span> in
      to<span class="o">)</span>
        <span class="nv">_target</span><span class="o">=</span><span class="s2">&quot;${1}&quot;</span>
        <span class="nb">shift</span>
        ;;
      from<span class="o">)</span>
        <span class="nv">_source</span><span class="o">=</span><span class="s2">&quot;${1}&quot;</span>
        <span class="nb">shift</span>
        ;;
      mode<span class="o">)</span>
         <span class="nv">_mode</span><span class="o">=</span><span class="s2">&quot;${1}&quot;</span>
         <span class="nb">shift</span>
        ;;
      owner<span class="o">)</span>
         <span class="nv">_owner</span><span class="o">=</span><span class="s2">&quot;${1}&quot;</span>
         <span class="nb">shift</span>
        ;;
      *<span class="o">)</span>
        <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_source:-}&quot;</span> <span class="o">]]</span>
        <span class="k">then</span>
<span class="k">          </span><span class="nv">_source</span><span class="o">=</span><span class="s2">&quot;$token&quot;</span>
          <span class="nb">shift</span>

<span class="nb">        </span><span class="k">elif</span> <span class="o">[[</span> -z <span class="s2">&quot;${_target:-}&quot;</span> <span class="o">]]</span>
        <span class="k">then</span>
<span class="k">          </span><span class="nv">_target</span><span class="o">=</span><span class="s2">&quot;$token&quot;</span>
          <span class="nb">break</span>
<span class="nb">        </span><span class="k">fi</span>
        ;;
    <span class="k">esac</span>
<span class="k">  done</span>

<span class="k">  </span>cp <span class="s2">&quot;${_source}&quot;</span> <span class="s2">&quot;${_target}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_mode:-}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>chmod <span class="s2">&quot;${_mode}&quot;</span> <span class="s2">&quot;${_target}&quot;</span>
  <span class="k">fi</span>

<span class="k">  if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_owner:-}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>chown <span class="s2">&quot;${_owner}&quot;</span> <span class="s2">&quot;${_target}&quot;</span>
  <span class="k">fi</span>

<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>copy<em>files</em>to</h2>

<p>depreciated, please use copy_files with the 'to' specifier instead</p>

</td><td class=code><div class=highlight><pre>
copy_files_to<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_path</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span> _file

  <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_path}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;Path was not given as the first parameter.&quot;</span>
  <span class="k">else</span>
<span class="k">    </span><span class="nb">shift</span>
<span class="nb">  </span><span class="k">fi</span>

<span class="k">  </span><span class="nb">local </span><span class="nv">_files</span><span class="o">=(</span><span class="s2">&quot;$@&quot;</span><span class="o">)</span>

  <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">_files</span><span class="p">[@]</span><span class="k">}</span> <span class="o">==</span> 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;No files were given in order to copy them into ${_path}.&quot;</span>
  <span class="k">fi</span>

<span class="k">  </span>log <span class="s2">&quot;copy_files_to is depreciated, please use copy_files with the &#39;to&#39; specifier instead&quot;</span>

  ensure_paths_exist <span class="s2">&quot;${_path}&quot;</span>

  <span class="k">for </span>_file in <span class="s2">&quot;${_files[@]}&quot;</span>
  <span class="k">do</span>
<span class="k">    if </span>file_is_missing <span class="s2">&quot;${_file}&quot;</span>
    <span class="k">then</span>
<span class="k">      </span>error <span class="s2">&quot;Cannot copy file ${_file} to ${_path} as the file does not exist.&quot;</span>
    <span class="k">else</span>
<span class="k">      </span>cp <span class="s2">&quot;${_file}&quot;</span> <span class="s2">&quot;${_path}/${_file}&quot;</span>
    <span class="k">fi</span>

<span class="k">  done</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>copy_files</h2>

<p>Copys a given list of files into the named path.</p>

<h3>Input Parameters</h3>

<p>The first parameter is the path to copy the files into.
Remaining parameters are the file name/path list.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>If successful, all named files are copied into the target path.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Fails if no target path is given.
Fails if no files are given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ copy_files "$HOME/.bashrc" "$HOME/.bash_profile" \
        to "$HOME/backup"
</code></pre>

</td><td class=code><div class=highlight><pre>
copy_files<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_source _target _file <span class="nv">_force_flag</span><span class="o">=</span>0 <span class="nv">_files</span><span class="o">=()</span>

  <span class="k">while</span> <span class="o">((</span> <span class="nv">$# </span>&gt; 0 <span class="o">))</span>
  <span class="k">do</span>
<span class="k">    </span><span class="nv">token</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span>
    <span class="nb">shift</span>

<span class="nb">    </span><span class="k">case</span> <span class="s2">&quot;${token}&quot;</span> in
      to<span class="o">)</span>
        <span class="nv">_target</span><span class="o">=</span><span class="s2">&quot;${1}&quot;</span>
        <span class="nb">shift</span>
        ;;
      from<span class="o">)</span>
        <span class="nv">_source</span><span class="o">=</span><span class="s2">&quot;${1}&quot;</span>
        <span class="nb">shift</span>
        ;;
      --force<span class="o">)</span>
        <span class="nv">_force_flag</span><span class="o">=</span>1
        ;;

      *<span class="o">)</span>
        _files+<span class="o">=(</span> <span class="s2">&quot;${token}&quot;</span> <span class="o">)</span>
        ;;
    <span class="k">esac</span>
<span class="k">  done</span>

<span class="k">  if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_target}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot copy files as no target path was given (eg. copy_files ... to {path}).&quot;</span>
  <span class="k">fi</span>

<span class="k">  if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">_files</span><span class="p">[@]</span><span class="k">}</span> <span class="o">==</span> 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot copy files as no files were given to copy.&quot;</span>
  <span class="k">fi</span>

<span class="k">  </span>ensure_paths_exist <span class="s2">&quot;${_target}&quot;</span>

  <span class="k">for </span>_file in <span class="s2">&quot;${_files[@]}&quot;</span>
  <span class="k">do</span>
<span class="k">    if </span>file_is_missing <span class="s2">&quot;${_file}&quot;</span>
    <span class="k">then</span>
<span class="k">      </span>error <span class="s2">&quot;Cannot copy file ${_file} to ${_target} as the file does not exist.&quot;</span>
    <span class="k">else</span>
<span class="k">      if</span> <span class="o">((</span> <span class="nv">_force_flag</span> <span class="o">==</span> 1 <span class="o">))</span>
      <span class="k">then</span>
<span class="k">        </span>cp -f <span class="s2">&quot;${_file}&quot;</span> <span class="s2">&quot;${_target}/${_file//*\/}&quot;</span>
      <span class="k">else</span>
<span class="k">        </span>cp <span class="s2">&quot;${_file}&quot;</span> <span class="s2">&quot;${_target}/${_file//*\/}&quot;</span>
      <span class="k">fi</span>
<span class="k">    fi</span>
<span class="k">  done</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>copy<em>directories</em>to</h2>

<p>Copys a given list of directories into the named path.</p>

<h3>Input Parameters</h3>

<p>The first parameter is the path to copy the directorys into.
Remaining parameters are the directory name/path list.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>If successful, all named directories are copied into the target path.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Fails if no target path is given.
Fails if no directories are given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ copy_directories_to "$HOME/backup/" "$HOME/bin" "$HOME/projects"
</code></pre>

</td><td class=code><div class=highlight><pre>
copy_directories_to<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_path</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span> _directory

  <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_path}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;Path was not given as the first parameter.&quot;</span>
  <span class="k">else</span>
<span class="k">    </span><span class="nb">shift</span>
<span class="nb">  </span><span class="k">fi</span>

<span class="k">  </span><span class="nb">local </span><span class="nv">_directories</span><span class="o">=(</span><span class="s2">&quot;$@&quot;</span><span class="o">)</span>

  <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">_directories</span><span class="p">[@]</span><span class="k">}</span> <span class="o">==</span> 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;No directories were given in order to copy them into ${_path}.&quot;</span>
  <span class="k">fi</span>

<span class="k">  </span>ensure_paths_exist <span class="s2">&quot;${_path}&quot;</span>

  <span class="k">for </span>_directory in <span class="s2">&quot;${_directories[@]}&quot;</span>
  <span class="k">do</span>
<span class="k">    if </span>directory_exists <span class="s2">&quot;${_directory}&quot;</span>
    <span class="k">then</span>
<span class="k">      </span>cp -Rf <span class="s2">&quot;${_directory}&quot;</span> <span class="s2">&quot;${_path}/&quot;</span>
    <span class="k">else</span>
<span class="k">      </span>error <span class="s2">&quot;Cannot copy directory ${_directory} to ${_path} as the directory &#39;${_directory}&#39; does not exist (in &#39;$PWD&#39;).&quot;</span>
    <span class="k">fi</span>
<span class="k">  done</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>copy_directories to</h2>

<p>Copys a given list of directories into the named path.</p>

<h3>Input Parameters</h3>

<p>The first parameter is the path to copy the directorys into.
Remaining parameters are the directory name/path list.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>If successful, all named directories are copied into the target path.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Fails if no target path is given.
Fails if no directories are given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ copy_directories to "$HOME/backup/" "$HOME/bin" "$HOME/projects"
</code></pre>

</td><td class=code><div class=highlight><pre>
copy_directories<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_source _target _directory <span class="nv">_force_flag</span><span class="o">=</span>0 <span class="nv">_directories</span><span class="o">=()</span>

  <span class="k">while</span> <span class="o">((</span> <span class="nv">$# </span>&gt; 0 <span class="o">))</span>
  <span class="k">do</span>
<span class="k">    </span><span class="nv">token</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span>
    <span class="nb">shift</span>

<span class="nb">    </span><span class="k">case</span> <span class="s2">&quot;${token}&quot;</span> in
      to<span class="o">)</span>
        <span class="nv">_target</span><span class="o">=</span><span class="s2">&quot;${1}&quot;</span>
        <span class="nb">shift</span>
        ;;
      from<span class="o">)</span>
        <span class="nv">_source</span><span class="o">=</span><span class="s2">&quot;${1}&quot;</span>
        <span class="nb">shift</span>
        ;;
      --force<span class="o">)</span>
        <span class="nv">_force_flag</span><span class="o">=</span>1
        ;;

      *<span class="o">)</span>
        _directories+<span class="o">=(</span> <span class="s2">&quot;${token}&quot;</span> <span class="o">)</span>
        ;;
    <span class="k">esac</span>
<span class="k">  done</span>

<span class="k">  if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_target}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot copy directories as no target path was given (eg. copy_directories ... to {path}).&quot;</span>
  <span class="k">fi</span>

<span class="k">  if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">_directories</span><span class="p">[@]</span><span class="k">}</span> <span class="o">==</span> 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot copy directories as no directories were given to copy.&quot;</span>
  <span class="k">fi</span>

<span class="k">  </span>ensure_paths_exist <span class="s2">&quot;${_target}&quot;</span>

  <span class="k">for </span>_directory in <span class="s2">&quot;${_directories[@]}&quot;</span>
  <span class="k">do</span>
<span class="k">    if </span>directory_exists <span class="s2">&quot;${_directory}&quot;</span>
    <span class="k">then</span>
<span class="k">      </span>cp -Rf <span class="s2">&quot;${_directory}&quot;</span> <span class="s2">&quot;${_target}/&quot;</span>
    <span class="k">else</span>
<span class="k">      </span>error <span class="s2">&quot;Cannot copy directory ${_directory} to ${_target} as the directory &#39;${_directory}&#39; does not exist (in &#39;$PWD&#39;).&quot;</span>
    <span class="k">fi</span>
<span class="k">  done</span>
<span class="o">}</span>


</pre></div></td></tr><tr><td class=docs>

<h2>copy_directory</h2>

<p>Copys a directory from one location to another.
(This is also used to rename a directory.)</p>

<h3>Input Parameters</h3>

<p>The first parameter is the source directory name
The second parameter is the target directory name</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>If successful, a directory is renamed (copyd).</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Fails if the source directory is not specified.
Fails if the target directory is not specified.</p>

<h3>Usage Examples</h3>

<pre><code>user$ copy_directory "freetds-0.91rc"* to "freetds-0.91"
</code></pre>

</td><td class=code><div class=highlight><pre>
copy_directory<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_source _target

  <span class="k">while</span> <span class="o">((</span> <span class="nv">$# </span>&gt; 0 <span class="o">))</span>
  <span class="k">do</span>
<span class="k">    </span><span class="nv">token</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span>
    <span class="nb">shift</span>
<span class="nb">    </span><span class="k">case</span> <span class="s2">&quot;${token}&quot;</span> in
      to<span class="o">)</span>
        <span class="nv">_target</span><span class="o">=</span><span class="s2">&quot;${1}&quot;</span>
        <span class="nb">shift</span>
        ;;
      from<span class="o">)</span>
        <span class="nv">_source</span><span class="o">=</span><span class="s2">&quot;${1}&quot;</span>
        <span class="nb">shift</span>
        ;;
      *<span class="o">)</span>
        <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_source}&quot;</span> <span class="o">]]</span>
        <span class="k">then</span>
<span class="k">          </span><span class="nv">_source</span><span class="o">=</span><span class="s2">&quot;$token&quot;</span>
          <span class="nb">shift</span>

<span class="nb">        </span><span class="k">elif</span> <span class="o">[[</span> -z <span class="s2">&quot;${_target}&quot;</span> <span class="o">]]</span>
        <span class="k">then</span>
<span class="k">          </span><span class="nv">_target</span><span class="o">=</span><span class="s2">&quot;$token&quot;</span>
          <span class="nb">break</span>
<span class="nb">        </span><span class="k">fi</span>
        ;;
    <span class="k">esac</span>
<span class="k">  done</span>

<span class="k">  </span>cp -Rf <span class="s2">&quot;${_source}&quot;</span> <span class="s2">&quot;${_target}&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>move<em>files</em>to</h2>

<p>Moves a given list of files into the named path.</p>

<h3>Input Parameters</h3>

<p>The first parameter is the path to move the files into.
Remaining parameters are the file name/path list.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>If successful, all named files are copied into the target path.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Fails if no target path is given.
Fails if no files are given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ move_files_to "$HOME/backup" "$HOME/.bashrc" "$HOME/.bash_profile"
</code></pre>

</td><td class=code><div class=highlight><pre>
move_files_to<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_path</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span> _file

  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_path}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;Path was not given as the first parameter.&quot;</span>
  <span class="k">else</span>
<span class="k">    </span><span class="nb">shift</span>
<span class="nb">  </span><span class="k">fi</span>

<span class="k">  </span>log <span class="s2">&quot;DEPRECIATED, use &#39;move_files ... to _path&#39; instead&quot;</span>

  <span class="nb">local </span><span class="nv">_files</span><span class="o">=(</span><span class="s2">&quot;$@&quot;</span><span class="o">)</span>

  <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">_files</span><span class="p">[@]</span><span class="k">}</span> &gt; 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;No files given in order to chmod ${_permissions} them.&quot;</span>
  <span class="k">fi</span>

<span class="k">  </span>ensure_paths_exist <span class="s2">&quot;${_path}&quot;</span>

  <span class="k">for </span>_file in <span class="s2">&quot;${_files[@]}&quot;</span>
  <span class="k">do</span>
<span class="k">    if </span>file_exists <span class="s2">&quot;${_file}&quot;</span>
    <span class="k">then</span>
<span class="k">      </span>mv <span class="s2">&quot;${_file}&quot;</span> <span class="s2">&quot;${_path}/${_file}&quot;</span>
    <span class="k">else</span>
<span class="k">      </span>error <span class="s2">&quot;Cannot move file ${_file} to ${_path} as the file does not exist.&quot;</span>
    <span class="k">fi</span>
<span class="k">  done</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>move_files</h2>

<p>Moves a given list of files into the named path.</p>

<h3>Input Parameters</h3>

<p>Parameters are file name/path for one or more files
Target directory is specified as 'to {{path}}'
Optional source directory is specified as 'from {{path}}'
Optional force flag '--force' may be specified</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>If successful, all named files are copied into the target path.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Fails if no target path is given.
Fails if no files are given.</p>

<h3>Usage Examples</h3>

<pre><code>user$
</code></pre>

<p>Alternatively,</p>

<pre><code>user$ move_files ".bashrc" ".bash_profile" from "$HOME" to "$HOME/backup"
</code></pre>

</td><td class=code><div class=highlight><pre>
move_files<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_source _target _file <span class="nv">_force_flag</span><span class="o">=</span>0 <span class="nv">_files</span><span class="o">=()</span>

  <span class="k">while</span> <span class="o">((</span> <span class="nv">$# </span>&gt; 0 <span class="o">))</span>
  <span class="k">do</span>
<span class="k">    </span><span class="nv">token</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span>
    <span class="nb">shift</span>

<span class="nb">    </span><span class="k">case</span> <span class="s2">&quot;${token}&quot;</span> in
      to<span class="o">)</span>
        <span class="nv">_target</span><span class="o">=</span><span class="s2">&quot;${1}&quot;</span>
        <span class="nb">shift</span>
        ;;
      from<span class="o">)</span>
        <span class="nv">_source</span><span class="o">=</span><span class="s2">&quot;${1}&quot;</span>
        <span class="nb">shift</span>
        ;;
      --force<span class="o">)</span>
        <span class="nv">_force_flag</span><span class="o">=</span>1
        ;;

      *<span class="o">)</span>
        _files+<span class="o">=(</span> <span class="s2">&quot;${token}&quot;</span> <span class="o">)</span>
        ;;
    <span class="k">esac</span>
<span class="k">  done</span>

<span class="k">  if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_target}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">_files</span><span class="p">[@]</span><span class="k">}</span> &gt; 0 <span class="o">))</span>
    <span class="k">then</span>
<span class="k">      if</span> <span class="o">[[</span> -d <span class="s2">&quot;${_target}&quot;</span> <span class="o">]]</span>
      <span class="k">then</span>
<span class="k">        for </span>_file in <span class="s2">&quot;${_files[@]}&quot;</span>
        <span class="k">do</span>
<span class="k">          if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_source}&quot;</span> <span class="o">]]</span>
          <span class="k">then</span>
<span class="k">            </span><span class="nv">_file</span><span class="o">=</span><span class="s2">&quot;${_source}/${_file}&quot;</span>
          <span class="k">fi</span>

<span class="k">          if </span>file_exists <span class="s2">&quot;${_file}&quot;</span>
          <span class="k">then</span>
<span class="k">            if</span> <span class="o">((</span> <span class="nv">_force_flag</span> <span class="o">==</span> 1 <span class="o">))</span>
            <span class="k">then</span>
<span class="k">              </span>mv -f <span class="s2">&quot;${_file}&quot;</span> <span class="s2">&quot;${_target}/${_file//*\/}&quot;</span>
            <span class="k">else</span>
<span class="k">              </span>mv <span class="s2">&quot;${_file}&quot;</span> <span class="s2">&quot;${_target}/${_file//*\/}&quot;</span>
            <span class="k">fi</span>
<span class="k">          else</span>
<span class="k">            </span>error <span class="s2">&quot;Cannot move file ${_file} to ${_path} as the file does not exist.&quot;</span>
          <span class="k">fi</span>
<span class="k">        done</span>
<span class="k">      else</span>
<span class="k">        </span>error <span class="s2">&quot;Cannot move files to &#39;${_target}&#39; as the directory does not exist&quot;</span>
      <span class="k">fi</span>
<span class="k">    else</span>
<span class="k">      </span>fail <span class="s2">&quot;Cannot move files as no files were given to move.&quot;</span>
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot move files as no target path was given (eg. move_files ... to {path}).&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>chown_files</h2>

<p>Change ownership of a list of files.</p>

<h3>Input Parameters</h3>

<p>First parameter is the new owner[:group] of the files.
Remaining parameters are the file names/paths.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if no new owner[:group] was specified.
Fails if no list of files was given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ chown_files $USER "$HOME/.bashrc" "$HOME/.bash_profile"
</code></pre>

</td><td class=code><div class=highlight><pre>
chown_files<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_identity</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span> _file

  <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_identity}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;user[:group] not given as the first parameter.&quot;</span>
  <span class="k">else</span>
<span class="k">    </span><span class="nb">shift</span>
<span class="nb">  </span><span class="k">fi</span>

<span class="k">  </span><span class="nb">local </span><span class="nv">_files</span><span class="o">=(</span><span class="s2">&quot;$@&quot;</span><span class="o">)</span>

  <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">_files</span><span class="p">[@]</span><span class="k">}</span> <span class="o">==</span> 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;No paths given to chmod ${_permissions}.&quot;</span>
  <span class="k">fi</span>

<span class="k">  for </span>_file in <span class="s2">&quot;${_files[@]}&quot;</span>
  <span class="k">do</span>
<span class="k">    if </span>file_exists <span class="s2">&quot;${_file}&quot;</span>
    <span class="k">then</span>
<span class="k">      </span>chown -R <span class="k">${</span><span class="nv">_identity</span><span class="k">}</span> <span class="s2">&quot;${_file}&quot;</span>
    <span class="k">else</span>
<span class="k">      </span>error <span class="s2">&quot;Cannot chown file ${_file} to ${_identity} as the file does not exist.&quot;</span>
    <span class="k">fi</span>
<span class="k">  done</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>chown_paths</h2>

<p>Change ownership of a list of paths.</p>

<h3>Input Parameters</h3>

<p>First parameter is the new owner[:group] of the paths.
Remaining parameters are the path names/paths.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if no new owner[:group] was specified.
Fails if no list of paths was given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ chown_paths $USER "$HOME" "/usr/local"
</code></pre>

</td><td class=code><div class=highlight><pre>
chown_paths<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_identity</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span> _path

  <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_identity}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;user[:group] not given as the first parameter.&quot;</span>
  <span class="k">else</span>
<span class="k">    </span><span class="nb">shift</span>
<span class="nb">  </span><span class="k">fi</span>

<span class="k">  </span><span class="nb">local </span><span class="nv">_paths</span><span class="o">=(</span><span class="s2">&quot;$@&quot;</span><span class="o">)</span>

  <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">_paths</span><span class="p">[@]</span><span class="k">}</span> <span class="o">==</span> 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;No paths given to chmod ${_permissions}.&quot;</span>
  <span class="k">fi</span>

<span class="k">  for </span>_path in <span class="s2">&quot;${_paths[@]}&quot;</span>
  <span class="k">do</span>
<span class="k">    if </span>directory_exists <span class="s2">&quot;${_path}&quot;</span>
    <span class="k">then</span>
<span class="k">      </span>chown <span class="k">${</span><span class="nv">_identity</span><span class="k">}</span> <span class="s2">&quot;${_path}&quot;</span>
    <span class="k">else</span>
<span class="k">      </span>error <span class="s2">&quot;Cannot chown path ${_path} to ${_identity} as the directory does not exist.&quot;</span>
    <span class="k">fi</span>
<span class="k">  done</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>chown<em>paths</em>recursively</h2>

<p>Change ownership of a list of paths, recursively.</p>

<h3>Input Parameters</h3>

<p>First parameter is the new owner[:group] of the paths.
Remaining parameters are the path names/paths.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if no new owner[:group] was specified.
Fails if no list of paths was given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ chown_paths_recursively $USER "$HOME" "/usr/local"
</code></pre>

</td><td class=code><div class=highlight><pre>
chown_paths_recursively<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_identity</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span> _path

  <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_identity}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;user[:group] not given as the first parameter!!&quot;</span>
  <span class="k">else</span>
<span class="k">    </span><span class="nb">shift</span>
<span class="nb">  </span><span class="k">fi</span>

<span class="k">  </span><span class="nb">local </span><span class="nv">_paths</span><span class="o">=(</span><span class="s2">&quot;$@&quot;</span><span class="o">)</span>

  <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">_paths</span><span class="p">[@]</span><span class="k">}</span> <span class="o">==</span> 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;No paths given to chmod ${_permissions}.&quot;</span>
  <span class="k">fi</span>

<span class="k">  for </span>_path in <span class="s2">&quot;${_paths[@]}&quot;</span>
  <span class="k">do</span>
<span class="k">    if </span>directory_exists <span class="s2">&quot;${_path}&quot;</span>
    <span class="k">then</span>
<span class="k">      </span>chown -R <span class="k">${</span><span class="nv">_identity</span><span class="k">}</span> <span class="s2">&quot;${_path}&quot;</span>
    <span class="k">else</span>
<span class="k">      </span>error <span class="s2">&quot;Cannot recursively chown ${_path} to ${_identity} as the directory does not exist.&quot;</span>
    <span class="k">fi</span>
<span class="k">  done</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>chmod_files</h2>

<p>Change ownership of a list of files.</p>

<h3>Input Parameters</h3>

<p>First parameter is the new owner[:group] of the files.
Remaining parameters are the file names/files.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if no new owner[:group] was specified.
Fails if no list of files was given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ chmod_files $USER "$HOME" "/usr/local"
</code></pre>

</td><td class=code><div class=highlight><pre>
chmod_files<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_permissions</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span> _file _message

  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_permissions}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span><span class="nb">shift</span>
<span class="nb">    local </span><span class="nv">_files</span><span class="o">=(</span><span class="s2">&quot;$@&quot;</span><span class="o">)</span>

    <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">_files</span><span class="p">[@]</span><span class="k">}</span> &gt; 0 <span class="o">))</span>
    <span class="k">then</span>
<span class="k">      for </span>_file in <span class="s2">&quot;${_files[@]}&quot;</span>
      <span class="k">do</span>
<span class="k">        if </span>file_exists <span class="s2">&quot;${_file}&quot;</span>
        <span class="k">then</span>
<span class="k">          </span>chmod <span class="k">${</span><span class="nv">_permissions</span><span class="k">}</span> <span class="s2">&quot;${_file}&quot;</span>
        <span class="k">else</span>
<span class="k">          </span><span class="nv">_message</span><span class="o">=(</span>
          <span class="s2">&quot;Cannot chmod file ${_file} to ${_permissions}&quot;</span>
          <span class="s2">&quot; as the file does not exist.&quot;</span>
          <span class="o">)</span>
          error <span class="s2">&quot;${_message[*]}&quot;</span>
        <span class="k">fi</span>
<span class="k">      done</span>
<span class="k">    else</span>
<span class="k">      </span>fail <span class="s2">&quot;No files given to chmod ${_permissions}.&quot;</span>
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Permissions not given as the first parameter!!&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>chmod_paths</h2>

<p>Change ownership of a list of paths.</p>

<h3>Input Parameters</h3>

<p>First parameter is the new owner[:group] of the paths.
Remaining parameters are the path names/paths.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if no new owner[:group] was specified.
Fails if no list of paths was given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ chmod_paths $USER "$HOME" "/usr/local"
</code></pre>

</td><td class=code><div class=highlight><pre>
chmod_paths<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_permissions</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span> _path _message

  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_permissions}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span><span class="nb">shift</span>
<span class="nb">    local </span><span class="nv">_paths</span><span class="o">=(</span><span class="s2">&quot;$@&quot;</span><span class="o">)</span>
    <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">_paths</span><span class="p">[@]</span><span class="k">}</span> &gt; 0 <span class="o">))</span>
    <span class="k">then</span>
<span class="k">      for </span>_path in <span class="s2">&quot;${_paths[@]}&quot;</span>
      <span class="k">do</span>
<span class="k">        if </span>directory_exists <span class="s2">&quot;${_path}&quot;</span>
        <span class="k">then</span>
<span class="k">          </span>chmod <span class="k">${</span><span class="nv">_permissions</span><span class="k">}</span> <span class="s2">&quot;${_path}&quot;</span>
        <span class="k">else</span>
<span class="k">          </span><span class="nv">_message</span><span class="o">=(</span>
          <span class="s2">&quot;Cannot chmod directory ${_path} to ${_permissions}&quot;</span>
          <span class="s2">&quot; as the directory does not exist.&quot;</span><span class="o">)</span>
          error <span class="s2">&quot;${_message[*]}&quot;</span>
        <span class="k">fi</span>
<span class="k">      done</span>
<span class="k">    else</span>
<span class="k">      </span><span class="nv">_message</span><span class="o">=(</span>
      <span class="s2">&quot;Cannot chmod_paths as no paths were given in &quot;</span>
      <span class="s2">&quot;order to change permissions to ${_permissions}.&quot;</span>
      <span class="o">)</span>
      fail <span class="s2">&quot;${_message[*]}&quot;</span>
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">    </span><span class="nv">_message</span><span class="o">=(</span>
    <span class="s2">&quot;Cannot chmod_paths as the permissions were &quot;</span>
    <span class="s2">&quot;not given as the first parameter!!&quot;</span>
    <span class="o">)</span>
    fail <span class="s2">&quot;${_message[*]}&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>chmod<em>paths</em>recursively</h2>

<p>Change ownership of a list of paths, recursively.</p>

<h3>Input Parameters</h3>

<p>First parameter is the new owner[:group] of the paths.
Remaining parameters are the path names/paths.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if no new owner[:group] was specified.
Fails if no list of paths was given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ chmod_paths_recursively $USER "$HOME" "/usr/local"
</code></pre>

</td><td class=code><div class=highlight><pre>
chmod_paths_recursively<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_permissions</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span> _path _message

  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_permissions}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span><span class="nb">shift</span>
<span class="nb">    local </span><span class="nv">_paths</span><span class="o">=(</span><span class="s2">&quot;$@&quot;</span><span class="o">)</span>

    <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">_paths</span><span class="p">[@]</span><span class="k">}</span> &gt; 0 <span class="o">))</span>
    <span class="k">then</span>
<span class="k">      for </span>_path in <span class="s2">&quot;${_paths[@]}&quot;</span>
      <span class="k">do</span>
<span class="k">        if </span>directory_exists <span class="s2">&quot;${_path}&quot;</span>
        <span class="k">then</span>
<span class="k">          </span>chmod -R <span class="k">${</span><span class="nv">_permissions</span><span class="k">}</span> <span class="s2">&quot;${_path}&quot;</span>
        <span class="k">else</span>
<span class="k">          </span><span class="nv">_message</span><span class="o">=(</span>
          <span class="s2">&quot;Cannot chmod directory ${_path} to ${_permissions} &quot;</span>
          <span class="s2">&quot;as the directory does not exist.&quot;</span>
          <span class="o">)</span>
          error <span class="s2">&quot;${_message[*]}&quot;</span>
        <span class="k">fi</span>
<span class="k">      done</span>
<span class="k">    else</span>
<span class="k">      </span>fail <span class="s2">&quot;No paths given to chmod ${_permissions}.&quot;</span>
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Permissions not given as the first parameter!!&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>enter</h2>

<p>Changes the current working directory ($PWD) to the given directory with
sanity checks.</p>

<h3>Input Parameters</h3>

<p>First parameter is the directory to change into.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>The current working directory (PWD) will become the given directory if
successful.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if no directory was given.
Fails if the given directory does not exist.</p>

<h3>Usage Examples</h3>

<pre><code>user$ enter "/usr/local/src"
</code></pre>

</td><td class=code><div class=highlight><pre>
enter<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_path</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_path}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    if</span> <span class="o">[[</span> -d <span class="s2">&quot;${_path}&quot;</span> <span class="o">]]</span>
    <span class="k">then</span>
<span class="k">      if</span> ! <span class="nb">builtin cd</span> <span class="s2">&quot;${_path}&quot;</span>
      <span class="k">then</span>
<span class="k">        </span>error <span class="s2">&quot;There was an error ($?) while entering the directory &#39;${_path}&#39;.&quot;</span>
      <span class="k">fi</span>
<span class="k">    else</span>
<span class="k">      </span>error <span class="s2">&quot;Cannot enter the directory &#39;${_path}&#39; as it does not exist.&quot;</span>
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot enter a directory as no directory was given.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>hash_file</h2>

<p>Set and get key/value pairs from a given has file.</p>

<h3>Input Parameters</h3>

<p>The first parameter is the file name/path for the hash file.
The second parameter is the key name.
The third (optional) parameter is the value to assign to the given key.</p>

<h3>Stream Outputs</h3>

<p>The value of the key retrieved is printed if no value parameter was given.</p>

<h3>Environmental effects</h3>

<p>If a value parameter was given the key=value pair is written to the named
hash file.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if no file name/path was provided.
Fails if no key name was given.
Fails if the file path does not exist.</p>

<h3>Usage Examples</h3>

<pre><code>user$ hash_file /usr/local/bdsm/extensions/core/config/defaults website_url
https://bdsm.beginrescueend.com/
</code></pre>

</td><td class=code><div class=highlight><pre>
hash_file<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_file</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span> _message

  <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_file}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;File path/name not given.\n =&gt; Usage: $0 &lt;filename&gt; &lt;key&gt; [value]&quot;</span>
  <span class="k">else</span>
<span class="k">    </span><span class="nb">shift</span>
<span class="nb">  </span><span class="k">fi</span>

<span class="k">  </span><span class="nb">local </span><span class="nv">_key</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_key}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;Key not given.\n =&gt; Usage: $0 &lt;filename&gt; &lt;key&gt; [value]&quot;</span>
  <span class="k">else</span>
<span class="k">    </span><span class="nb">shift</span>
<span class="nb">  </span><span class="k">fi</span>

<span class="k">  </span><span class="nb">local </span><span class="nv">_path</span><span class="o">=</span><span class="k">$(</span>dirname <span class="s2">&quot;${_file}&quot;</span><span class="k">)</span>
  <span class="k">if</span> <span class="o">[[</span> -d <span class="s2">&quot;${_path}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>ensure_files_exist <span class="s2">&quot;$_file&quot;</span>
  <span class="k">else</span>
<span class="k">    </span><span class="nv">_message</span><span class="o">=(</span>
    <span class="s2">&quot;Cannot access the database file &#39;${_file}&#39; &quot;</span>
    <span class="s2">&quot;as the directory &#39;${_file%\/*}&#39; does not exist.&quot;</span>
    <span class="o">)</span>
    error <span class="s2">&quot;{$_message[*]}&quot;</span>
  <span class="k">fi</span>

<span class="k">  </span><span class="nv">value</span><span class="o">=</span><span class="s2">&quot;$*&quot;</span>
  <span class="k">case</span> <span class="s2">&quot;$value&quot;</span> in
    <span class="nb">unset</span>|delete<span class="o">)</span>
      sed -i.tmp <span class="s2">&quot;s#^${_key}=.*\$##&quot;</span> <span class="s2">&quot;${_file}&quot;</span>
      ;;
    *<span class="o">)</span>
      <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${value}&quot;</span> <span class="o">]]</span>
      <span class="k">then</span> <span class="c"># get</span>
        awk -F<span class="o">=</span> <span class="s1">&#39;/^&#39;</span><span class="s2">&quot;${_key}&quot;</span><span class="s1">&#39;=/{print $2}&#39;</span> <span class="s2">&quot;$_file&quot;</span>
      <span class="k">else</span> <span class="c"># set</span>
        <span class="k">if</span> ! awk -F<span class="o">=</span> <span class="s2">&quot;/^&#39;&quot;</span><span class="k">${</span><span class="nv">_key</span><span class="k">}</span><span class="s2">&quot;&#39;=/{print $2}&quot;</span> <span class="s2">&quot;${_file}&quot;</span> &gt;/dev/null 2&gt;&amp;1
        <span class="k">then</span>
<span class="k">          </span><span class="nb">echo</span> <span class="s2">&quot;${_key}=$value&quot;</span> &gt;&gt; <span class="s2">&quot;${_file}&quot;</span>
        <span class="k">else</span> <span class="c"># overwrite</span>
          sed -i.tmp <span class="s2">&quot;s#^${_key}=.*\$#${_key}=$value#&quot;</span> <span class="s2">&quot;${_file}&quot;</span>
        <span class="k">fi</span>
<span class="k">      fi</span>
      ;;
  <span class="k">esac</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>file<em>is</em>executable</h2>

<p>Check if a file name/path is executable.</p>

<h3>Input Parameters</h3>

<p>First parameter is a file name/path.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 if the named file is executable.
1 if the named file is not executable or does not exist.</p>

<h3>Failure Scenarios</h3>

<p>Fails if no file name/path was given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ file_is_executable /bin/bash
user$ echo $?
0

user$ file_is_executable /bin/asdfasdf
user$ echo $?
1
</code></pre>

</td><td class=code><div class=highlight><pre>
file_is_executable<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_file</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_file}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    if</span> <span class="o">[[</span> -x <span class="s2">&quot;${_file}&quot;</span> <span class="o">]]</span>
    <span class="k">then</span>
<span class="k">      return </span>0
    <span class="k">else</span>
<span class="k">      return </span>1
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot check if a file is executable as no file path/name was given&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>file_exists</h2>

<p>Check if a file name/path exists.</p>

<h3>Input Parameters</h3>

<p>First parameter is a file name/path.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 if the named file exists.
1 if the named file does not exist or does not exist.</p>

<h3>Failure Scenarios</h3>

<p>Fails if no file name/path was given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ file_exists /bin/bash
user$ echo $?
0

user$ file_exists /bin/asdfasdf
user$ echo $?
1
</code></pre>

</td><td class=code><div class=highlight><pre>
file_exists<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_file</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>
  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_file}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    if</span> <span class="o">[[</span> -f <span class="s2">&quot;${_file}&quot;</span> <span class="o">]]</span>
    <span class="k">then</span>
<span class="k">      return </span>0
    <span class="k">else</span>
<span class="k">      return </span>1
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot check to see if a file exists as no file name/path was given&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>file<em>is</em>nonempty</h2>

<p>Check if a file name/path is nonempty.</p>

<h3>Input Parameters</h3>

<p>First parameter is a file name/path.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 if the named file is nonempty.
1 if the named file is empty or does not exist.</p>

<h3>Failure Scenarios</h3>

<p>Fails if no file name/path was given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ file_is_nonempty /bin/bash
user$ echo $?
0

user$ file_is_nonempty /bin/asdfasdf
user$ echo $?
1
</code></pre>

</td><td class=code><div class=highlight><pre>
file_is_nonempty<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_file</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_file}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    if</span> <span class="o">[[</span> -d <span class="s2">&quot;${_file}&quot;</span> <span class="o">]]</span>
    <span class="k">then</span>
<span class="k">      </span>error <span class="s2">&quot;When checking whether the file &#39;${_file}&#39; is nonempty, a directory was found in its place.&quot;</span>
    <span class="k">else</span>
<span class="k">      if</span> <span class="o">[[</span> -s <span class="s2">&quot;${_file}&quot;</span> <span class="o">]]</span>
      <span class="k">then</span>
<span class="k">        return </span>0
      <span class="k">else</span>
<span class="k">        return </span>1
      <span class="k">fi</span>
<span class="k">    fi</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot check if file is nonempty as no file path/name was given&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>file<em>is</em>empty</h2>

<p>Check if a file name/path is empty.</p>

<h3>Input Parameters</h3>

<p>First parameter is a file name/path.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 if the named file is empty.
1 if the named file is not empty or does not exist.</p>

<h3>Failure Scenarios</h3>

<p>Fails if no file name/path was given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ file_is_empty /bin/bash
user$ echo $?
1

user$ file_is_empty /bin/asdfasdf
user$ echo $?
0
</code></pre>

</td><td class=code><div class=highlight><pre>
file_is_empty<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_file</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_file}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    if</span> <span class="o">[[</span> -f <span class="s2">&quot;${_file}&quot;</span> <span class="o">&amp;&amp;</span> ! -s <span class="s2">&quot;${_file}&quot;</span> <span class="o">]]</span>
    <span class="k">then</span>
<span class="k">      return </span>0
    <span class="k">else</span>
<span class="k">      return </span>1
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot check if a file is empty as no file path/name was given&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>file<em>is</em>missing</h2>

<p>Check if a file name/path is missing.</p>

<h3>Input Parameters</h3>

<p>First parameter is a file name/path.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 if the named file is missing.
1 if the named file is not missing or does not exist.</p>

<h3>Failure Scenarios</h3>

<p>Fails if no file name/path was given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ file_is_missing /bin/bash
user$ echo $?
1

user$ file_is_missing /bin/asdfasdf
user$ echo $?
0
</code></pre>

</td><td class=code><div class=highlight><pre>
file_is_missing<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_file</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_file}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    if</span> <span class="o">[[</span> ! -f <span class="s2">&quot;${_file}&quot;</span> <span class="o">]]</span>
    <span class="k">then</span>
<span class="k">      return </span>0
    <span class="k">else</span>
<span class="k">      return </span>1
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot check if file is missing as no file path/name was given&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>file<em>is</em>empty<em>or</em>missing</h2>

<p>Check if a file name/path is empty or missing.</p>

<h3>Input Parameters</h3>

<p>First parameter is a file name/path.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 if the named file is empty or missing.
1 if the named file exists or is nonempty.</p>

<h3>Failure Scenarios</h3>

<p>Fails if no file name/path was given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ file_is_missing /bin/bash
user$ echo $?
1

user$ file_is_missing /bin/asdfasdf
user$ echo $?
0
</code></pre>

</td><td class=code><div class=highlight><pre>
file_is_empty_or_missing<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_file</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_file}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    if</span> <span class="o">[[</span> ! -f <span class="s2">&quot;${_file}&quot;</span> <span class="o">||</span> ! -s <span class="s2">&quot;${_file}&quot;</span> <span class="o">]]</span>
    <span class="k">then</span>
<span class="k">      return </span>0
    <span class="k">else</span>
<span class="k">      return </span>1
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot check if file is empty or missing as no file path/name was given&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>file_contains()</h2>

<p>Checks if a named file contains a given string/unix regexp pattern.</p>

<h3>Input Parameters</h3>

<p>First parameter is the file name/path.
Second parameter is the pattern to match.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 if the given file contains the given pattern.
1 if the given file does not contain the given pattern.</p>

<h3>Failure Scenarios</h3>

<p>Fails if the file path/name was not given
Fails if the pattern is not given.
Fails if the file path/name given either does not exist or is not a file.</p>

<h3>Usage Examples</h3>

<pre><code>user$ cat "$HOME/test"
#!/usr/bin/env bash
source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.

modules filesystem

if file_contains "$HOME/.bdsmrc" ".*w00t.*"
then
  echo "w00t! "
else
  echo "no w00t :("
fi
</code></pre>

</td><td class=code><div class=highlight><pre>
file_contains<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_file</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span> _message

  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_file}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span><span class="nb">shift</span>
<span class="nb">    local </span><span class="nv">_pattern</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>
    <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_pattern}&quot;</span> <span class="o">]]</span>
    <span class="k">then</span>
<span class="k">      if</span> <span class="o">[[</span> -f <span class="s2">&quot;${_file}&quot;</span> <span class="o">]]</span>
      <span class="k">then</span>
<span class="k">        if </span>grep <span class="s2">&quot;${_pattern}&quot;</span> <span class="s2">&quot;${_file}&quot;</span> &gt;/dev/null 2&gt;&amp;1
        <span class="k">then</span>
<span class="k">          return </span>0
        <span class="k">else</span>
<span class="k">          return </span>1
        <span class="k">fi</span>
<span class="k">      else</span>
<span class="k">        </span><span class="nv">_message</span><span class="o">=(</span>
        <span class="s2">&quot;First parameter must be a file, &#39;${_file}&#39;&quot;</span>
        <span class="s2">&quot; does not appear to be a file.&quot;</span>
        <span class="o">)</span>
        fail <span class="s2">&quot;${_message[*]}&quot;</span>
      <span class="k">fi</span>
<span class="k">    else</span>
<span class="k">      </span>fail <span class="s2">&quot;String pattern for search was not given!&quot;</span>
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;File path/name was not given!&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>symlink_exists</h2>

<p>Check if a symlink name/path exists.</p>

<h3>Input Parameters</h3>

<p>First parameter is a symlink name/path.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 if the named symlink exists.
1 if the named symlink does not exist or does not exist.</p>

<h3>Failure Scenarios</h3>

<p>Fails if no symlink name/path was given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ symlink_exists /usr/local/bin/bdsm
user$ echo $?
0

user$ symlink_exists /bin/asdfasdf
user$ echo $?
1
</code></pre>

</td><td class=code><div class=highlight><pre>
symlink_exists<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_file</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_file}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    if</span> <span class="o">[[</span> -L <span class="s2">&quot;${_file}&quot;</span> <span class="o">]]</span>
    <span class="k">then</span>
<span class="k">      return </span>0
    <span class="k">else</span>
<span class="k">      return </span>1
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot check if symlink exists as no path/name was given&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>directory_exists</h2>

<p>Check if a directory name/path exists.</p>

<h3>Input Parameters</h3>

<p>First parameter is a directory name/path.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 if the named directory exists.
1 if the named directory does not exist or does not exist.</p>

<h3>Failure Scenarios</h3>

<p>Fails if no directory name/path was given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ directory_exists /usr/local/bin/bdsm
user$ echo $?
0

user$ directory_exists /bin/asdfasdf
user$ echo $?
1
</code></pre>

</td><td class=code><div class=highlight><pre>
directory_exists<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_directory</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_directory}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    if</span> <span class="o">[[</span> -d <span class="s2">&quot;$_directory&quot;</span> <span class="o">]]</span>
    <span class="k">then</span>
<span class="k">      return </span>0
    <span class="k">else</span>
<span class="k">      return </span>1
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot check if directory exists as no name/path was given&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>function_name</h2>

<p>Function Description</p>

<h3>Input Parameters</h3>

<p>Positional Parameter listing and descriptions.</p>

<h3>Stream Outputs</h3>

<p>What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.</p>

<h3>Environmental effects</h3>

<p>What, if any, environmental side effects this function causes. 'None.' for none.</p>

<h3>Return Codes</h3>

<p>0 if ...
1 if ...</p>

<h3>Failure Scenarios</h3>

<p>Fails if ...</p>

<h3>Usage Examples</h3>

<pre><code>user$ {{ setup the scenario }}
user$ function_name {{ parameters }}
user$ {{ demonstrate the results}}
</code></pre>

</td><td class=code><div class=highlight><pre>
directories_in<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_path</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${path}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    if</span> <span class="o">[[</span> -d <span class="s2">&quot;${_path}&quot;</span> <span class="o">]]</span>
    <span class="k">then</span>
<span class="k">      if </span>find <span class="s2">&quot;${_path}&quot;</span> -mindepth 1 -maxdepth 1 -type d
      <span class="k">then</span>
<span class="k">        return </span>0
      <span class="k">else</span>
<span class="k">        return </span>1
      <span class="k">fi</span>
<span class="k">    else</span>
<span class="k">      </span>fail <span class="s2">&quot;&#39;${_path}&#39; is not a directory!&quot;</span>
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Directory name/path was not given!&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

directories_in_matching<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_path</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span> <span class="nv">_pattern</span><span class="o">=</span><span class="s2">&quot;${2:-}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${path}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    if</span> <span class="o">[[</span> -d <span class="s2">&quot;${_path}&quot;</span> <span class="o">]]</span>
    <span class="k">then</span>
<span class="k">      if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_pattern}&quot;</span> <span class="o">]]</span>
      <span class="k">then</span>
<span class="k">        if </span>find <span class="s2">&quot;${_path}&quot;</span> -mindepth 1 -maxdepth 1 -type d
        <span class="k">then</span>
<span class="k">          return </span>0
        <span class="k">else</span>
<span class="k">          return </span>1
        <span class="k">fi</span>
<span class="k">      else</span>
<span class="k">        </span>fail <span class="s2">&quot;&#39;${_path}&#39; is not a directory!&quot;</span>
      <span class="k">fi</span>
<span class="k">    else</span>
<span class="k">      </span>fail <span class="s2">&quot;&#39;${_path}&#39; is not a directory!&quot;</span>
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Directory name/path was not given!&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

directories_under<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_path</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${path}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    if</span> <span class="o">[[</span> -d <span class="s2">&quot;${_path}&quot;</span> <span class="o">]]</span>
    <span class="k">then</span>
<span class="k">      if </span>find <span class="s2">&quot;${_path}&quot;</span> -mindepth 1 -type d
      <span class="k">then</span>
<span class="k">        return </span>0
      <span class="k">else</span>
<span class="k">        return </span>1
      <span class="k">fi</span>
<span class="k">    else</span>
<span class="k">      </span>fail <span class="s2">&quot;&#39;${_path}&#39; is not a directory!&quot;</span>
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Directory name/path was not given!&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

directories_under_matching<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_path</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${path}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span><span class="nb">shift</span>
<span class="nb">    local </span><span class="nv">_pattern</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>
    <span class="k">if</span> <span class="o">[[</span> -d <span class="s2">&quot;${_path}&quot;</span> <span class="o">]]</span>
    <span class="k">then</span>
<span class="k">      if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_pattern}&quot;</span> <span class="o">]]</span>
      <span class="k">then</span>
<span class="k">        if </span>find <span class="s2">&quot;${_path}&quot;</span> -mindepth 1 -iname <span class="s2">&quot;${_pattern}&quot;</span> -type d
        <span class="k">then</span>
<span class="k">          return </span>0
        <span class="k">else</span>
<span class="k">          return </span>1
        <span class="k">fi</span>
<span class="k">      else</span>
<span class="k">        </span>fail <span class="s2">&quot;&#39;${_path}&#39; is not a directory!&quot;</span>
      <span class="k">fi</span>
<span class="k">    else</span>
<span class="k">      </span>fail <span class="s2">&quot;&#39;${_path}&#39; is not a directory!&quot;</span>
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Directory name/path was not given!&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>function_name</h2>

<p>Function Description</p>

<h3>Input Parameters</h3>

<p>Positional Parameter listing and descriptions.</p>

<h3>Stream Outputs</h3>

<p>What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.</p>

<h3>Environmental effects</h3>

<p>What, if any, environmental side effects this function causes. 'None.' for none.</p>

<h3>Return Codes</h3>

<p>0 if ...
1 if ...</p>

<h3>Failure Scenarios</h3>

<p>Fails if ...</p>

<h3>Usage Examples</h3>

<pre><code>user$ {{ setup the scenario }}
user$ function_name {{ parameters }}
user$ {{ demonstrate the results}}
</code></pre>

</td><td class=code><div class=highlight><pre>
files_in<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_path</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${path}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    if</span> <span class="o">[[</span> -d <span class="s2">&quot;${_path}&quot;</span> <span class="o">]]</span>
    <span class="k">then</span>
<span class="k">      if </span>find <span class="s2">&quot;${_path}&quot;</span> -mindepth 1 -maxdepth 1 -type f
      <span class="k">then</span>
<span class="k">        return </span>0
      <span class="k">else</span>
<span class="k">        return </span>1
      <span class="k">fi</span>
<span class="k">    else</span>
<span class="k">      </span>fail <span class="s2">&quot;&#39;${_path}&#39; is not a directory!&quot;</span>
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Directory name/path was not given!&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>function_name</h2>

<p>Function Description</p>

<h3>Input Parameters</h3>

<p>Positional Parameter listing and descriptions.</p>

<h3>Stream Outputs</h3>

<p>What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.</p>

<h3>Environmental effects</h3>

<p>What, if any, environmental side effects this function causes. 'None.' for none.</p>

<h3>Return Codes</h3>

<p>0 if ...
1 if ...</p>

<h3>Failure Scenarios</h3>

<p>Fails if ...</p>

<h3>Usage Examples</h3>

<pre><code>user$ {{ setup the scenario }}
user$ function_name {{ parameters }}
user$ {{ demonstrate the results}}
</code></pre>

</td><td class=code><div class=highlight><pre>
files_under<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_path</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${path}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    if</span> <span class="o">[[</span> -d <span class="s2">&quot;${_path}&quot;</span> <span class="o">]]</span>
    <span class="k">then</span>
<span class="k">      if </span>find <span class="s2">&quot;${_path}&quot;</span> -mindepth 1 -type f
      <span class="k">then</span>
<span class="k">        return </span>0
      <span class="k">else</span>
<span class="k">        return </span>1
      <span class="k">fi</span>
<span class="k">    else</span>
<span class="k">      </span>fail <span class="s2">&quot;&#39;${_path}&#39; is not a directory!&quot;</span>
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Directory name/path was not given!&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>files<em>in</em>path_matching</h2>

<p>Find all files in given path matching a given name glob pattern.</p>

<h3>Input Parameters</h3>

<p>First parameter is the path to search in
Second parameter is the pattern to match in</p>

<h3>Stream Outputs</h3>

<p>What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.</p>

<h3>Environmental effects</h3>

<p>What, if any, environmental side effects this function causes. 'None.' for none.</p>

<h3>Return Codes</h3>

<p>0 if ...
1 if ...</p>

<h3>Failure Scenarios</h3>

<p>Fails if ...</p>

<h3>Usage Examples</h3>

<pre><code>user$ files_in_path_matching ...
</code></pre>

</td><td class=code><div class=highlight><pre>
files_in_path_matching<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_path</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${path}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span><span class="nb">shift</span>
<span class="nb">    </span><span class="nv">_pattern</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>
    <span class="k">if</span> <span class="o">[[</span> -d <span class="s2">&quot;${_path}&quot;</span> <span class="o">]]</span>
    <span class="k">then</span>
<span class="k">      </span><span class="nb">shift</span>
<span class="nb">      </span><span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_pattern}&quot;</span> <span class="o">]]</span>
      <span class="k">then</span>
<span class="k">        if </span>find <span class="s2">&quot;${_path}&quot;</span> -mindepth 1 -iname <span class="s2">&quot;${_pattern}&quot;</span> -type f
        <span class="k">then</span>
<span class="k">          return </span>0
        <span class="k">else</span>
<span class="k">          return </span>1
        <span class="k">fi</span>
<span class="k">      else</span>
<span class="k">        </span>fail <span class="s2">&quot;Cannot find files as a filename or pattern was not given.&quot;</span>
      <span class="k">fi</span>
<span class="k">    else</span>
<span class="k">      </span>fail <span class="s2">&quot;&#39;${_path}&#39; is not a directory!&quot;</span>
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Directory name/path was not given!&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>replace_content</h2>

<p>Replaces a given (sed compatable) pattern with given replacement text in a
file.</p>

<h3>Input Parameters</h3>

<p>First parameter is the pattern
[optional 'with']
Second parameter is the replacement content
[optional 'in']
Third parameter is the file name/path</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>The pattern will be matched against the file name/path content and the
replacement text will be put in place.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if no pattern was given
Fails if replacement content was not given
Fails if filename was not given
Fails if the file does not exist</p>

<h3>Usage Examples</h3>

<h1>Replace contents in a file with a given (sed) regex pattern.</h1>

<pre><code>replace_content "^PREFIX =.*" with "${install_path}" in Makefile
</code></pre>

</td><td class=code><div class=highlight><pre>
replace_content<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_token _pattern _content _file _message

  <span class="k">while</span> <span class="o">((</span> <span class="nv">$# </span>&gt; 0 <span class="o">))</span>
  <span class="k">do</span>
<span class="k">    </span><span class="nv">_token</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span>
    <span class="nb">shift</span>

<span class="nb">    </span><span class="k">case</span> <span class="s2">&quot;${_token}&quot;</span> in
      <span class="o">(</span>with<span class="o">)</span>
        <span class="nv">_content</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>
        <span class="nb">shift</span>
        ;;
      <span class="o">(</span>in<span class="o">)</span>
        <span class="nv">_file</span><span class="o">=</span><span class="s2">&quot;${1}&quot;</span>
        <span class="nb">shift</span>
        ;;
      <span class="o">(</span>*<span class="o">)</span>
        <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_pattern}&quot;</span> <span class="o">]]</span>
        <span class="k">then</span>
<span class="k">          </span><span class="nv">_pattern</span><span class="o">=</span><span class="s2">&quot;${_token}&quot;</span>
        <span class="k">else</span>
<span class="k">          </span>fail <span class="s2">&quot;Unknown token &#39;${_token}&#39; passed as a parameter.&#39;&quot;</span>
        <span class="k">fi</span>
        ;;
    <span class="k">esac</span>
<span class="k">  done</span>

<span class="k">  if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_pattern:-}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_content:-}&quot;</span> <span class="o">]]</span>
    <span class="k">then</span>
<span class="k">      if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_file:-}&quot;</span> <span class="o">]]</span>
      <span class="k">then</span>
<span class="k">        if</span> <span class="o">[[</span> -f <span class="s2">&quot;${_file:-}&quot;</span> <span class="o">]]</span>
        <span class="k">then</span>
<span class="k">          if </span>sed -i -e <span class="s2">&quot;s#${_pattern//\#/\\#}#${_content//\#/\\#}#g&quot;</span> <span class="s2">&quot;${_file}&quot;</span>
          <span class="k">then</span>
<span class="k">            return </span>0
          <span class="k">else</span>
<span class="k">            return </span>1
          <span class="k">fi</span>
<span class="k">        else</span>
<span class="k">          </span>fail <span class="s2">&quot;Can not replace file content as the file does not exist.&quot;</span>
        <span class="k">fi</span>
<span class="k">      else</span>
<span class="k">        </span><span class="nv">_message</span><span class="o">=(</span>
        <span class="s2">&quot;Can not file content as the filename was not given,&quot;</span>
        <span class="s2">&quot; specify by &#39;in \&quot;/path/to/filename\&quot;&#39;&quot;</span>
        <span class="o">)</span>
        fail <span class="s2">&quot;${_message[*]}&quot;</span>
      <span class="k">fi</span>
<span class="k">    else</span>
<span class="k">      </span><span class="nv">_message</span><span class="o">=(</span>
      <span class="s2">&quot;Cannot replace content as the replacement content was not given, &quot;</span>
      <span class="s2">&quot;specify by &#39;with \&quot;replacement text\&quot;&#39;.&quot;</span>
      <span class="o">)</span>
      fail <span class="s2">&quot;${_message[*]}&quot;</span>
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot replace content as not even a pattern was given.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>file<em>matches</em>md5</h2>

<p>Checks to see if the given file matches the given md5 sum.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>none.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 if the file matches the md5sum
1 if the file does not match the md5sum
1 if the file is empty or missing</p>

<h3>Failure Scenarios</h3>

<p>Fails if no file name/path was given.
Fails if no md5 string was given.</p>

<h3>Usage Examples</h3>

<p>Example Usage:</p>

<p>user$ file<em>matches</em>md5</p>

<h3>Notes</h3>

</td><td class=code><div class=highlight><pre>
file_matches_md5<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_file</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span> <span class="nv">_md5</span><span class="o">=</span><span class="s2">&quot;$2&quot;</span> _file_md5

  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_file}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_md5}&quot;</span> <span class="o">]]</span>
    <span class="k">then</span>
<span class="k">      if</span> <span class="o">[[</span> -s <span class="s2">&quot;${_file}&quot;</span> <span class="o">]]</span>
      <span class="k">then</span>
<span class="k">        </span><span class="nv">_file_md5</span><span class="o">=</span><span class="s2">&quot;$(file_md5 &quot;</span><span class="k">${</span><span class="nv">_file</span><span class="k">}</span><span class="s2">&quot;)&quot;</span>

        <span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;${_file_md5// *}&quot;</span> <span class="o">=</span> <span class="s2">&quot;$_md5&quot;</span> <span class="o">]]</span>
        <span class="k">then</span>
<span class="k">          return </span>0
        <span class="k">else</span>
<span class="k">          return </span>1
        <span class="k">fi</span>
<span class="k">      else</span>
<span class="k">        return </span>1
      <span class="k">fi</span>
<span class="k">    else</span>
<span class="k">      </span>fail <span class="s2">&quot;Cannot determine if file matches md5 as no md5 was given.&quot;</span>
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot determine if file matches md5 as no file was given.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

extract_archive<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_archive</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_archive}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span><span class="nb">shift</span>
<span class="nb">    local </span><span class="nv">_path</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

    <span class="k">case</span> <span class="s2">&quot;${_archive}&quot;</span> in
      *.tar.gz|*.tgz<span class="o">)</span> <span class="c"># gzip</span>
        <span class="k">if</span> ! tar zxf <span class="s2">&quot;${_archive}&quot;</span>
        <span class="k">then</span>
<span class="k">          </span>error <span class="s2">&quot;There was an error while extracting the archive &#39;${_archive}&#39;&quot;</span>
        <span class="k">fi</span>
        ;;
      *tar.xz<span class="o">)</span> <span class="c"># LZMA</span>
</pre></div></td></tr><tr><td class=docs>

<p>TODO: if 'xz' command exists, use that, otherwise use tar J</p>

</td><td class=code><div class=highlight><pre>
        <span class="k">if</span> ! tar Jxf <span class="s2">&quot;${_archive}&quot;</span>
        <span class="k">then</span>
<span class="k">          </span>error <span class="s2">&quot;There was an error while extracting the archive &#39;${_archive}&#39;&quot;</span>
        <span class="k">fi</span>
        ;;
      *.tar.bz2<span class="o">)</span> <span class="c"># bzip</span>
        <span class="k">if</span> ! tar jxf <span class="s2">&quot;${_archive}&quot;</span>
        <span class="k">then</span>
<span class="k">          </span>error <span class="s2">&quot;There was an error while extracting the archive &#39;${_archive}&#39;&quot;</span>
        <span class="k">fi</span>
        ;;
      *.zip<span class="o">)</span>
        <span class="k">if</span> ! unzip <span class="s2">&quot;${_archive}&quot;</span> -d <span class="s2">&quot;${_path:-}&quot;</span>
        <span class="k">then</span>
<span class="k">          </span>error <span class="s2">&quot;There was an error while extracting the archive &#39;${_archive}&#39;&quot;</span>
        <span class="k">fi</span>
        ;;
      *<span class="o">)</span>
        error <span class="s2">&quot;Unknown archive format for ${_archive}&quot;</span>
        ;;
    <span class="k">esac</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot extract an archive to target location as no archive was given.&quot;</span>
  <span class="k">fi</span>

<span class="o">}</span>

file_md5<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_file</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span> _command _md5

  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_file}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    if </span>os_is_darwin
    <span class="k">then</span>
<span class="k">      </span><span class="nv">_command</span><span class="o">=</span><span class="s2">&quot;/sbin/md5 -q&quot;</span>

    <span class="k">else</span>
<span class="k">      if </span>command_exists <span class="s2">&quot;md5sum&quot;</span>
      <span class="k">then</span>
<span class="k">        </span><span class="nv">_command</span><span class="o">=</span><span class="s2">&quot;md5sum&quot;</span>

      <span class="k">elif </span>command_exists md5
      <span class="k">then</span>
<span class="k">        </span><span class="nv">_command</span><span class="o">=</span><span class="s2">&quot;md5&quot;</span>

      <span class="k">else</span>
<span class="k">        </span>error <span class="s2">&quot;Could not find a suitable md5 command in the path.&quot;</span>
      <span class="k">fi</span>
<span class="k">    fi</span>

<span class="k">    if </span><span class="nv">_md5</span><span class="o">=</span><span class="s2">&quot;$(${_command} &quot;</span><span class="nv">$_file</span><span class="s2">&quot; 2&gt;/dev/null)&quot;</span>
    <span class="k">then</span>
<span class="k">      </span><span class="nb">printf</span> <span class="s2">&quot;${_md5// *}&quot;</span>

    <span class="k">else</span> <span class="c"># Should this be error ?</span>
      warn <span class="s2">&quot;There was an unknown error computing the md5&quot;</span>
      <span class="k">return </span>1
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot calculate md5 of a file as no file name/path was given.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>



</td><td class=code><div class=highlight><pre>
</pre></div></td></tr><tr><td class=docs>

</pre></div></td></tr><tr><td class=docs>
</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs></td><td class='code'></td></tr>
    </tbody>
    </table>
</div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
    <meta http-eqiv='content-type' content='text/html;charset=utf-8'>
    <title>dsl</title>
    <link rel=stylesheet href="http://jashkenas.github.com/docco/resources/docco.css">
</head>
<body>
<div id=container>
    <div id=background></div>
    <table cellspacing=0 cellpadding=0>
    <thead>
      <tr>
        <th class=docs><h1>dsl</h1></th>
        <th class=code></th>
      </tr>
    </thead>
    <tbody>
        <tr><td class='docs'><h2>show_help()</h2>

<p>Display help for the current extension based on settings declared in the help
action.</p>

<h3>Input Parameters</h3>

<p>First parameter is the help section to display, default is all sections 'usage'.</p>

<h3>Stream Outputs</h3>

<p>Prints out formatted help sections to the calling environments STDOUT stream.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ show_help usage
</code></pre>

</td><td class=code><div class=highlight><pre>
<span class="c">#!/usr/bin/env bash</span>

show_help<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_help_command _token

  <span class="k">while</span> <span class="o">((</span> <span class="nv">$# </span>&gt; 0 <span class="o">))</span> ; <span class="k">do</span>
<span class="k">    </span><span class="nv">_token</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span> ; <span class="nb">shift</span>
<span class="nb">    </span><span class="k">case</span> <span class="s2">&quot;${_token}&quot;</span> in
      desc*|description<span class="o">)</span>
        <span class="nv">_help_command</span><span class="o">=</span><span class="s2">&quot;description&quot;</span>
        ;;
      actions<span class="o">)</span>
        <span class="nv">_help_command</span><span class="o">=</span><span class="s2">&quot;actions&quot;</span>
        ;;
      usage<span class="o">)</span>
        <span class="nv">_help_command</span><span class="o">=</span><span class="s2">&quot;usage&quot;</span>
        ;;
    <span class="k">esac</span>
<span class="k">  done</span>

  <span class="s2">&quot;${_help_command:-usage}&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>description()</h2>

<p>Set the string that will be printed when the actions help section is output.</p>

<h3>Input Parameters</h3>

<p>First parameter is a string containing a description of the extension.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Fails if no description is given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ description "This extension handles X Y and Z."
</code></pre>

</td><td class=code><div class=highlight><pre>
description<span class="o">()</span>
<span class="o">{</span>
  <span class="o">[[</span> -n <span class="s2">&quot;$*&quot;</span> <span class="o">]]</span> <span class="o">||</span> fail <span class="s2">&quot;Cannot add description to help as no help description was given.&quot;</span>

  help_descriptions+<span class="o">=(</span><span class="s2">&quot;$*&quot;</span><span class="o">)</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>help_description()</h2>

<p>Outputs the collected help description.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Prints the help description output.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>None.</p>

<h3>Usage Examples</h3>

<pre><code>user$ description "This extension handles X Y and Z."
</code></pre>

</td><td class=code><div class=highlight><pre>
help_description<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_description

  <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">help_descriptions</span><span class="p">[@]</span><span class="k">}</span> &gt; 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    </span>help_section <span class="s2">&quot;Description&quot;</span>

    <span class="k">for </span>_description in <span class="s2">&quot;${help_descriptions[@]}&quot;</span>
    <span class="k">do</span>
<span class="k">      </span><span class="nb">printf</span> <span class="s2">&quot;  %s\n&quot;</span> <span class="s2">&quot;${_description}&quot;</span>
    <span class="k">done</span>
<span class="k">  fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>actions()</h2>

<p>Set the string that will be printed when the actions help section is output.</p>

<h3>Input Parameters</h3>

<p>First parameter is a string of the action descriptions.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Fails if no actions are given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ actions "install  - Installs the extension..."
</code></pre>

</td><td class=code><div class=highlight><pre>
actions<span class="o">()</span>
<span class="o">{</span>
  <span class="o">[[</span> -n <span class="s2">&quot;$*&quot;</span> <span class="o">]]</span> <span class="o">||</span> fail <span class="s2">&quot;No help actions were given.&quot;</span>
  warn <span class="s2">&quot;help actions() is depreciated, use action() instead for each action.&quot;</span>
  <span class="nv">help_actions</span><span class="o">=</span><span class="s2">&quot;$*&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>action()</h2>

<p>Adds an action definition for help output.</p>

<h3>Input Parameters</h3>

<p>First parameter is the name of the extension action
Second parameter is the description of the extension action</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>The action description will be stored for use on help output.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Fails if an action name is not given.
Fails if a description is not provided.</p>

<h3>Usage Examples</h3>

<pre><code>user$ action "install"  "Installs the extension..."
</code></pre>

</td><td class=code><div class=highlight><pre>
action<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_name</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>
  <span class="nb">local </span><span class="nv">_description</span><span class="o">=</span><span class="s2">&quot;${2:-}&quot;</span>

  <span class="o">[[</span> -n <span class="s2">&quot;${_name}&quot;</span> <span class="o">&amp;&amp;</span> -n <span class="s2">&quot;${_description}&quot;</span> <span class="o">]]</span> <span class="o">||</span>
    fail <span class="s2">&quot;An action and a description must be provided:\naction {name} {description}&quot;</span>

  help_action_names+<span class="o">=(</span> <span class="s2">&quot;${_name}&quot;</span> <span class="o">)</span>
  help_action_descriptions+<span class="o">=(</span> <span class="s2">&quot;${_description}&quot;</span> <span class="o">)</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>note()</h2>

<p>Adds a note definition for help Notes section.</p>

<h3>Input Parameters</h3>

<p>First parameter is a string containing any note for the notes section of
the current extension's help output.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ note "Help for this extension can be found in #beginrescueend on irc.freenode.net"
</code></pre>

</td><td class=code><div class=highlight><pre>
note<span class="o">()</span>
<span class="o">{</span>
  help_notes+<span class="o">=(</span><span class="s2">&quot;$*&quot;</span><span class="o">)</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>dependencies()</h2>

<p>Specify content for the dependencies section of the help command.</p>

<h3>Input Parameters</h3>

<p>First parameter is a string containing any dependencies for the dependencies
section of the current extension's help output.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ dependencies " * pcre"
</code></pre>

</td><td class=code><div class=highlight><pre>
dependencies<span class="o">()</span>
<span class="o">{</span>
  <span class="nv">help_dependencies</span><span class="o">=</span><span class="s2">&quot;$*&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>resource()</h2>

<p>Add a resource for the Resources section of the help command.</p>

<h3>Input Parameters</h3>

<p>First parameter is a string containing any resources for the resources
section of the current extension's help output.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ resource "website: ..."
</code></pre>

</td><td class=code><div class=highlight><pre>
resource<span class="o">()</span>
<span class="o">{</span>
  help_resources+<span class="o">=(</span><span class="s2">&quot;$*&quot;</span><span class="o">)</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>help_actions()</h2>

<p>Outputs the help actions in a formatted manner.
Outputs a message if there are no actions.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Prints a formatted listing of the actions and their descriptions to the
calling environments STDOUT.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ cat $HOME/test
#!/usr/bin/env bash
source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
modules help

action "help" "Displays the help output for the ${extension} extension"
action "install" "Installs Z redis package"
action "uninstall" "Uninstalls Z redis package"

help_actions

user$ "$HOME/test"
help      - Displays the help output for the redis extension
install   - Installs Z redis package
uninstall - Uninstalls Z redis package
</code></pre>

</td><td class=code><div class=highlight><pre>
help_actions<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_largest _index

  <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">help_action_names</span><span class="p">[@]</span><span class="k">}</span> &gt; 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    </span><span class="nv">_largest</span><span class="o">=</span><span class="k">$(</span> array_largest help_action_names <span class="k">)</span> <span class="c"># Use the array DSL to grab largest</span>
    <span class="nv">_largest</span><span class="o">=</span><span class="k">$((</span> <span class="k">${#</span><span class="nv">_largest</span><span class="k">}</span> <span class="o">+</span> <span class="m">1</span> <span class="k">))</span>

    help_section <span class="s2">&quot;Actions&quot;</span>

    <span class="k">for</span> <span class="o">((</span> <span class="nv">_index</span><span class="o">=</span>0 ; _index &lt; <span class="k">${#</span><span class="nv">help_action_names</span><span class="p">[@]</span><span class="k">}</span> ; _index++ <span class="o">))</span>
    <span class="k">do</span>
<span class="k">      </span><span class="nb">printf</span> <span class="s2">&quot;  %-$((_largest + 2))s - %s\n&quot;</span> <span class="se">\</span>
        <span class="s2">&quot;${help_action_names[${_index}]}&quot;</span> <span class="s2">&quot;${help_action_descriptions[${_index}]}&quot;</span>
    <span class="k">done</span>
<span class="k">  else</span>
<span class="k">    </span>log <span class="s2">&quot;# No help has been defined for ${extension} actions .&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>help_notes()</h2>

<p>Outputs the help notes in a formatted manner.
Outputs a message if there are no notes.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Prints a formatted listing of the notes to the calling environments STDOUT.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ cat $HOME/test
#!/usr/bin/env bash
source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
modules help

note "Don't forget the milk! "
note "... and cookies... mmm...."

help_notes

user$ "$HOME/test"
* Don't forget the milk!
* ... and cookies... mmm....
</code></pre>

</td><td class=code><div class=highlight><pre>
help_notes<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_index

  <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">help_notes</span><span class="p">[@]</span><span class="k">}</span> &gt; 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    </span>help_section <span class="s2">&quot;Notes&quot;</span>

    <span class="k">for</span> <span class="o">((</span> <span class="nv">_index</span><span class="o">=</span>0 ; _index &lt; <span class="k">${#</span><span class="nv">help_notes</span><span class="p">[@]</span><span class="k">}</span> ; _index++ <span class="o">))</span>
    <span class="k">do</span>
<span class="k">      </span><span class="nb">printf</span> <span class="s2">&quot;  * %s\n&quot;</span> <span class="s2">&quot;${help_notes[${_index}]}&quot;</span>
    <span class="k">done</span>
<span class="k">  fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>help_dependencies()</h2>

<p>Outputs the help dependencies in a formatted manner.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Prints a formatted listing of the current extensions defined dependencies to
the calling environments STDOUT.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

</td><td class=code><div class=highlight><pre>
help_dependencies<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_index

  <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">help_dependencies</span><span class="p">[@]</span><span class="k">}</span> &gt; 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    </span>help_section <span class="s2">&quot;Dependencies&quot;</span>

    <span class="k">for</span> <span class="o">((</span> <span class="nv">_index</span><span class="o">=</span>0 ; _index &lt; <span class="k">${#</span><span class="nv">help_dependencies</span><span class="p">[@]</span><span class="k">}</span> ; _index++ <span class="o">))</span>
    <span class="k">do</span>
<span class="k">      </span><span class="nb">printf</span> <span class="s2">&quot; * %s\n&quot;</span> <span class="s2">&quot;${help_dependencies[${_index}]}&quot;</span>
    <span class="k">done</span>
<span class="k">  fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>help_resources()</h2>

<p>Outputs the help notes in a formatted manner.
Outputs a message if there are no notes.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Prints a formatted listing of the defined resources to the calling
environments STDOUT.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

</td><td class=code><div class=highlight><pre>
help_resources<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_index

  <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">help_resources</span><span class="p">[@]</span><span class="k">}</span> &gt; 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    </span>help_section <span class="s2">&quot;Resources&quot;</span>

    <span class="k">for</span> <span class="o">((</span> <span class="nv">_index</span><span class="o">=</span>0 ; _index &lt; <span class="k">${#</span><span class="nv">help_resources</span><span class="p">[@]</span><span class="k">}</span> ; _index++ <span class="o">))</span>
    <span class="k">do</span>
<span class="k">      </span><span class="nb">printf</span> <span class="s2">&quot; * %s\n&quot;</span> <span class="s2">&quot;${help_resources[${_index}]}&quot;</span>
    <span class="k">done</span>
<span class="k">  fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>help_section()</h2>

<p>Displays a help section header.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Prints the given string as a help section header.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ help_section Usage
</code></pre>

</td><td class=code><div class=highlight><pre>
help_section<span class="o">()</span>
<span class="o">{</span>
  log <span class="s2">&quot;\n$*\n&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>help_usage()</h2>

<p>Display the CLI signature.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Prints the CLI command signature.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ help_usage
bdsm core {action} [arguments...]
</code></pre>

</td><td class=code><div class=highlight><pre>
help_usage<span class="o">()</span>
<span class="o">{</span>
  help_section <span class="s2">&quot;Usage&quot;</span>
  log <span class="s2">&quot;  bdsm ${extension} {action} [arguments...]&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>usage()</h2>

<p>Display the usage help output of the command. This displays all help sections.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Prints all help sections to the STDOUT of the calling environment.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ usage
</code></pre>

</td><td class=code><div class=highlight><pre>
usage<span class="o">()</span>
<span class="o">{</span>
  bdsm_version

  log <span class="s2">&quot;\nbdsm ${bdsm_version} https://bdsm.beginrescueend.com/ by Wayne E. Seguin (wayneeseguin@gmail.com)&quot;</span>

  <span class="nv">sections</span><span class="o">=(</span>usage description actions notes dependencies resources<span class="o">)</span>
  <span class="k">for </span>section in <span class="s2">&quot;${sections[@]}&quot;</span>
  <span class="k">do</span>
    <span class="s2">&quot;help_${section}&quot;</span>
  <span class="k">done</span>

<span class="k">  case</span> <span class="s2">&quot;${extension}&quot;</span> in
    ext|extension|extend<span class="o">)</span>
      help_section <span class="s2">&quot;Installed Extensions&quot;</span>
      <span class="nb">printf</span> <span class="s2">&quot;  &quot;</span>
      extensions_installed
      <span class="nb">echo</span>

<span class="nb">      </span>help_section <span class="s2">&quot;Available Extensions&quot;</span>
      <span class="nb">printf</span> <span class="s2">&quot;  &quot;</span>
      extensions_available
      <span class="nb">echo</span>
      ;;
  <span class="k">esac</span>
<span class="k">  </span><span class="nb">echo</span>
<span class="o">}</span>



</td><td class=code><div class=highlight><pre>
</pre></div></td></tr><tr><td class=docs>

</pre></div></td></tr><tr><td class=docs>
</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs></td><td class='code'></td></tr>
    </tbody>
    </table>
</div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
    <meta http-eqiv='content-type' content='text/html;charset=utf-8'>
    <title>dsl</title>
    <link rel=stylesheet href="http://jashkenas.github.com/docco/resources/docco.css">
</head>
<body>
<div id=container>
    <div id=background></div>
    <table cellspacing=0 cellpadding=0>
    <thead>
      <tr>
        <th class=docs><h1>dsl</h1></th>
        <th class=code></th>
      </tr>
    </thead>
    <tbody>
        <tr><td class='docs'><h2>shell<em>is</em>interactive()</h2>

<p>Test if the current shell is an interactive shell.</p>

<p>Usage Examples:</p>

<pre><code>if shell_is_interactive
then
  ${PAGER} somefile
else
  cat -v somefile
fi
</code></pre>

</td><td class=code><div class=highlight><pre>
<span class="c">#!/usr/bin/env bash</span>

shell_is_interactive<span class="o">()</span>
<span class="o">{</span>
  <span class="k">if</span> <span class="o">[[</span> -t 0 <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    return </span>0
  <span class="k">else</span>
<span class="k">    return </span>1
  <span class="k">fi</span>
<span class="o">}</span>

<span class="k">if </span>shell_is_interactive
<span class="k">then</span>
<span class="k">  </span><span class="nb">true</span> <span class="c"># Interactive functions will be loaded here, only if shell is interactive.</span>
<span class="k">fi</span>


</td><td class=code><div class=highlight><pre>
</pre></div></td></tr><tr><td class=docs>

</pre></div></td></tr><tr><td class=docs>
</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs></td><td class='code'></td></tr>
    </tbody>
    </table>
</div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
    <meta http-eqiv='content-type' content='text/html;charset=utf-8'>
    <title>dsl</title>
    <link rel=stylesheet href="http://jashkenas.github.com/docco/resources/docco.css">
</head>
<body>
<div id=container>
    <div id=background></div>
    <table cellspacing=0 cellpadding=0>
    <thead>
      <tr>
        <th class=docs><h1>dsl</h1></th>
        <th class=code></th>
      </tr>
    </thead>
    <tbody>
        <tr><td class='docs'><h2>log()</h2>

<p>Log arguments to the calling environments STDOUT.</p>

<h3>Input Parameters</h3>

<p>Strings to be logged.</p>

<h3>Stream Outputs</h3>

<p>Prints arguments passed in to the calling environments STDOUT with a newline
character appended.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if no arguments are given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ log "Hello there! "
Hello there!
</code></pre>

</td><td class=code><div class=highlight><pre>
<span class="c">#!/usr/bin/env bash</span>

log<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_token _file _message <span class="nv">_append_flag</span><span class="o">=</span>0

  <span class="k">while</span> <span class="o">((</span> <span class="nv">$# </span>&gt; 0 <span class="o">))</span>
  <span class="k">do</span>
<span class="k">    </span><span class="nv">_token</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span>
    <span class="nb">shift</span>

<span class="nb">    </span><span class="k">case</span> <span class="s2">&quot;${_token}&quot;</span> in
      <span class="o">(</span>append|--append<span class="o">)</span>
        <span class="nv">_append_flag</span><span class="o">=</span>1
        ;;
      <span class="o">(</span>to<span class="o">)</span>
        <span class="nv">_file</span><span class="o">=</span><span class="s2">&quot;${1}&quot;</span>
        <span class="nb">shift</span>
        ;;
      <span class="o">(</span>*<span class="o">)</span>
        <span class="nv">_message</span><span class="o">=</span><span class="s2">&quot;${_token}&quot;</span>
        ;;
    <span class="k">esac</span>
<span class="k">  done</span>

<span class="k">  if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_message:-}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot log a message as no message was given.&quot;</span>
  <span class="k">fi</span>

<span class="k">  if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_file}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    if</span> <span class="o">((</span> <span class="nv">_append_flag</span> <span class="o">==</span> 1 <span class="o">))</span>
    <span class="k">then</span>
<span class="k">      </span><span class="nb">printf</span> <span class="s2">&quot;${_message}\n&quot;</span> &gt;&gt; <span class="s2">&quot;${_file}&quot;</span>
    <span class="k">else</span>
<span class="k">      </span><span class="nb">printf</span> <span class="s2">&quot;${_message}\n&quot;</span> &gt; <span class="s2">&quot;${_file}&quot;</span>
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">      </span><span class="nb">printf</span> <span class="s2">&quot;${_message}\n&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>info()</h2>

<p>Log arguments to the calling environments STDOUT preceeded by 'INFO .</p>

<h3>Input Parameters</h3>

<p>Strings to be logged.</p>

<h3>Stream Outputs</h3>

<p>Prints arguments passed in to the calling environments STDOUT with a newline
character appended and 'INFO ' prepended.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if no arguments are given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ info "Hello there! "
INFO Hello there!
</code></pre>

</td><td class=code><div class=highlight><pre>
info<span class="o">()</span>
<span class="o">{</span>
  log <span class="s2">&quot;INFO: $*&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>warn()</h2>

<p>Log arguments to the calling environments STDOUT preceeded by 'WARNING .</p>

<h3>Input Parameters</h3>

<p>Strings to be logged.</p>

<h3>Stream Outputs</h3>

<p>Prints arguments passed in to the calling environments STDOUT with a newline
character appended and 'WARNING ' prepended.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if no arguments are given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ info "Bad Monkeys are Typing! "
WARNING: Bad Monkeys are Typing!
</code></pre>

</td><td class=code><div class=highlight><pre>
warn<span class="o">()</span>
<span class="o">{</span>
  log <span class="s2">&quot;WARNING: $*&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>note()</h2>

<p>Log arguments to the calling environments STDOUT preceeded by 'NOTE .</p>

<h3>Input Parameters</h3>

<p>Strings to be logged.</p>

<h3>Stream Outputs</h3>

<p>Prints arguments passed in to the calling environments STDOUT with a newline
character appended and 'NOTE ' prepended.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if no arguments are given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ info "You are not Smurfette! "
NOTE You are not Smurfette!
</code></pre>

</td><td class=code><div class=highlight><pre>
note<span class="o">()</span>
<span class="o">{</span>
  log <span class="s2">&quot;NOTE: $*&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>debug()</h2>

<p>Log arguments to the calling environments STDOUT preceeded by 'DEBUG: .</p>

<h3>Input Parameters</h3>

<p>Strings to be logged.</p>

<h3>Stream Outputs</h3>

<p>Prints arguments passed in to the calling environments STDOUT with a newline
character appended and 'DEBUG: ' prepended.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if no arguments are given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ debug "Hello there! "
DEBUG: Hello there!
</code></pre>

</td><td class=code><div class=highlight><pre>
debug<span class="o">()</span>
<span class="o">{</span>
  <span class="k">if</span> <span class="o">((</span> <span class="k">${</span><span class="nv">debug_flag</span><span class="p">:=0</span><span class="k">}</span> <span class="o">==</span> 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    </span>log <span class="s2">&quot;DEBUG: $*&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>error()</h2>

<p>Log arguments to the calling environments STDERR preceeded by 'ERROR '.
Exits with status code 1.</p>

<h3>Input Parameters</h3>

<p>Strings to be logged.</p>

<h3>Stream Outputs</h3>

<p>Prints arguments passed in to the calling environments STDOUT with a newline
character appended and 'ERROR ' prepended.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>1 for failure.</p>

<h3>Failure Scenarios</h3>

<p>Fails if no arguments are given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ error "Hello there! "
ERROR Hello there!
*poof* shell closed...
</code></pre>

</td><td class=code><div class=highlight><pre>
error<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">set</span> +o xtrace
  log <span class="s2">&quot;\nERROR: $*&quot;</span> &gt;&amp;2
  disable_backtrace
  <span class="nb">exit </span>1
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>succeed()</h2>

<p>Log arguments to the calling environments STDOUT. Exits with status code 0.</p>

<h3>Input Parameters</h3>

<p>Strings to be logged.</p>

<h3>Stream Outputs</h3>

<p>Prints arguments passed in to the calling environments STDOUT with a newline
character appended.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if no arguments are given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ succeed "Hello there! "
Hello there!
*poof* shell closed...
</code></pre>

</td><td class=code><div class=highlight><pre>
succeed<span class="o">()</span> <span class="o">{</span>
  <span class="nb">set</span> +o xtrace
  log <span class="s2">&quot;$*&quot;</span>
  <span class="nb">exit </span>0
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>fail()</h2>

<p>Log arguments to the calling environments STDERR preceeded by 'ERROR '.
Exits with status code 1.</p>

<h3>Input Parameters</h3>

<p>Strings to be logged.</p>

<h3>Stream Outputs</h3>

<p>Prints arguments passed in to the calling environments STDOUT with a newline
character appended and 'ERROR ' prepended.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>1 for failure.</p>

<h3>Failure Scenarios</h3>

<p>Fails if no arguments are given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ error "Hello there! "
ERROR Hello there!
*poof* shell closed...
</code></pre>

</td><td class=code><div class=highlight><pre>
fail<span class="o">()</span>
<span class="o">{</span>
  <span class="nv">trace_flag</span><span class="o">=</span>0
  backtrace <span class="s2">&quot;$*&quot;</span>
  <span class="nb">exit </span>1
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>verbose()</h2>

<p>Log arguments to the calling environments STDERR preceeded by 'ERROR '.
Exits with status code 1.</p>

<h3>Input Parameters</h3>

<p>Strings to be logged.</p>

<h3>Stream Outputs</h3>

<p>Prints arguments passed in to the calling environments STDOUT with a newline
character appended and 'ERROR ' prepended.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>1 for verboseure.</p>

<h3>verboseure Scenarios</h3>

<p>verboses if no arguments are given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ verbose "w00t! "
user$ verbose_flag=1
user$ verbose "w00t! "
w00t!
</code></pre>

</td><td class=code><div class=highlight><pre>
verbose<span class="o">()</span>
<span class="o">{</span>
  <span class="k">if</span> <span class="o">((</span> <span class="k">${</span><span class="nv">verbose_flag</span><span class="p">:=0</span><span class="k">}</span> <span class="o">==</span> 1 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    </span>log <span class="s2">&quot;$*&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>logrotate()</h2>

<p>Strategically rotate a logfile minimizing data loss.</p>

<p>This function uses a copy, tail and truncate strategy.</p>

<h3>Usage Examples</h3>

<pre><code>root# logrotate /var/log/my_logfile.log
</code></pre>

</td><td class=code><div class=highlight><pre>
logrotate<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_file</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>
  <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_file}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot rotate a log file as no log file was given.&quot;</span>
  <span class="k">fi</span>

<span class="k">  </span>set_timestamp

  verbose <span class="s2">&quot;Tailing the file in a background process into a tail logfile.&quot;</span>
  <span class="o">(</span> tail -n 0 -f <span class="s2">&quot;${_file}&quot;</span> &gt; <span class="k">${</span><span class="nv">file</span><span class="k">}</span>.<span class="nv">$$</span>.log <span class="o">)</span>&amp;

  <span class="nb">local </span><span class="nv">_tail_pid</span><span class="o">=</span><span class="nv">$!</span>

  verbose <span class="s2">&quot;Copying the file&#39;s contentes into a new timestamped file.&quot;</span>
  cp <span class="s2">&quot;${_file}&quot;</span> <span class="s2">&quot;${_file}.${timestamp}&quot;</span>

  verbose <span class="s2">&quot;Truncating the file.&quot;</span>
  cp /dev/null <span class="k">${</span><span class="nv">_file</span><span class="k">}</span>

  verbose <span class="s2">&quot;Signaling the tail background process to stop.&quot;</span>
  <span class="nb">kill</span> -QUIT <span class="k">${</span><span class="nv">_tail_pid</span><span class="k">}</span>

  verbose <span class="s2">&quot;Appending the tail logfile to the new timestamped logfile.&quot;</span>
  cat <span class="s2">&quot;${file}.$$.log&quot;</span> &gt;&gt; <span class="s2">&quot;${file}.${timestamp}&quot;</span>

  verbose <span class="s2">&quot;Compressing the timestamped file (gzip)&quot;</span>
  gzip -f -9 <span class="s2">&quot;${file}.${timestamp}&quot;</span>

  verbose <span class="s2">&quot;Removing the tail logfile&quot;</span>
  rm <span class="s2">&quot;${file}.$$.log&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>log_streams()</h2>

<p>Log streams to three files:
  - standard out
  - standard in
  - combined (what the user typically sees)</p>

<h3>Usage Examples</h3>

<pre><code>root# log_streams "make install" prefix make
cat make.out.log
root#
...
</code></pre>

<p>Alternatively,</p>

<pre><code>root# log_streams "make install" \
      out /path/to/out.log \
      err /path/to/err.log \
      mix /path/to/mix.log # both out &amp; err as they occurred.
root# cat /path/to/mix.log
...
</code></pre>

</td><td class=code><div class=highlight><pre>
log_streams<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_command</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span> _prefix _err _out _mix

</pre></div></td></tr><tr><td class=docs>

<p>TODO: allow specification of path, name prefix</p>

</td><td class=code><div class=highlight><pre>

  <span class="k">while</span> <span class="o">((</span> <span class="nv">$# </span>&gt; 0 <span class="o">))</span>
  <span class="k">do</span>
<span class="k">    </span><span class="nv">_token</span><span class="o">=</span><span class="s2">&quot;${1}&quot;</span>
    <span class="nb">shift</span>
<span class="nb">    </span><span class="k">case</span> <span class="s2">&quot;${token}&quot;</span> in
      prefix<span class="o">)</span>
        <span class="nv">_prefix</span><span class="o">=</span><span class="s2">&quot;${1}.&quot;</span>
        ;;
      err<span class="o">)</span>
        <span class="nv">_stderr</span><span class="o">=</span><span class="s2">&quot;${1}&quot;</span>
        <span class="nb">shift</span>
        ;;
      out<span class="o">)</span>
        <span class="nv">_stdout</span><span class="o">=</span><span class="s2">&quot;${1}&quot;</span>
        <span class="nb">shift</span>
        ;;
      mix<span class="o">)</span>
        <span class="nv">_stdmix</span><span class="o">=</span><span class="s2">&quot;${1}&quot;</span>
        <span class="nb">shift</span>
        ;;
      *<span class="o">)</span>
        <span class="nv">_command</span><span class="o">=</span><span class="s2">&quot;${1}&quot;</span>
        <span class="nb">shift</span>
        ;;
    <span class="k">esac</span>
<span class="k">  done</span>

  : <span class="se">\</span>
    <span class="s2">&quot;${_stdout=&quot;</span><span class="k">${</span><span class="nv">2</span><span class="k">:-</span><span class="nv">stdout</span><span class="p">.log</span><span class="k">}</span><span class="s2">&quot;}&quot;</span> <span class="se">\</span>
    <span class="s2">&quot;${_stderr=&quot;</span><span class="k">${</span><span class="nv">3</span><span class="k">:-</span><span class="nv">stderr</span><span class="p">.log</span><span class="k">}</span><span class="s2">&quot;}&quot;</span> <span class="se">\</span>
    <span class="s2">&quot;${_stdmix=&quot;</span><span class="k">${</span><span class="nv">4</span><span class="k">:-</span><span class="nv">stdmix</span><span class="p">.log</span><span class="k">}</span><span class="s2">&quot;}&quot;</span>

  <span class="o">{</span>
    <span class="o">{</span>
      <span class="k">${</span><span class="nv">_command</span><span class="k">}</span> 2&gt;&amp;1 1&gt;&amp;3 | tee <span class="s2">&quot;${_stderr}&quot;</span>
    <span class="o">}</span> 3&gt;&amp;1 1&gt;&amp;2 | tee <span class="s2">&quot;${_stdout}&quot;</span>
  <span class="o">}</span> &gt; <span class="s2">&quot;${_stdmix}&quot;</span> 2&gt;&amp;1
<span class="o">}</span>



</td><td class=code><div class=highlight><pre>
</pre></div></td></tr><tr><td class=docs>

</pre></div></td></tr><tr><td class=docs>
</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs></td><td class='code'></td></tr>
    </tbody>
    </table>
</div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
    <meta http-eqiv='content-type' content='text/html;charset=utf-8'>
    <title>dsl</title>
    <link rel=stylesheet href="http://jashkenas.github.com/docco/resources/docco.css">
</head>
<body>
<div id=container>
    <div id=background></div>
    <table cellspacing=0 cellpadding=0>
    <thead>
      <tr>
        <th class=docs><h1>dsl</h1></th>
        <th class=code></th>
      </tr>
    </thead>
    <tbody>
        <tr><td class='docs'><h2>modules()</h2>

<p>Loads named BDSM modules into the calling environment.</p>

<h3>Input Parameters</h3>

<p>Positional Parameter listing and descriptions.</p>

<h3>Stream Outputs</h3>

<p>None, unless loading the module causes output to a stream.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if no module names were given as parameters.</p>

<h3>Usage Examples</h3>

<pre><code>user$ modules array system
user$ modules_loaded
logging trace filesystem array system
</code></pre>

</td><td class=code><div class=highlight><pre>
<span class="c">#!/usr/bin/env bash</span>

modules<span class="o">()</span>
<span class="o">{</span>
  <span class="k">if</span> <span class="o">((</span> trace_flag &lt; 2 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    </span><span class="nb">set</span> +o xtrace
  <span class="k">fi</span>

<span class="k">  </span><span class="nb">local </span>_module _bdsm _extension _path _file <span class="nv">_modules</span><span class="o">=(</span><span class="s2">&quot;$@&quot;</span><span class="o">)</span>

  <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">_modules</span><span class="p">[@]</span><span class="k">}</span> <span class="o">==</span> 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;No modules specified to load.&quot;</span>
  <span class="k">fi</span>

<span class="k">  for </span>_module in <span class="s2">&quot;${_modules[@]}&quot;</span>
  <span class="k">do</span>
<span class="k">    if </span>module_is_loaded <span class="s2">&quot;${_module}&quot;</span>
    <span class="k">then</span>
<span class="k">      continue</span> <span class="c"># The module has already been loaded, continue to the next one.</span>
    <span class="k">else</span>
<span class="k">      </span><span class="nv">_bdsm</span><span class="o">=</span><span class="s2">&quot;${modules_path}/bash/${_module}&quot;</span>
      <span class="nv">_extension</span><span class="o">=</span><span class="s2">&quot;${extension_modules_path}/bash/${_module}&quot;</span>

      <span class="k">for </span>_path in <span class="s2">&quot;${_bdsm}&quot;</span> <span class="s2">&quot;${_extension}&quot;</span>
      <span class="k">do</span>
<span class="k">        for </span>_file in dsl initialize
        <span class="k">do</span>
<span class="k">          if</span> <span class="o">[[</span> -s <span class="s2">&quot;${_path}/${_file}&quot;</span> <span class="o">]]</span>
          <span class="k">then</span>
<span class="k">            </span><span class="nb">source</span> <span class="s2">&quot;${_path}/${_file}&quot;</span>
          <span class="k">fi</span>
<span class="k">        done</span>
<span class="k">      done</span>
<span class="k">      </span>modules+<span class="o">=(</span><span class="s2">&quot;${_module}&quot;</span><span class="o">)</span>
    <span class="k">fi</span>
<span class="k">  done</span>

<span class="k">  if</span> <span class="o">((</span> trace_flag &gt; 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    </span><span class="nb">set</span> -o xtrace
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>module_load()</h2>

<p>Function Description</p>

<h3>Input Parameters</h3>

<p>Positional Parameter listing and descriptions.</p>

<h3>Stream Outputs</h3>

<p>None, unless loading the module causes output to a stream.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if no extension module files names have been given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ ls ${extension_modules_path}/bash/
cli dsl initialize zebra

user$ cat ${extension_modules_path}/bash/zebra
#!/usr/bin/env bash
echo "Zebra!!! "

user$ module_load zebra # This will load zebra into the current context
Zebra!!!
</code></pre>

</td><td class=code><div class=highlight><pre>
module_load<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_file <span class="nv">_files</span><span class="o">=(</span><span class="s2">&quot;$@&quot;</span><span class="o">)</span>

  <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">_files</span><span class="p">[@]</span><span class="k">}</span> <span class="o">==</span> 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot load a module as no module was given.&quot;</span>
  <span class="k">fi</span>

<span class="k">  for </span>_file in <span class="s2">&quot;${_files[@]}&quot;</span>
  <span class="k">do</span>
<span class="k">    </span>source_files <span class="s2">&quot;${extension_modules_path:-&quot;</span><span class="nv">$modules_path</span><span class="s2">&quot;}/bash/${_file}&quot;</span>
  <span class="k">done</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>module<em>is</em>loaded()</h2>

<p>Checks to see whether or not the named module has been loaded or not.</p>

<h3>Input Parameters</h3>

<p>First parameter is a module name.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 if the module has already been loaded
1 if the module has not already been loaded</p>

<h3>Failure Scenarios</h3>

<p>Fails if no module name was given as the first parameter.</p>

<h3>Usage Examples</h3>

<pre><code>user$ module_is_loaded package
user$ echo $?
1
user$ modules package
user$ module_is_loaded package
0
</code></pre>

</td><td class=code><div class=highlight><pre>
module_is_loaded<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_name</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  <span class="o">[[</span> -n <span class="s2">&quot;${_name}&quot;</span> <span class="o">]]</span> <span class="o">||</span>
    fail <span class="s2">&quot;Cannot determine if a module is loaded as no module was given.&quot;</span>

  <span class="k">case</span> <span class="s2">&quot; ${modules[@]} &quot;</span> in
    <span class="o">(</span>*<span class="o">[[</span>:space:<span class="o">]]</span><span class="k">${</span><span class="nv">_name</span><span class="k">}</span><span class="o">[[</span>:space:<span class="o">]]</span>*<span class="o">)</span>
      <span class="k">return </span>0
      ;;
    <span class="o">(</span>*<span class="o">)</span>
      <span class="k">return </span>1
      ;;
  <span class="k">esac</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>modules_loaded()</h2>

<p>Outputs a list of all modules that have been loaded.</p>

<h3>Input Parameters</h3>

<p>Positional Parameter listing and descriptions.</p>

<h3>Stream Outputs</h3>

<p>Prints a space separated list of all loaded modules to the STDOUT stream of
the calling environment.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios.</p>

<h3>Usage Examples</h3>

<pre><code>user$ modules_loaded
logging trace filesystem
</code></pre>

</td><td class=code><div class=highlight><pre>
modules_loaded<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">printf</span> <span class="s2">&quot;${modules[@]}\n&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<p>Print out a list of all installed modules.</p>

</td><td class=code><div class=highlight><pre>
modules_installed<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_module
  <span class="nb">local </span><span class="nv">_module_type</span><span class="o">=</span><span class="s2">&quot;${1:-&quot;</span>bash<span class="s2">&quot;}&quot;</span>
  <span class="nb">local </span><span class="nv">_modules</span><span class="o">=(</span><span class="k">$(</span>find <span class="s2">&quot;${modules_path}/${_module_type}&quot;</span> -mindepth 1 -maxdepth 1 -type d | sed -e <span class="s1">&#39;s#.*/##g&#39;</span> -e <span class="s1">&#39;/\..*/d&#39;</span><span class="k">)</span><span class="o">)</span>

  <span class="k">for </span>_module in <span class="k">${</span><span class="nv">_modules</span><span class="p">[@]</span><span class="k">}</span> ; <span class="k">do</span>
<span class="k">    </span><span class="nb">printf</span> <span class="s2">&quot;%s\n&quot;</span> <span class="s2">&quot;${_module}&quot;</span>
  <span class="k">done</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>module_dsl()</h2>

<p>Print out a list of all dsl for the given module.</p>

<h3>Input Parameters</h3>

<p>First parameter is the module name to print out the dsl for.</p>

<h3>Stream Outputs</h3>

<p>The named module's DSL function listing will is printed to the calling
environments STDOUT.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if no module name was given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ module_dsl defaults
read_default()
</code></pre>

</td><td class=code><div class=highlight><pre>
module_dsl<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_function _dsl <span class="nv">_modules</span><span class="o">=</span><span class="s2">&quot;${@:-}&quot;</span>

  <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">_modules</span><span class="p">[@]</span><span class="k">}</span> <span class="o">==</span> 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot print the DSL for module(s) as no module names were given.&quot;</span>
  <span class="k">fi</span>

<span class="k">  </span><span class="nb">local </span><span class="nv">_path</span><span class="o">=</span><span class="s2">&quot;${modules_path}/bash/${_module}&quot;</span>

  <span class="nv">_dsl</span><span class="o">=(</span><span class="k">$(</span>find <span class="s2">&quot;${_path}&quot;</span> -mindepth 1 -maxdepth 1 -name dsl -type f -print0 | xargs -0 grep <span class="s1">&#39;^[a-z_]*()$&#39;</span> 2&gt;/dev/null <span class="o">||</span> <span class="nb">true</span><span class="k">)</span><span class="o">)</span>

  <span class="k">for </span>_function in <span class="s2">&quot;${_dsl[@]}&quot;</span>
  <span class="k">do</span>
<span class="k">    </span><span class="nv">_function</span><span class="o">=</span><span class="s2">&quot;${_function##*modules\/bash\/}&quot;</span>
    <span class="nb">printf</span> <span class="s2">&quot;%s\n&quot;</span> <span class="s2">&quot;${_function//*:}&quot;</span>
  <span class="k">done</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>modules_list()</h2>

<p>Lists dsl for all modules.</p>

<h3>Input Parameters</h3>

<p>First parameter is the module name to print out the dsl for.</p>

<h3>Stream Outputs</h3>

<p>DSL function listing for each module is printed to the STDOUT of the calling
environment.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ modules_list
array

  array_is_nonempty()
  array_length()
  array_last_element()
  array_first_element()
  array_push()
  array_append()
  array_shift()
  array_unshift()
  array_join()
... longish output ...
</code></pre>

</td><td class=code><div class=highlight><pre>
modules_list<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_module _modules _function _dsl

  <span class="k">for </span>language in bash ruby
  <span class="k">do</span>
<span class="k">    </span><span class="nv">_modules</span><span class="o">=(</span><span class="k">$(</span>modules_installed <span class="k">${</span><span class="nv">language</span><span class="k">})</span><span class="o">)</span>
    <span class="k">for </span>_module in <span class="s2">&quot;${_modules[@]}&quot;</span>
    <span class="k">do</span>
<span class="k">      </span><span class="nb">printf</span> <span class="s2">&quot;\n%s\n\n&quot;</span> <span class="s2">&quot;${_module}&quot;</span>
      <span class="nv">_dsl</span><span class="o">=(</span><span class="k">$(</span>module_dsl <span class="s2">&quot;${_module}&quot;</span><span class="k">)</span><span class="o">)</span>
      <span class="k">for </span>_function in <span class="s2">&quot;${_dsl[@]}&quot;</span>
      <span class="k">do</span>
<span class="k">        </span><span class="nb">printf</span> <span class="s2">&quot;%s\n&quot;</span> <span class="s2">&quot;  ${_function}&quot;</span>
      <span class="k">done</span>
<span class="k">    done</span>
<span class="k">  done</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>modules_docs()</h2>

<p>Output the module DSL documentation for a given module name.</p>

<h3>Input Parameters</h3>

<p>First parameter is the module name to print out the dsl documentation for.</p>

<h3>Stream Outputs</h3>

<p>DSL documentation for every function of the named module.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if no module name is given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ module_docs defaults

# read_default

Reads default values from an extension's config/defaults file.

### Input Parameters

First parameter is the defaults file key to read (key=value).
Second parameter is the variable name to store the retrieved value in.
Remaining parameters are parsed out as token, value and prefix
  into|as &lt;variable name&gt;
  prefix &lt;name&gt;
  &lt;variable&gt; # If no specifier.

### Stream Outputs

None.

### Environmental effects

A variable will be set to the value, if the value is nonempty. If no variable
name is specified the variable will be assigned the same name as the key.

### Return Codes

0 for success.

### Failure Scenarios

Fails if no arguments are passed in, at least need to specify a key.

### Usage Examples

    user$ read_default "version" prefix "package" # extension is nginx for example
    user$ echo $package_version
    1.0.0
</code></pre>

</td><td class=code><div class=highlight><pre>
module_docs<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_function _dsl _module content_flag table_flag

  <span class="k">while</span> <span class="o">((</span> <span class="nv">$# </span>&gt; 0 <span class="o">))</span>
  <span class="k">do</span>
<span class="k">    </span><span class="nv">token</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span>
    <span class="nb">shift</span>
<span class="nb">    </span><span class="k">case</span> <span class="s2">&quot;${token}&quot;</span> in
      --content<span class="o">)</span>
        <span class="nv">content_flag</span><span class="o">=</span>1
        ;;
      --table<span class="o">)</span>
        <span class="nv">table_flag</span><span class="o">=</span>1
        ;;
      *<span class="o">)</span>
        <span class="nv">_module</span><span class="o">=</span><span class="s2">&quot;$token&quot;</span>
    <span class="k">esac</span>
<span class="k">  done</span>

<span class="k">  if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_module}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span><span class="nb">local </span><span class="nv">_path</span><span class="o">=</span><span class="s2">&quot;${core_development_path}/modules/bash/${_module}&quot;</span>
    <span class="k">if</span> <span class="o">((</span> <span class="nv">content_flag</span> <span class="o">==</span> 1 <span class="o">))</span>
    <span class="k">then</span>
<span class="k">      </span>shocco <span class="s2">&quot;${_path}/dsl&quot;</span> | awk <span class="s1">&#39;/&lt;body&gt;/{p=1;next;} /\/body&gt;/{p=0;next;} {if (p == 1) print ; } &#39;</span>
    <span class="k">elif</span> <span class="o">((</span> <span class="nv">table_flag</span> <span class="o">==</span> 1 <span class="o">))</span>
    <span class="k">then</span>
<span class="k">      </span>shocco <span class="s2">&quot;${_path}/dsl&quot;</span> | awk <span class="s1">&#39;/&lt;table/{p=1;} {if (p == 1) print ; } /\/table&gt;/{p=0;} &#39;</span>
    <span class="k">else</span>
<span class="k">      </span>shocco <span class="s2">&quot;${_path}/dsl&quot;</span>
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot glean documentation for a module as no module name was given&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>modules_docgen()</h2>

<p>Lists dsl for all modules.</p>

<h3>Input Parameters</h3>

<p>First parameter is the module name to print out the dsl for.</p>

<h3>Stream Outputs</h3>

<p>DSL function listing for each module is printed to the STDOUT of the calling
environment.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ modules_list
array

  array_is_nonempty()
  array_length()
  array_last_element()
  array_first_element()
  array_push()
  array_append()
  array_shift()
  array_unshift()
  array_join()
... longish output ...
</code></pre>

</td><td class=code><div class=highlight><pre>
modules_docgen<span class="o">()</span>
<span class="o">{</span>
</pre></div></td></tr><tr><td class=docs>

<p>TODO: Replace with,
for file in modules/bash/<em>/dsl ; do (name=${file%%\/dsl}; shocco $file > html/${name//</em>\/}.html)&amp; done ; wait</p>

</td><td class=code><div class=highlight><pre>

  <span class="nb">local </span>_module _modules _function _dsl
  <span class="nb">local </span><span class="nv">_prefix</span><span class="o">=</span><span class="s2">&quot;${core_development_path}/html&quot;</span>
  <span class="nb">local </span><span class="nv">_path</span><span class="o">=</span><span class="s2">&quot;${site_development_path}&quot;</span>

  <span class="k">if </span>directory_exists <span class="s2">&quot;${core_development_path}&quot;</span>
  <span class="k">then</span>
<span class="k">    </span><span class="nv">_modules</span><span class="o">=(</span><span class="k">$(</span>
    find <span class="s2">&quot;${core_development_path}/modules/bash&quot;</span> -mindepth 1 -maxdepth 1 <span class="se">\</span>
      -type d | sed -e <span class="s1">&#39;s#.*/##g&#39;</span> -e <span class="s1">&#39;/\..*/d&#39;</span>
    <span class="k">)</span><span class="o">)</span>
    <span class="k">for </span>_module in <span class="s2">&quot;${_modules[@]}&quot;</span>
    <span class="k">do</span>
      <span class="c">#(</span>
      ensure_paths_exist <span class="s2">&quot;${_prefix}/${_module}&quot;</span>
      <span class="nv">_base</span><span class="o">=</span><span class="s2">&quot;${_prefix}/${_module}/${_module}&quot;</span>
      log <span class="s2">&quot;Generating ${_base}.md&quot;</span>
      module_docs <span class="s2">&quot;${_module}&quot;</span> &gt; <span class="s2">&quot;${_base}.html&quot;</span>
      cat <span class="s2">&quot;${_base}.html&quot;</span> &gt;&gt; <span class="s2">&quot;${site_development_path}/content/modules/bash/${name}/dsl.haml&quot;</span>
      <span class="c">#)&amp;</span>
    <span class="k">done</span>
<span class="k">    </span><span class="nb">wait</span>

<span class="nb">    </span>log <span class="s2">&quot;Modules documentation content has been generated in ${_prefix}.&quot;</span>
  <span class="k">else</span>
<span class="k">    </span>fail <span class="s2">&quot;Set core_development_path in ~/.bdsmrc in order to run docgen.&quot;</span>
  <span class="k">fi</span>

<span class="k">  if </span>directory_exists <span class="s2">&quot;${site_development_path}&quot;</span>
  <span class="k">then</span>
</pre></div></td></tr><tr><td class=docs>

<p>Copy the generated files into the proper site content dir.</p>

</td><td class=code><div class=highlight><pre>
    <span class="nv">files</span><span class="o">=(</span><span class="k">$(</span>find <span class="s2">&quot;${_prefix}&quot;</span> -mindepth 1 -iname <span class="s1">&#39;*.haml&#39;</span><span class="k">)</span><span class="o">)</span>
    <span class="k">for </span>file in <span class="s2">&quot;${files[@]}&quot;</span>
    <span class="k">do</span>
      <span class="o">(</span>
      <span class="nv">name</span><span class="o">=</span><span class="k">${</span><span class="nv">file</span><span class="p">##*\/</span><span class="k">}</span>
      <span class="nv">name</span><span class="o">=</span><span class="k">${</span><span class="nv">name</span><span class="p">%.haml</span><span class="k">}</span>

      ensure_paths_exist <span class="s2">&quot;${site_development_path}/content/modules/bash/${name}&quot;</span>

      log <span class="s2">&quot;Building ${name} dsl from generated docs.&quot;</span>
      cat &gt; <span class="s2">&quot;${site_development_path}/content/modules/bash/${name}/dsl.haml&quot;</span> <span class="s">&lt;&lt;Header</span>
<span class="s">  .breadcrumbs</span>
<span class="s">    %a{ :href =&gt; &quot;/&quot; }</span>
<span class="s">      Documentation</span>
<span class="s">    &amp;nbsp;&gt;&amp;nbsp;</span>
<span class="s">    %a{ :href =&gt; &quot;/modules/&quot; }</span>
<span class="s">      Modules</span>
<span class="s">    &amp;nbsp;&gt;&amp;nbsp;</span>
<span class="s">    %a{ :href =&gt; &quot;/modules/bash/&quot; }</span>
<span class="s">      Bash</span>
<span class="s">    &amp;nbsp;&gt;&amp;nbsp;</span>
<span class="s">    %a{ :href =&gt; &quot;/modules/bash/${name}/&quot; }</span>
<span class="s">      ${name}</span>
<span class="s">    &amp;nbsp;&gt;&amp;nbsp;</span>
<span class="s">    %a{ :href =&gt; &quot;/modules/bash/${name}/dsl/&quot; }</span>
<span class="s">      DSL API :: ${name}</span>
<span class="s">    %hr</span>

<span class="s">  %h1</span>
<span class="s">    Module ${name}</span>

<span class="s">Header</span>
      cat <span class="nv">$file</span> &gt;&gt; <span class="s2">&quot;${site_development_path}/content/modules/bash/${name}/dsl.haml&quot;</span>
      <span class="o">)</span>&amp;
    <span class="k">done</span>

<span class="k">    </span><span class="nb">wait</span>

<span class="nb">    </span>log <span class="s2">&quot;Module documentation has been generated from the source code path ${core_development_path} into the site development path ${site_development_path}&quot;</span>
  <span class="k">else</span>
<span class="k">    </span>fail <span class="s2">&quot;Set site_development_path in ~/.bdsmrc in order to run docgen.&quot;</span>
  <span class="k">fi</span>

<span class="o">}</span>



</td><td class=code><div class=highlight><pre>
</pre></div></td></tr><tr><td class=docs>

</pre></div></td></tr><tr><td class=docs>
</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs></td><td class='code'></td></tr>
    </tbody>
    </table>
</div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
    <meta http-eqiv='content-type' content='text/html;charset=utf-8'>
    <title>dsl</title>
    <link rel=stylesheet href="http://jashkenas.github.com/docco/resources/docco.css">
</head>
<body>
<div id=container>
    <div id=background></div>
    <table cellspacing=0 cellpadding=0>
    <thead>
      <tr>
        <th class=docs><h1>dsl</h1></th>
        <th class=code></th>
      </tr>
    </thead>
    <tbody>
        <tr><td class='docs'><h2>package_error</h2>

<p>Presents the user with a package related error message including the tail
of an optional log file.</p>

<h3>Input Parameters</h3>

<p>String to be logged, an optional log file containing more details and
an optional number of lines of the file to show (defaults to 25)</p>

<h3>Stream Outputs</h3>

<p>Prints arguments passed in to the calling environments STDOUT with a newline
character appended and 'ERROR ' prepended.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>1 for failure.</p>

<h3>Failure Scenarios</h3>

<p>Fails if no arguments are given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ package_error "Hello there! " configure.log 5
ERROR Hello there!


Tail of configure.log:
</code></pre>

</td><td class=code><div class=highlight><pre>
<span class="c">#!/usr/bin/env bash</span>

<span class="c">#			checking for inflate in -lz... no</span>
<span class="c">#			configure: error: zlib library not found</span>
<span class="c">#			If you have zlib already installed, see config.log for details on the</span>
<span class="c">#			failure.  It is possible the compiler isn&#39;t looking in the proper directory.</span>
<span class="c">#			Use --without-zlib to disable zlib support.</span>
</pre></div></td></tr><tr><td class=docs>

<pre><code>*poof* shell closed...
</code></pre>

</td><td class=code><div class=highlight><pre>
package_error<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_message</span><span class="o">=</span><span class="nv">$1</span>
  <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_message}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot print a package error as no message was provided.&quot;</span>
  <span class="k">fi</span>
<span class="k">  </span><span class="nb">local </span><span class="nv">_log</span><span class="o">=</span><span class="nv">$2</span>

  <span class="k">if</span> <span class="o">[[</span> -n <span class="k">${</span><span class="nv">_log</span><span class="k">}</span> <span class="o">]]</span> <span class="o">&amp;&amp;</span> file_exists <span class="k">${</span><span class="nv">_log</span><span class="k">}</span>
  <span class="k">then</span> <span class="c"># Append tail of error log to the error message.</span>
    <span class="nb">local </span><span class="nv">_num_lines</span><span class="o">=</span><span class="k">${</span><span class="nv">3</span><span class="k">:-</span><span class="nv">25</span><span class="k">}</span> <span class="c"># Default the number of lines to 25</span>
    <span class="nv">_message</span><span class="o">=</span><span class="s2">&quot;${_message}\n\nTail of ${_log}:\n$( tail -n ${_num_lines} ${_log} )&quot;</span>
  <span class="k">fi</span>

<span class="k">  </span>error <span class="s2">&quot;${_message}&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>package_definition</h2>

<p>Enables module developers to easily set package variables in name, value pairs.</p>

<h3>Input Parameters</h3>

<p>Parameters must come in pairs, variable name first (without the 'package'
prefix), value second.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>For each name/value pair, a variable package_${name} is created with the given
value.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Fails if extension developer accidentailly separates key/value with an = :)
Fails if a key is given without a matching value.</p>

<h3>Usage Examples</h3>

<p>Example Usage:</p>

<p>user$ package_definition \
        name "bash" \
        version "4.2" \
        url "ftp.gnu.org/gnu/bash/"</p>

<h3>Notes</h3>

<p>For readability it is recommended to split the line into "key value" lines by
ending the line with a singele backslash '\' character with no space afterwards.</p>

</td><td class=code><div class=highlight><pre>
package_definition<span class="o">()</span>
<span class="o">{</span>
  <span class="k">while</span> <span class="o">((</span> <span class="nv">$# </span>&gt; 0 <span class="o">))</span> ; <span class="k">do</span>
<span class="k">    </span><span class="nv">key</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span> ; <span class="nb">shift</span>
<span class="nb">    </span><span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${1:-}&quot;</span> <span class="o">]]</span> ; <span class="k">then</span>
<span class="k">      </span><span class="nv">value</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span> ; <span class="nb">shift</span>
<span class="nb">    </span><span class="k">else</span>
<span class="k">      if </span><span class="nb">echo</span> <span class="s2">&quot;$key&quot;</span> | grep <span class="s1">&#39;=&#39;</span> ; <span class="k">then</span>
<span class="k">        </span>fail <span class="s2">&quot;Invalid key &#39;${key}&#39;\n =&gt; Guess: Most likely the &#39;=&#39; is supposed to be a &#39; &#39;.&quot;</span>
      <span class="k">else</span>
<span class="k">        </span>fail <span class="s2">&quot;Value not specified for key &#39;${key}&#39;\n =&gt; They tend to come in pairs :)&quot;</span>
      <span class="k">fi</span>
<span class="k">    fi</span>

<span class="k">    case</span> <span class="s2">&quot;$key&quot;</span> in
      name<span class="o">)</span>
        <span class="nv">package_name</span><span class="o">=</span><span class="s2">&quot;${value}&quot;</span>
        ;;
      version<span class="o">)</span>
        <span class="nv">package_version</span><span class="o">=</span><span class="s2">&quot;${value}&quot;</span>
        ;;
      file<span class="o">)</span>
        <span class="nv">package_file</span><span class="o">=</span><span class="s2">&quot;${value}&quot;</span>
        ;;
      dir<span class="o">)</span>
        <span class="nv">package_dir</span><span class="o">=</span><span class="s2">&quot;${value}&quot;</span>
        ;;
      url<span class="o">)</span>
        <span class="nv">package_url</span><span class="o">=</span><span class="s2">&quot;${value}&quot;</span>
        ;;
      base_url<span class="o">)</span>
        <span class="nv">package_base_url</span><span class="o">=</span><span class="s2">&quot;${value}&quot;</span>
        ;;
      docs_url<span class="o">)</span>
        <span class="nv">package_docs_url</span><span class="o">=</span><span class="s2">&quot;${value}&quot;</span>
        ;;
      patches_url<span class="o">)</span>
        <span class="nv">package_patches_url</span><span class="o">=</span><span class="s2">&quot;${value}&quot;</span>
        ;;
      md5_url<span class="o">)</span>
        <span class="nv">package_md5_url</span><span class="o">=</span><span class="s2">&quot;${value}&quot;</span>
        ;;
      active_path<span class="o">)</span>
        <span class="nv">active_path</span><span class="o">=</span><span class="s2">&quot;${value}&quot;</span>
        ;;
      bin_path<span class="o">)</span>
        <span class="nv">bin_path</span><span class="o">=</span><span class="s2">&quot;${value}&quot;</span>
        ;;
      packages_path<span class="o">)</span>
        <span class="nv">packages_path</span><span class="o">=</span><span class="s2">&quot;${value}&quot;</span>
        ;;
      source_path<span class="o">)</span>
        <span class="nv">source_path</span><span class="o">=</span><span class="s2">&quot;${value}&quot;</span>
        ;;
      target_path<span class="o">)</span>
        <span class="nv">target_path</span><span class="o">=</span><span class="s2">&quot;${value}&quot;</span>
        ;;
      archive_format<span class="o">)</span>
        <span class="nv">archive_format</span><span class="o">=</span><span class="s2">&quot;${value}&quot;</span>
        ;;
</pre></div></td></tr><tr><td class=docs>

<p>TODO: Simplify into</p>

</td><td class=code><div class=highlight><pre>
      <span class="c">#(+([[[:alnum:]]|])_path|name|version|url|md5_url)</span>
</pre></div></td></tr><tr><td class=docs>

<p>eval "${key}=${value}"
 ;;</p>

</td><td class=code><div class=highlight><pre>
      *<span class="o">)</span>
        fail <span class="s2">&quot;Unknown key &#39;${key}&#39; (value: ${value})&quot;</span>
      ;;
    <span class="k">esac</span>
<span class="k">  done</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>package_install</h2>

<p>Performs all package installation steps:
* download
* extract
* patch
* confiure
* build
* install
* postinstall
* activation
* service setup, if service module is loaded</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Steps performed are logged to STDOUT of the calling environment.</p>

<h3>Environmental effects</h3>

<p>Package installation artifacts are created in the system and source directories.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Fails if any of the constituant components fail.</p>

<h3>Usage Examples</h3>

<p>Example Usage:</p>

<p>user$ package_definition \
        name "bash" \
        version "4.2" \
        url "ftp.gnu.org/gnu/bash/"</p>

<p>user$ package_install</p>

<h3>Notes</h3>

</td><td class=code><div class=highlight><pre>
package_install<span class="o">()</span>
<span class="o">{</span>
  variables_must_be_nonempty package_name package_version archive_format

  <span class="nb">true</span> <span class="s2">&quot;${package_dir:=&quot;</span><span class="k">${</span><span class="nv">package_name</span><span class="k">}</span>-<span class="k">${</span><span class="nv">package_version</span><span class="k">}</span><span class="s2">&quot;}&quot;</span>

  ensure_paths_exist <span class="s2">&quot;${source_path}&quot;</span>

  enter <span class="s2">&quot;${source_path}&quot;</span>

  <span class="k">if </span>command_exists <span class="s2">&quot;${package_name}_download&quot;</span>
  <span class="k">then</span>
    <span class="s2">&quot;${package_name}_download&quot;</span>
  <span class="k">else</span>
<span class="k">    </span>log <span class="s2">&quot;Downloading ${package_name} ${package_version}&quot;</span>
    package_fetch
  <span class="k">fi</span>

<span class="k">  if </span>command_exists <span class="s2">&quot;${package_name}_preextract&quot;</span>
  <span class="k">then</span>
    <span class="s2">&quot;${package_name}_preextract&quot;</span>
  <span class="k">fi</span>

<span class="k">  if </span>command_exists <span class="s2">&quot;${package_name}_extract&quot;</span>
  <span class="k">then</span>
    <span class="s2">&quot;${package_name}_extract&quot;</span>
  <span class="k">else</span>
<span class="k">    </span>log <span class="s2">&quot;Extracting ${package_name} ${package_version}&quot;</span>
    package_extract
  <span class="k">fi</span>

<span class="k">  if </span>command_exists <span class="s2">&quot;${package_name}_postextract&quot;</span>
  <span class="k">then</span>
    <span class="s2">&quot;${package_name}_postextract&quot;</span>
  <span class="k">fi</span>

<span class="k">  </span>enter <span class="s2">&quot;${package_dir}&quot;</span>

  <span class="k">if </span>command_exists <span class="s2">&quot;${package_name}_patch&quot;</span>
  <span class="k">then</span>
    <span class="s2">&quot;${package_name}_patch&quot;</span>
  <span class="k">else</span>
<span class="k">    </span>package_patch
  <span class="k">fi</span>

<span class="k">  if </span>command_exists <span class="s2">&quot;${package_name}_preconfigure&quot;</span>
  <span class="k">then</span>
    <span class="s2">&quot;${package_name}_preconfigure&quot;</span>
  <span class="k">fi</span>

<span class="k">  if </span>command_exists <span class="s2">&quot;${package_name}_configure&quot;</span>
  <span class="k">then</span>
    <span class="s2">&quot;${package_name}_configure&quot;</span>
  <span class="k">else</span>
<span class="k">    </span>log <span class="s2">&quot;Configuring ${package_name} ${package_version}&quot;</span>
    package_configure
  <span class="k">fi</span>

<span class="k">  if </span>command_exists <span class="s2">&quot;${package_name}_postconfigure&quot;</span>
  <span class="k">then</span>
    <span class="s2">&quot;${package_name}_postconfigure&quot;</span>
  <span class="k">fi</span>

<span class="k">  if </span>command_exists <span class="s2">&quot;${package_name}_build&quot;</span>
  <span class="k">then</span>
    <span class="s2">&quot;${package_name}_build&quot;</span>
  <span class="k">else</span>
<span class="k">    </span>log <span class="s2">&quot;Building ${package_name} ${package_version}&quot;</span>
    package_build
  <span class="k">fi</span>

<span class="k">  if </span>command_exists <span class="s2">&quot;${package_name}_preinstall&quot;</span>
  <span class="k">then</span>
    <span class="s2">&quot;${package_name}_preinstall&quot;</span>
  <span class="k">fi</span>

<span class="k">  if </span>command_exists <span class="s2">&quot;${package_name}_install&quot;</span>
  <span class="k">then</span>
    <span class="s2">&quot;${package_name}_install&quot;</span>
  <span class="k">else</span>
<span class="k">    </span>log <span class="s2">&quot;Installing ${package_name} ${package_version}&quot;</span>

    package_make_install

    log <span class="s2">&quot;Installed ${package_name} ${package_version}.&quot;</span>
  <span class="k">fi</span>

<span class="k">  if </span>command_exists <span class="s2">&quot;${package_name}_postinstall&quot;</span>
  <span class="k">then</span>
    <span class="s2">&quot;${package_name}_postinstall&quot;</span>
  <span class="k">fi</span>

<span class="k">  </span>package_activate_if_first <span class="s2">&quot;${package_name}&quot;</span> <span class="s2">&quot;${package_version}&quot;</span>

  <span class="k">if </span>command_exists <span class="s2">&quot;${package_name}_postactivate&quot;</span>
  <span class="k">then</span>
    <span class="s2">&quot;${package_name}_postactivate&quot;</span>
  <span class="k">fi</span>

<span class="k">  </span>package_setup

  <span class="k">if </span>module_is_loaded <span class="s2">&quot;service&quot;</span>
  <span class="k">then</span>
<span class="k">    </span>service_setup
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>package<em>fetch</em>md5</h2>

<p>Fetches the package's md5 sum from the md5_url, if given.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>none.</p>

<h3>Environmental effects</h3>

<p>The 'package_md5' variable is set with the downloaded md5 sum.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Fails if any of the constituant components fail.</p>

<h3>Usage Examples</h3>

<p>Example Usage:</p>

<p>user$ package<em>fetch</em>md5</p>

<h3>Notes</h3>

</td><td class=code><div class=highlight><pre>
package_fetch_md5<span class="o">()</span>
<span class="o">{</span>
  variables_must_be_nonempty package_name package_version archive_format

  <span class="nb">local </span>download_url

  : <span class="se">\</span>
    <span class="s2">&quot;${package_file:=&quot;</span><span class="k">${</span><span class="nv">package_name</span><span class="k">}</span>-<span class="k">${</span><span class="nv">package_version</span><span class="k">}</span>.<span class="k">${</span><span class="nv">archive_format</span><span class="k">}</span><span class="s2">&quot;}&quot;</span> <span class="se">\</span>
    <span class="s2">&quot;${packge_md5_url:=&quot;</span><span class="k">${</span><span class="nv">package_base_url</span><span class="k">}</span>/<span class="k">${</span><span class="nv">package_file</span><span class="k">}</span>.md5<span class="s2">&quot;}&quot;</span> <span class="se">\</span>
    <span class="s2">&quot;${package_md5:=$( hash_file &quot;</span><span class="k">${</span><span class="nv">extension_config_path</span><span class="k">}</span>/md5<span class="s2">&quot; &quot;</span><span class="k">${</span><span class="nv">package_file</span><span class="k">}</span><span class="s2">&quot; )}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${package_md5}&quot;</span> <span class="o">&amp;&amp;</span> -n <span class="s2">&quot;${package_md5_url}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>curl -L <span class="s2">&quot;${packge_md5_url}&quot;</span> -o <span class="s2">&quot;${package_file}.md5&quot;</span> 2&gt;/dev/null <span class="o">||</span>
      error <span class="s2">&quot;Fetching md5 from &#39;${package_md5_url}&#39; failed.&quot;</span>

    <span class="nv">package_md5</span><span class="o">=</span><span class="k">$(</span>cat <span class="s2">&quot;${package_file}.md5&quot;</span><span class="k">)</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>package_fetch</h2>

<p>Fetches the package's archive file.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>curl output goes to STDERR of the calling environment.</p>

<h3>Environmental effects</h3>

<p>The package archive file will be placed on the filesystem.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<p>Example Usage:</p>

<p>user$ package_fetch</p>

<h3>Notes</h3>

</td><td class=code><div class=highlight><pre>
package_fetch<span class="o">()</span>
<span class="o">{</span>
  variables_must_be_nonempty package_name package_version archive_format

  : <span class="se">\</span>
    <span class="s2">&quot;${package_file:=&quot;</span><span class="k">${</span><span class="nv">package_name</span><span class="k">}</span>-<span class="k">${</span><span class="nv">package_version</span><span class="k">}</span>.<span class="k">${</span><span class="nv">archive_format</span><span class="k">}</span><span class="s2">&quot;}&quot;</span> <span class="se">\</span>
    <span class="s2">&quot;${package_url:=&quot;</span><span class="k">${</span><span class="nv">package_base_url</span><span class="k">}</span>/<span class="k">${</span><span class="nv">package_file</span><span class="k">}</span><span class="s2">&quot;}&quot;</span>

  package_fetch_md5

  <span class="k">if </span>variable_is_nonempty package_md5
  <span class="k">then</span>
<span class="k">    </span>file_matches_md5 <span class="s2">&quot;${package_file}&quot;</span> <span class="s2">&quot;${package_md5}&quot;</span> <span class="o">||</span> <span class="o">{</span>
      log <span class="s2">&quot;${package_file} does not match md5 ${package_md5}, removing and downloading.&quot;</span>

      remove_files <span class="s2">&quot;${package_file}&quot;</span>

      curl -L <span class="s2">&quot;${package_url}&quot;</span> -o <span class="s2">&quot;${package_file}&quot;</span> <span class="o">||</span>
        error <span class="s2">&quot;Downloading ${package_name} from &#39;${package_url}&#39; to &#39;${package_file}&#39; failed &quot;</span>
    <span class="o">}</span>
  <span class="k">else</span>
<span class="k">    </span>curl -L <span class="s2">&quot;${package_url}&quot;</span> -o <span class="s2">&quot;${package_file}&quot;</span> <span class="o">||</span>
      error <span class="s2">&quot;Downloading ${package_name} from &#39;${package_url}&#39; to &#39;${package_file}&#39; failed &quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>package_extract</h2>

<p>Extracts the package archive into the package source directory.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>none.</p>

<h3>Environmental effects</h3>

<p>The 'package_md5' variable is set with the downloaded md5 sum.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Errors halting program if any extraction fails or if the archive format is
unknown.</p>

<h3>Usage Examples</h3>

<p>Example Usage:</p>

<p>user$ package_extract</p>

<h3>Notes</h3>

</td><td class=code><div class=highlight><pre>
package_extract<span class="o">()</span>
<span class="o">{</span>
  extract_archive <span class="s2">&quot;${package_file}&quot;</span> <span class="s2">&quot;${source_path}&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>package_configure</h2>

<p>Configures the package source (eg. ./configure ...).</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>none.</p>

<h3>Environmental effects</h3>

<p>Makefile will be generated for a standard package extension.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Errors halting program if configuration fails for any reason.</p>

<h3>Usage Examples</h3>

<p>Example Usage:</p>

<p>user$ package_configure</p>

<h3>Notes</h3>

</td><td class=code><div class=highlight><pre>
package_configure<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_command

  <span class="k">if</span> <span class="o">[[</span> -n <span class="k">${</span><span class="nv">configure_command</span><span class="k">:-}</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span><span class="nv">_command</span><span class="o">=</span><span class="s2">&quot;${configure_command}&quot;</span>
  <span class="k">else</span>
<span class="k">    </span><span class="nb">export </span><span class="nv">PREFIX</span><span class="o">=</span><span class="s2">&quot;${install_base_path}/${package_version}&quot;</span>

    <span class="nv">_command</span><span class="o">=</span><span class="s2">&quot;./configure ${configure_flags[@]:-&quot;</span>--prefix<span class="o">=</span><span class="k">${</span><span class="nv">install_path</span><span class="k">:-</span><span class="nv">$packages_path</span><span class="k">}</span><span class="s2">&quot;}&quot;</span>

    file_is_executable <span class="s2">&quot;configure&quot;</span> <span class="o">||</span> <span class="k">return </span>0
  <span class="k">fi</span>

<span class="k">  if</span> <span class="k">${</span><span class="nv">_command</span><span class="k">}</span> &gt; configure.log 2&gt;&amp;1
  <span class="k">then</span>
<span class="k">    </span>log <span class="s2">&quot;Configuration of ${package_name} ${package_version} successful.&quot;</span>
  <span class="k">else</span>
<span class="k">    </span>package_error <span class="s2">&quot;Configuration of ${package_name} ${package_version} failed&quot;</span> <span class="s2">&quot;configure.log&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>package_build</h2>

<p>builds the package source (eg. make)</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>none.</p>

<h3>Environmental effects</h3>

<p>Makefile will be generated for a standard package extension.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Errors halting program if building fails for any reason.</p>

<h3>Usage Examples</h3>

<p>Example Usage:</p>

<p>user$ package_build</p>

<h3>Notes</h3>

</td><td class=code><div class=highlight><pre>
package_build<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_command

  <span class="k">if</span> <span class="o">[[</span> -n <span class="k">${</span><span class="nv">make_command</span><span class="k">:-}</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span><span class="nv">_command</span><span class="o">=</span><span class="s2">&quot;${make_command}&quot;</span>
  <span class="k">else</span>
<span class="k">    </span><span class="nv">_command</span><span class="o">=</span><span class="s2">&quot;make ${make_flags[@]:-&quot;</span>-j<span class="k">$(</span>os_cpu_count<span class="k">)</span><span class="s2">&quot;}&quot;</span>
  <span class="k">fi</span>

<span class="k">  if </span><span class="nb">eval</span> <span class="s2">&quot;${_command}&quot;</span> &gt; make.log 2&gt;&amp;1
  <span class="k">then</span>
<span class="k">    return </span>0
  <span class="k">else</span>
<span class="k">    </span>package_error <span class="s2">&quot;Compilation of ${package_name} ${package_version} failed! &quot;</span> <span class="s2">&quot;make.log&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>package<em>make</em>install</h2>

<p>make install  the package source (eg. make)</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>none.</p>

<h3>Environmental effects</h3>

<p>Installation files will be installed to the install_path.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Errors halting program if make install fails for any reason.</p>

<h3>Usage Examples</h3>

<p>Example Usage:</p>

<p>user$ package<em>make</em>install</p>

<h3>Notes</h3>

</td><td class=code><div class=highlight><pre>
package_make_install<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_command

  <span class="k">if</span> <span class="o">[[</span> -n <span class="k">${</span><span class="nv">make_install_command</span><span class="k">:-}</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span><span class="nv">_command</span><span class="o">=</span><span class="s2">&quot;${make_install_command}&quot;</span>
  <span class="k">else</span>
<span class="k">    </span><span class="nv">_command</span><span class="o">=</span><span class="s2">&quot;make ${make_install_flags[@]:-install}&quot;</span>
  <span class="k">fi</span>

<span class="k">  if</span> <span class="k">${</span><span class="nv">_command</span><span class="k">}</span> &gt; make.install.log 2&gt;&amp;1
  <span class="k">then</span>
<span class="k">    return </span>0
  <span class="k">else</span>
<span class="k">    </span>package_error <span class="s2">&quot;Installation of ${package_name} ${package_version} failed! &quot;</span> <span class="s2">&quot;make.install.log&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>package_activate</h2>

<p>activates the package</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>none.</p>

<h3>Environmental effects</h3>

<p>Symlink will be created to the active version in the package install path.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Errors halting program if activateing fails for any reason.</p>

<h3>Usage Examples</h3>

<p>Example Usage:</p>

<p>user$ package_activate</p>

<h3>Notes</h3>

</td><td class=code><div class=highlight><pre>
package_activate<span class="o">()</span>
<span class="o">{</span>
</pre></div></td></tr><tr><td class=docs>

<p>TODO: Switch package activation to</p>

</td><td class=code><div class=highlight><pre>
  <span class="nb">local </span><span class="nv">_package</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span> <span class="nv">_version</span><span class="o">=</span><span class="s2">&quot;${2:-}&quot;</span>

  variables_must_be_nonempty _package _version

  <span class="k">if </span>symlink_exists <span class="s2">&quot;${packages_path}/${_package}/active&quot;</span>
  <span class="k">then</span>
<span class="k">    </span>package_deactivate <span class="s2">&quot;${_package}&quot;</span>
  <span class="k">fi</span>

<span class="k">  if </span>directory_exists <span class="s2">&quot;${install_path}&quot;</span>
  <span class="k">then</span>
<span class="k">    </span>log <span class="s2">&quot;Activating ${_package} ${_version}&quot;</span>

    <span class="k">if </span>command_exists rsync
    <span class="k">then</span>
<span class="k">      </span>rsync -a <span class="s2">&quot;${install_path}/&quot;</span> <span class="s2">&quot;${active_path}/&quot;</span>
    <span class="k">else</span>
<span class="k">      </span>cp -Rf <span class="s2">&quot;${install_path}/&quot;</span> <span class="s2">&quot;${active_path}&quot;</span>
    <span class="k">fi</span>

<span class="k">    </span>link --force <span class="s2">&quot;${packages_path}/${_package}/${_version}&quot;</span> <span class="se">\</span>
      to <span class="s2">&quot;${packages_path}/${_package}/active&quot;</span>
  <span class="k">else</span>
<span class="k">    </span>warn <span class="s2">&quot;Skipping activation of ${_package} ${_version} &quot;</span><span class="se">\</span>
      <span class="s2">&quot;as &#39;${install_path}&#39; does not exist.&quot;</span>
  <span class="k">fi</span>

<span class="k">  </span>package_setup <span class="s2">&quot;${_package}&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>package_setup</h2>

<p>Sets up the package</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>none.</p>

<h3>Environmental effects</h3>

<p>ldconfig, profile.d and service (init.d / conf.d) files will be put in place
on the system.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Errors halting program if setup fails for any reason.</p>

<h3>Usage Examples</h3>

<p>Example Usage:</p>

<p>user$ package_setup</p>

<h3>Notes</h3>

</td><td class=code><div class=highlight><pre>
package_setup<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_package</span><span class="o">=</span><span class="s2">&quot;${1:-${package_name}}&quot;</span>

  package_ldconfig <span class="s2">&quot;${_package}&quot;</span>

  package_profile_d <span class="s2">&quot;${_package}&quot;</span>

  <span class="k">if </span>module_is_loaded <span class="s2">&quot;service&quot;</span>
  <span class="k">then</span>
<span class="k">    </span>service_setup <span class="s2">&quot;${_package}&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>package_deactivate</h2>

<p>deactivates the package</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>none.</p>

<h3>Environmental effects</h3>

<p>Active symlinks will be removed from the filesystem.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Errors halting program if deactivating fails for any reason.</p>

<h3>Usage Examples</h3>

<p>Example Usage:</p>

<p>user$ package_deactivate</p>

<h3>Notes</h3>

</td><td class=code><div class=highlight><pre>
package_deactivate<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_package</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span> _file _files

  variables_must_be_nonempty _package

  log <span class="s2">&quot;Deactivating ${_package}&quot;</span>

  <span class="o">(</span>
  enter <span class="s2">&quot;${install_path}&quot;</span>
  <span class="nv">directories</span><span class="o">=(</span><span class="k">$(</span>find . -type d<span class="k">)</span><span class="o">)</span>

  <span class="nv">files</span><span class="o">=(</span><span class="k">$(</span>find . -type f<span class="k">)</span><span class="o">)</span>
  <span class="k">for </span>file in <span class="s2">&quot;${files[@]}&quot;</span>
  <span class="k">do</span>
<span class="k">    </span>rm -f <span class="s2">&quot;${active_path}/${file#.\/}&quot;</span>
  <span class="k">done</span>
  <span class="o">)</span>

  <span class="nv">_files</span><span class="o">=(</span>
  <span class="s2">&quot;/etc/ld.so.profile.d/${_package}.conf&quot;</span>
  <span class="s2">&quot;/etc/profile.d/${_package}.sh&quot;</span>
  <span class="s2">&quot;${packages_path}/${_package}/active&quot;</span>
  <span class="o">)</span>

  <span class="k">for </span>_file in <span class="s2">$&quot;${_files[@]}&quot;</span>
  <span class="k">do</span>
<span class="k">    if </span>file_exists <span class="s2">&quot;${_file}&quot;</span>
    <span class="k">then</span>
<span class="k">      </span>remove_files <span class="s2">&quot;${_file}&quot;</span>
    <span class="k">fi</span>
<span class="k">  done</span>
<span class="k">  </span>log <span class="s2">&quot;${_package} deactivated&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>package<em>activate</em>if_first</h2>

<p>Activates the package version , if another package version has not yet been
activated.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>none.</p>

<h3>Environmental effects</h3>

<p>Active symlinks will be added to the filesystem if it is the first version
installed.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Errors halting program if deactivating fails for any reason.</p>

<h3>Usage Examples</h3>

<p>Example Usage:</p>

<p>user$ package<em>activate</em>if_first</p>

<h3>Notes</h3>

</td><td class=code><div class=highlight><pre>
package_activate_if_first<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_package</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span> <span class="nv">_version</span><span class="o">=</span><span class="s2">&quot;${2:-}&quot;</span>

  variables_must_be_nonempty _package _version

  <span class="k">if </span>directory_exists <span class="s2">&quot;${install_path}&quot;</span>
  <span class="k">then</span>
<span class="k">    </span>symlink_exists <span class="s2">&quot;${packages_path}/${_package}/active&quot;</span> <span class="o">||</span>
      package_activate <span class="s2">&quot;${_package}&quot;</span> <span class="s2">&quot;${_version}&quot;</span>
  <span class="k">else</span>
<span class="k">    </span>log <span class="s2">&quot;&#39;${install_path}&#39; not found, skipping activation.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>package_ldconfig</h2>

<p>Sets up system level ldconfigs for the package libraries.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>none.</p>

<h3>Environmental effects</h3>

<p>Adjusts ldconfig configuration and runs ldconfig (on linux).</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Errors halting program if deactivating fails for any reason.</p>

<h3>Usage Examples</h3>

<p>Example Usage:</p>

<p>user$ package_ldconfig</p>

<h3>Notes</h3>

</td><td class=code><div class=highlight><pre>
package_ldconfig<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_package</span><span class="o">=</span><span class="s2">&quot;${1:-${package_name}}&quot;</span> _path _files

  variables_must_be_nonempty _package

  directory_exists <span class="s2">&quot;${packages_path}/${_package}/active/lib&quot;</span> <span class="o">||</span>
    <span class="k">return </span>0 <span class="c"># no lib/ directory for activated package, no need to update ldconfig</span>

</pre></div></td></tr><tr><td class=docs>

<p>TODO: Figure out if solaris and freebsd have an analog to this?</p>

</td><td class=code><div class=highlight><pre>
  <span class="k">if </span>user_is_root
  <span class="k">then</span>
<span class="k">    if </span>os_is_linux
    <span class="k">then</span>
<span class="k">      </span>ensure_paths_exist <span class="s2">&quot;/etc/ld.so.conf.d&quot;</span>

      <span class="k">if</span> ! file_exists <span class="s2">&quot;/etc/ld.so.conf.d/bdsm.conf&quot;</span>
      <span class="k">then</span>
<span class="k">        </span><span class="nb">printf</span> <span class="s2">&quot;%s\n&quot;</span> <span class="s2">&quot;${active_path}/lib&quot;</span> &gt; <span class="s2">&quot;/etc/ld.so.conf.d/bdsm.conf&quot;</span>
        chmod_files 0644 <span class="s2">&quot;/etc/ld.so.conf.d/bdsm.conf&quot;</span>
      <span class="k">fi</span>

<span class="k">      </span>log <span class="s2">&quot;Updating ldconfig for ${_package}&quot;</span>
      ldconfig
    <span class="k">elif </span>os_is_darwin
    <span class="k">then</span> <span class="c"># Cluster Fuck.</span>
      <span class="nb">true</span>
</pre></div></td></tr><tr><td class=docs>

<p>This should be handled by the profile.d?
<em>files=($(find "${packages</em>path}/${<em>package}/active" -mindepth 1 -maxdepth 1 -type d))
(( ${#</em>files[@]} > 0 )) &amp;&amp; copy<em>files to "${packages</em>path}" "${_files[@]}"</p>

</td><td class=code><div class=highlight><pre>
    <span class="k">fi</span>
<span class="k">  fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>package<em>profile</em>d</h2>

<p>Sets up system level profile_d configuration for the package</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>none.</p>

<h3>Environmental effects</h3>

<p>Updates profile_d configuration for the given package</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Errors halting program if profile_d setup fails for any reason.</p>

<h3>Usage Examples</h3>

<p>Example Usage:</p>

<p>user$ package<em>profile</em>d</p>

<h3>Notes</h3>

</td><td class=code><div class=highlight><pre>
package_profile_d<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_package</span><span class="o">=</span><span class="s2">&quot;${1:-${package_name}}&quot;</span>

  variables_must_be_nonempty _package

  <span class="k">if </span>template_exists <span class="s2">&quot;profile.d.template&quot;</span>
  <span class="k">then</span>
<span class="k">    </span>log <span class="s2">&quot;Updating shell profile for ${_package}&quot;</span>

    ensure_paths_exist <span class="s2">&quot;${profile_d_path}&quot;</span>
    ensure_files_exist <span class="s2">&quot;${profile_path}&quot;</span>

    install_template <span class="s2">&quot;profile.d&quot;</span> to <span class="s2">&quot;${profile_d_path}/${_package}.sh&quot;</span> mode 0755
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>package_uninstall</h2>

<p>Uninstalls the package</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>none.</p>

<h3>Environmental effects</h3>

<p>Uninstalls the package install effects from the system.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Errors halting program if uninstall fails for any reason.</p>

<h3>Usage Examples</h3>

<p>Example Usage:</p>

<p>user$ package_uninstall</p>

<h3>Notes</h3>

</td><td class=code><div class=highlight><pre>
package_uninstall<span class="o">()</span>
<span class="o">{</span>
  variables_must_be_nonempty package_name package_version archive_format

  <span class="k">if </span>package_is_active <span class="s2">&quot;${package_name}&quot;</span> <span class="s2">&quot;${package_version}&quot;</span>
  <span class="k">then</span> <span class="c"># Deactivate the package if active.</span>
     package_deactivate <span class="s2">&quot;${package_name}&quot;</span>
  <span class="k">fi</span>

<span class="k">  </span>remove_paths <span class="s2">&quot;${install_path}&quot;</span>

  <span class="k">if </span>module_is_loaded service
  <span class="k">then</span> <span class="c"># Remove any service reminants.</span>
     service_uninstall
  <span class="k">fi</span>

<span class="k">  </span>log <span class="s2">&quot;${package_name} ${package_version} has been uninstalled.&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>package_patch</h2>

<p>Applies any patches found for the current package.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>none.</p>

<h3>Environmental effects</h3>

<p>Updates the source code directory for the package with any patches found.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Errors halting program if patching fails for any reason.</p>

<h3>Usage Examples</h3>

<p>Example Usage:</p>

<p>user$ package_patch</p>

<h3>Notes</h3>

</td><td class=code><div class=highlight><pre>
package_patch<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_patches _patch

  <span class="k">if</span> ! directory_exists <span class="s2">&quot;${extension_patches_path}&quot;</span>
  <span class="k">then</span>
<span class="k">    return </span>0
  <span class="k">fi</span>

</pre></div></td></tr><tr><td class=docs>

<p>TODO: Three level hierarchy based on patches/{OS}/{version},
      root level as 'global' always installed.</p>

</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs>

<p>TODO: Test each dir for existence and skip if missing</p>

</td><td class=code><div class=highlight><pre>
  <span class="nv">_patches</span><span class="o">=(</span><span class="k">$(</span>find <span class="s2">&quot;${extension_patches_path}&quot;</span> -mindepth 1 -maxdepth 1 -iname <span class="s1">&#39;*.patch&#39;</span> -type f<span class="k">)</span><span class="o">)</span>

  <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">_patches</span><span class="p">[@]</span><span class="k">}</span> <span class="o">==</span> 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    return </span>0
  <span class="k">fi</span>

<span class="k">  </span>log <span class="s2">&quot;Applying patches for ${package_name} ${package_version}&quot;</span>

  package_apply_patches <span class="s2">&quot;${_patches[@]}&quot;</span>

  <span class="k">if</span> ! directory_exists <span class="s2">&quot;${extension_patches_path}/$(os_type)&quot;</span>
  <span class="k">then</span>
<span class="k">    return </span>0
  <span class="k">fi</span>

<span class="k">  </span><span class="nv">_patches</span><span class="o">=(</span><span class="k">$(</span>find <span class="s2">&quot;${extension_patches_path}/$(os_type)&quot;</span> -mindepth 1 -maxdepth 1 -iname <span class="s1">&#39;*.patch&#39;</span> -type f<span class="k">)</span><span class="o">)</span>
  package_apply_patches <span class="s2">&quot;${_patches[@]}&quot;</span>

  <span class="k">if</span> ! directory_exists <span class="s2">&quot;${extension_patches_path}/$(os_type)/${package_version}&quot;</span>
  <span class="k">then</span>
<span class="k">    return </span>0
  <span class="k">fi</span>

<span class="k">  </span><span class="nv">_patches</span><span class="o">=(</span><span class="k">$(</span>find <span class="s2">&quot;${extension_patches_path}/$(os_type)/${package_version}&quot;</span> -mindepth 1 -maxdepth 1 -iname <span class="s1">&#39;*.patch&#39;</span> -type f<span class="k">)</span><span class="o">)</span>

  package_apply_patches <span class="s2">&quot;${_patches[@]}&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>package<em>apply</em>patches</h2>

<p>Applies patches found</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>none.</p>

<h3>Environmental effects</h3>

<p>Applies any patches found for the current package.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Errors halting program if apply_patches fails for any reason.</p>

<h3>Usage Examples</h3>

<p>Example Usage:</p>

<p>user$ package<em>apply</em>patches</p>

<h3>Notes</h3>

</td><td class=code><div class=highlight><pre>
package_apply_patches<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_patch <span class="nv">_patches</span><span class="o">=(</span><span class="s2">&quot;$@&quot;</span><span class="o">)</span>

  <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">_patches</span><span class="p">[@]</span><span class="k">}</span> <span class="o">==</span> 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot apply patches as no patches were given.&quot;</span>
  <span class="k">fi</span>

<span class="k">  for </span>_patch in <span class="s2">&quot;${_patches[@]}&quot;</span>
  <span class="k">do</span>
<span class="k">    </span>log <span class="s2">&quot;TODO: patch application is NIY&quot;</span>
  <span class="k">done</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>package_usage</h2>

<p>Sets up system level usage configuration for the package</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>none.</p>

<h3>Environmental effects</h3>

<p>Updates usage configuration for the given package</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Errors halting program if usage setup fails for any reason.</p>

<h3>Usage Examples</h3>

<p>Example Usage:</p>

<p>user$ package_usage</p>

<h3>Notes</h3>

</td><td class=code><div class=highlight><pre>
package_usage<span class="o">()</span> <span class="o">{</span>
  <span class="nb">printf</span> <span class="s2">&quot;</span>
<span class="s2">  Usage:</span>

<span class="s2">  $0 [options]</span>

<span class="s2">  options:</span>

<span class="s2">  --prefix   - specify prefix path</span>
<span class="s2">  --src)     - specify source directory</span>
<span class="s2">  --data)    - specify data directory</span>
<span class="s2">  --user)    - specify user to install as</span>
<span class="s2">  --version) - specify version to install</span>
<span class="s2">  --licence) - view licence</span>
<span class="s2">  --help)    - view this usage information</span>

<span class="s2">  &quot;</span>
  <span class="k">return </span>0
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>package_cli</h2>

<p>Parses package CLI arguments</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>none.</p>

<h3>Environmental effects</h3>

<p>Updates cli configuration for the given package</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Errors halting program if cli setup fails for any reason.</p>

<h3>Usage Examples</h3>

<p>Example Usage:</p>

<p>user$ package_cli</p>

<h3>Notes</h3>

</td><td class=code><div class=highlight><pre>
package_cli<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_ignored_args</span><span class="o">=()</span>

  <span class="nv">number_of_args</span><span class="o">=</span><span class="k">${#</span><span class="nv">extension_args</span><span class="p">[@]</span><span class="k">}</span>

  <span class="k">for</span> <span class="o">((</span> <span class="nv">index</span><span class="o">=</span>0 ; index &lt; <span class="nv">$number_of_args</span> ; index++ <span class="o">))</span>
  <span class="k">do</span>
<span class="k">    </span><span class="nv">token</span><span class="o">=</span><span class="s2">&quot;${extension_args[$index]}&quot;</span>

    <span class="k">case</span> <span class="s2">&quot;$token&quot;</span> in
      --prefix<span class="o">)</span>
        <span class="nv">packages_path</span><span class="o">=</span><span class="s2">&quot;${extension_args[$((++index))]}&quot;</span>
        ;;
      --src<span class="o">)</span>
        <span class="nv">src_path</span><span class="o">=</span><span class="s2">&quot;${extension_args[$((++index))]}&quot;</span>
        ;;
      --data<span class="o">)</span>
        <span class="nv">data_path</span><span class="o">=</span><span class="s2">&quot;${extension_args[$((++index))]}&quot;</span>
        ;;
      --user<span class="o">)</span>
        <span class="nv">package_user</span><span class="o">=</span><span class="s2">&quot;${extension_args[$((++index))]}&quot;</span>
        ;;
      --version<span class="o">)</span>
        <span class="nv">package_version</span><span class="o">=</span><span class="s2">&quot;${extension_args[$((++index))]}&quot;</span>
        ;;
      --base_url<span class="o">)</span>
        <span class="nv">package_base_url</span><span class="o">=</span><span class="s2">&quot;${extension_args[$((++index))]}&quot;</span>
        ;;
      --file<span class="o">)</span>
        <span class="nv">package_file</span><span class="o">=</span><span class="s2">&quot;${extension_args[$((++index))]}&quot;</span>
        ;;
      --directory<span class="o">)</span>
        <span class="nv">package_directory</span><span class="o">=</span><span class="s2">&quot;${extension_args[$((++index))]}&quot;</span>
        ;;
      --archive_format<span class="o">)</span>
        <span class="nv">archive_format</span><span class="o">=</span><span class="s2">&quot;${extension_args[$((++index))]}&quot;</span>
        ;;
      --activate|activate<span class="o">)</span>
</pre></div></td></tr><tr><td class=docs>

<p>TODO: Throw error if parameter is not specified.</p>

</td><td class=code><div class=highlight><pre>
        <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">extension_args</span><span class="p">[@]</span><span class="k">}</span> &gt; 0 <span class="o">))</span>
        <span class="k">then</span>
<span class="k">          </span>package_activate <span class="s2">&quot;${extension}&quot;</span> <span class="s2">&quot;${extension_args[$((++index))]}&quot;</span>
        <span class="k">else</span>
<span class="k">          </span>error <span class="s2">&quot;Cannot activate ${extension}, no version was given.&quot;</span>
        <span class="k">fi</span>
        ;;
      --deactivate|deactivate<span class="o">)</span>
        package_deactivate <span class="s2">&quot;${extension}&quot;</span>
        ;;
      --md5<span class="o">)</span>
        <span class="nv">package_md5</span><span class="o">=</span><span class="s2">&quot;${extension_args[$((++index))]}&quot;</span>
        ;;
      --licence<span class="o">)</span>
        extension_license
        <span class="nb">exit </span>0
        ;;
      --help<span class="o">)</span>
        package_usage
        <span class="nb">exit </span>0
        ;;
      --trace<span class="o">)</span>
        <span class="nb">set</span> -o xtrace
        ;;
      *<span class="o">)</span>
        _ignored_args+<span class="o">=(</span><span class="s2">&quot;${token}&quot;</span><span class="o">)</span>
        ;;
    <span class="k">esac</span>

<span class="k">    if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">_ignored_args</span><span class="p">[@]</span><span class="k">}</span> &gt; 0 <span class="o">))</span>
    <span class="k">then</span>
<span class="k">      </span><span class="nv">extension_args</span><span class="o">=(</span> <span class="s2">&quot;${_ignored_args[@]}&quot;</span> <span class="o">)</span>
    <span class="k">fi</span>

<span class="k">  done</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>package_active</h2>

<p>Parses package active arguments</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>none.</p>

<h3>Environmental effects</h3>

<p>Updates active configuration for the given package</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Errors halting program if active setup fails for any reason.</p>

<h3>Usage Examples</h3>

<p>Example Usage:</p>

<p>user$ package_active</p>

<h3>Notes</h3>

</td><td class=code><div class=highlight><pre>
package_is_active<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_name</span><span class="o">=</span><span class="s2">&quot;${1:-${package_name}}&quot;</span>
  <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_name}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;Can not query if a package is active as no package name was given or name is empty.&quot;</span>
  <span class="k">fi</span>

<span class="k">  </span><span class="nb">local </span><span class="nv">_path</span><span class="o">=</span><span class="s2">&quot;${packages_path}/${_name}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -L <span class="s2">&quot;${_path}/active&quot;</span> <span class="o">&amp;&amp;</span> -d <span class="k">$(</span>readlink <span class="s2">&quot;${_path}/active&quot;</span><span class="k">)</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    return </span>0
  <span class="k">else</span>
<span class="k">    return </span>1
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>package_must be</h2>

<p>Parses package must be arguments</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>none.</p>

<h3>Environmental effects</h3>

<p>Updates must be configuration for the given package</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Errors halting program if must be setup fails for any reason.</p>

<h3>Usage Examples</h3>

<p>Example Usage:</p>

<p>user$ package_must be</p>

<h3>Notes</h3>

</td><td class=code><div class=highlight><pre>
package_must_be_active<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_name</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_name}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;Can not ensure that package is active as no package name was given or name is empty.&quot;</span>
  <span class="k">fi</span>

<span class="k">  if </span>package_is_active <span class="s2">&quot;${_name}&quot;</span>
  <span class="k">then</span>
<span class="k">    return </span>0
  <span class="k">else</span>
<span class="k">    </span>error <span class="s2">&quot;Install/activate the node package extension before installing ${_name}.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>packages<em>must</em>be_active</h2>

<p>Parses package must<em>be</em>active arguments</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>none.</p>

<h3>Environmental effects</h3>

<p>Updates must<em>be</em>active configuration for the given package</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Errors halting program if must<em>be</em>active setup fails for any reason.</p>

<h3>Usage Examples</h3>

<p>Example Usage:</p>

<p>user$ packages<em>must</em>be_active</p>

<h3>Notes</h3>

</td><td class=code><div class=highlight><pre>
packages_must_be_active<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_package <span class="nv">_packages</span><span class="o">=</span><span class="s2">&quot;$@&quot;</span>

  <span class="k">if</span> <span class="o">((</span> <span class="s2">&quot;${#@}&quot;</span> <span class="o">==</span> 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;Can not ensure that packages are active as no packages were given.&quot;</span>
  <span class="k">fi</span>

<span class="k">  for </span>_package in <span class="s2">&quot;${_packages[@]}&quot;</span>
  <span class="k">do</span>
<span class="k">    </span>package_must_be_active <span class="s2">&quot;${_package}&quot;</span>
  <span class="k">done</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>package_docs</h2>

<p>Opens package documentation website either in the web browser (if able) or via
curl through PAGER (defaulting to less).</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>None if can open web browser or website docs in PAGER otherwise.</p>

<h3>Environmental effects</h3>

<p>Web browser will open with documentation url if able.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Error if package<em>docs</em>url has not been set.</p>

<h3>Usage Examples</h3>

<p>Example Usage:</p>

<p>user$ package_docs</p>

<h3>Notes</h3>

</td><td class=code><div class=highlight><pre>
package_docs<span class="o">()</span>
<span class="o">{</span>
</pre></div></td></tr><tr><td class=docs>

<p>TODO: move this logic into a core dsl function.</p>

</td><td class=code><div class=highlight><pre>
  <span class="k">if </span>os_is_darwin
  <span class="k">then</span>
<span class="k">    </span>open <span class="nv">$package_docs_url</span>

  <span class="k">elif </span>command_exists xdg-open
  <span class="k">then</span>
<span class="k">    </span>xdg-open <span class="nv">$package_docs_url</span>

  <span class="k">elif </span>command_exists lynx
  <span class="k">then</span>
<span class="k">    </span>lynx <span class="nv">$package_docs_url</span>

  <span class="k">elif </span>command_exists links
  <span class="k">then</span>
<span class="k">    </span>links <span class="nv">$package_docs_url</span>

  <span class="k">else</span>
<span class="k">    </span>curl -s -L <span class="nv">$package_docs_url</span> -o /tmp/<span class="k">${</span><span class="nv">package_name</span><span class="k">}</span>-<span class="k">${</span><span class="nv">package_version</span><span class="k">}</span>.docs
    <span class="k">${</span><span class="nv">EDITOR</span><span class="k">:-</span><span class="p">/bin/less</span><span class="k">}</span> /tmp/<span class="k">${</span><span class="nv">package_name</span><span class="k">}</span>-<span class="k">${</span><span class="nv">package_version</span><span class="k">}</span>.docs
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>package_website</h2>

<p>Opens package documentation website either in the web browser (if able) or via
curl through PAGER (defaulting to less).</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>None if can open web browser or website website in PAGER otherwise.</p>

<h3>Environmental effects</h3>

<p>Web browser will open with documentation url if able.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Error if package<em>website</em>url has not been set.</p>

<h3>Usage Examples</h3>

<p>Example Usage:</p>

<p>user$ package_website</p>

<h3>Notes</h3>

</td><td class=code><div class=highlight><pre>
package_website<span class="o">()</span>
<span class="o">{</span>
</pre></div></td></tr><tr><td class=docs>

<p>TODO: move this logic into a core dsl function.</p>

</td><td class=code><div class=highlight><pre>
  <span class="k">if </span>os_is_darwin
  <span class="k">then</span>
<span class="k">    </span>open <span class="nv">$package_website_url</span>

  <span class="k">elif </span>command_exists xdg-open
  <span class="k">then</span>
<span class="k">    </span>xdg-open <span class="nv">$package_website_url</span>

  <span class="k">elif </span>command_exists lynx
  <span class="k">then</span>
<span class="k">    </span>lynx <span class="nv">$package_website_url</span>

  <span class="k">elif </span>command_exists links
  <span class="k">then</span>
<span class="k">    </span>links <span class="nv">$package_website_url</span>

  <span class="k">else</span>
<span class="k">    </span>curl -s -L <span class="nv">$package_website_url</span> -o /tmp/<span class="k">${</span><span class="nv">package_name</span><span class="k">}</span>-<span class="k">${</span><span class="nv">package_version</span><span class="k">}</span>.website
    <span class="k">${</span><span class="nv">EDITOR</span><span class="k">:-</span><span class="p">/bin/less</span><span class="k">}</span> /tmp/<span class="k">${</span><span class="nv">package_name</span><span class="k">}</span>-<span class="k">${</span><span class="nv">package_version</span><span class="k">}</span>.website
  <span class="k">fi</span>
<span class="o">}</span>



</td><td class=code><div class=highlight><pre>
</pre></div></td></tr><tr><td class=docs>

</pre></div></td></tr><tr><td class=docs>
</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs></td><td class='code'></td></tr>
    </tbody>
    </table>
</div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
    <meta http-eqiv='content-type' content='text/html;charset=utf-8'>
    <title>dsl</title>
    <link rel=stylesheet href="http://jashkenas.github.com/docco/resources/docco.css">
</head>
<body>
<div id=container>
    <div id=background></div>
    <table cellspacing=0 cellpadding=0>
    <thead>
      <tr>
        <th class=docs><h1>dsl</h1></th>
        <th class=code></th>
      </tr>
    </thead>
    <tbody>
        <tr><td class='docs'><h2>lockfile_lock()</h2>

<p>If the current process is the first to write to the lockfile then the process
continues processing past the line calling lockfile_lock "{file path/name}"</p>

<p>Otherwise lockfile_lock causes the process to exit with a message and status
code 0.</p>

<p>If the lock is obtained then lockfile_lock ensures that</p>

<p>Usage Examples:</p>

<p>lockfile<em>lock /var/run/my</em>script.pid</p>

</td><td class=code><div class=highlight><pre>
<span class="c">#!/usr/bin/env bash</span>

lockfile_lock<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_lockfile</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_lockfile}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot lock onto a lockfile as no lockfile was specified as the first parameter.&quot;</span>
  <span class="k">fi</span>

</pre></div></td></tr><tr><td class=docs>

<p>The first instance that successfully writes it's pid to the lockfile 'wins'</p>

</td><td class=code><div class=highlight><pre>
  <span class="nb">printf</span> <span class="s2">&quot;$$&quot;</span> &gt;&gt; <span class="s2">&quot;${_lockfile}&quot;</span>

  <span class="nb">read</span> -r _pid &lt; <span class="s2">&quot;${_lockfile}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;${_pid}&quot;</span> <span class="o">==</span> <span class="s2">&quot;$$&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>on_exit <span class="s2">&quot;rm -f ${_lockfile}&quot;</span>
</pre></div></td></tr><tr><td class=docs>

<p>Ensure the lockfile is released on exit while preserving existing EXIT traps.</p>

</td><td class=code><div class=highlight><pre>
    <span class="nb">trap</span> <span class="s2">&quot;rm -f ${_lockfile};$(trap | awk &#39;/EXIT/&#39; | sed -e &quot;</span>s#<span class="s1">&#39; EXIT##&quot; -e &quot;s#.*&#39;</span><span class="c">##&quot;)&quot; EXIT</span>
    <span class="k">return </span>0 <span class="c"># The lock has been obtained! Proceed with nefarious things!</span>
  <span class="k">else</span> <span class="c"># Question: Should this be an error exit code or ?</span>
    succeed <span class="s2">&quot;Another process already owns the lockfile, exiting.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

on_exit<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_commands</span><span class="o">=</span><span class="s2">&quot;$*&quot;</span>
  <span class="nb">local </span><span class="nv">_on_exit_code</span><span class="o">=</span><span class="s2">&quot;$(trap | awk &#39;/EXIT/&#39; | sed -e &quot;</span>s#<span class="s1">&#39; EXIT##&quot; -e &quot;s#.*&#39;</span><span class="c">##&quot;)&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;${_on_exit_code}&quot;</span> !<span class="o">=</span> *on_exit* <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span><span class="nb">trap</span> <span class="s2">&quot;on_exit_commands;${_on_exit_code}&quot;</span> EXIT
  <span class="k">fi</span>

<span class="k">  </span>on_exit_commands+<span class="o">=(</span> <span class="s2">&quot;${_commands}&quot;</span> <span class="o">)</span>
<span class="o">}</span>

on_exit_commands<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_result</span><span class="o">=</span><span class="s2">&quot;$?&quot;</span> <span class="c"># Preserve actual exit code.</span>

  <span class="nb">local </span>_command
  <span class="k">for </span>_command in <span class="s2">&quot;${on_exit_commands[@]}&quot;</span>
  <span class="k">do</span>
<span class="k">    if</span> ! <span class="nb">eval</span> <span class="s2">&quot;${_command}&quot;</span>
    <span class="k">then</span>
<span class="k">      </span>log <span class="s2">&quot;On Exit Command Failed: ${_command}&quot;</span>
    <span class="k">fi</span>
<span class="k">  done</span>

<span class="k">  return</span> <span class="s2">&quot;${_result}&quot;</span>
<span class="o">}</span>


</td><td class=code><div class=highlight><pre>
</pre></div></td></tr><tr><td class=docs>

</pre></div></td></tr><tr><td class=docs>
</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs></td><td class='code'></td></tr>
    </tbody>
    </table>
</div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
    <meta http-eqiv='content-type' content='text/html;charset=utf-8'>
    <title>dsl</title>
    <link rel=stylesheet href="http://jashkenas.github.com/docco/resources/docco.css">
</head>
<body>
<div id=container>
    <div id=background></div>
    <table cellspacing=0 cellpadding=0>
    <thead>
      <tr>
        <th class=docs><h1>dsl</h1></th>
        <th class=code></th>
      </tr>
    </thead>
    <tbody>
        <tr><td class='docs'><h2>project_initialize()</h2>

<p>Initializes paths and environment for the logical concept of a 'project'.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>Environmental variable settings, such as {shared,release}_path, environment,
etc...</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ project_initialize
user$ echo $environment
production
</code></pre>

</td><td class=code><div class=highlight><pre>
<span class="c">#!/usr/bin/env bash</span>

project_initialize<span class="o">()</span>
<span class="o">{</span>
  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${project_path}&quot;</span> <span class="o">]]</span> ; <span class="k">then</span>
    : <span class="se">\</span>
      <span class="s2">&quot;${shared_path:=${project_path}/shared}&quot;</span> <span class="se">\</span>
      <span class="s2">&quot;${release_path:=${project_path}/current}&quot;</span> <span class="se">\</span>
      <span class="s2">&quot;${environment:=&quot;</span>production<span class="s2">&quot;}&quot;</span>

    : <span class="se">\</span>
      <span class="s2">&quot;${vcs:=$(vcs &quot;</span><span class="k">${</span><span class="nv">shared_path</span><span class="k">}</span>/<span class="k">${</span><span class="nv">project</span><span class="k">}</span><span class="s2">&quot;)}&quot;</span>

    <span class="nv">log_path</span><span class="o">=</span><span class="s2">&quot;$shared_path/log&quot;</span> <span class="c"># Override default BDSM log path.</span>
    <span class="nv">extension_log_path</span><span class="o">=</span><span class="s2">&quot;${log_path}&quot;</span>
  <span class="k">fi</span>

<span class="k">  if</span> <span class="o">[[</span> -n <span class="s2">&quot;${project}&quot;</span> <span class="o">]]</span> ; <span class="k">then</span>
<span class="k">    </span><span class="nv">database_name</span><span class="o">=</span><span class="s2">&quot;${database_name:-&quot;</span><span class="k">${</span><span class="nv">project</span><span class="k">}</span>_<span class="k">${</span><span class="nv">environment</span><span class="k">}</span><span class="s2">&quot;}&quot;</span>

    source_files <span class="s2">&quot;.${project}rc&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>vcs()</h2>

<p>Detect and set the vcs, if any, for the current project.</p>

<h3>Input Parameters</h3>

<p>First parameter must be the path to a repository for determining the VCS.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>The environment variable 'vcs' will be set to the VCS detected, or 'git' by
default.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if no repository path is given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ vcs /home/appuser/shared/appuser
user$ echo $vcs
git
</code></pre>

</td><td class=code><div class=highlight><pre>
vcs<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_path</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span>

  <span class="o">[[</span> -n <span class="s2">&quot;${_path}&quot;</span> <span class="o">]]</span> <span class="o">||</span>
    fail <span class="s2">&quot;Repository path must be given in order to detect the VCS used.&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -d <span class="s2">&quot;${_path}/.git&quot;</span> <span class="o">]]</span> ; <span class="k">then</span>
<span class="k">    </span><span class="nv">vcs</span><span class="o">=</span><span class="s2">&quot;git&quot;</span>
  <span class="k">elif</span> <span class="o">[[</span> -d <span class="s2">&quot;${_path}/.svn&quot;</span> <span class="o">]]</span> ; <span class="k">then</span>
<span class="k">    </span><span class="nv">vcs</span><span class="o">=</span><span class="s2">&quot;svn&quot;</span>
  <span class="k">elif</span> <span class="o">[[</span> -d <span class="s2">&quot;${_path}/.hg&quot;</span> <span class="o">]]</span> ; <span class="k">then</span>
<span class="k">    </span><span class="nv">vcs</span><span class="o">=</span><span class="s2">&quot;hg&quot;</span>
</pre></div></td></tr><tr><td class=docs>

<p>TODO:
elif [[ ... ]] ; then
vcs="fossil"</p>

</td><td class=code><div class=highlight><pre>
  <span class="k">else</span>
<span class="k">    </span><span class="nv">vcs</span><span class="o">=</span><span class="s2">&quot;git&quot;</span> <span class="c"># default</span>
  <span class="k">fi</span>
<span class="o">}</span>



</td><td class=code><div class=highlight><pre>
</pre></div></td></tr><tr><td class=docs>

</pre></div></td></tr><tr><td class=docs>
</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs></td><td class='code'></td></tr>
    </tbody>
    </table>
</div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
    <meta http-eqiv='content-type' content='text/html;charset=utf-8'>
    <title>dsl</title>
    <link rel=stylesheet href="http://jashkenas.github.com/docco/resources/docco.css">
</head>
<body>
<div id=container>
    <div id=background></div>
    <table cellspacing=0 cellpadding=0>
    <thead>
      <tr>
        <th class=docs><h1>dsl</h1></th>
        <th class=code></th>
      </tr>
    </thead>
    <tbody>
        <tr><td class='docs'><h2>rvm_install()</h2>

<p>Install the latest release version of RVM.</p>

<h3>Input Parameters</h3>

<p>First parameter is an optional version number of RVM to install.</p>

<h3>Stream Outputs</h3>

<p>Output from rvm-installer will be printed to the enclosing environment's
STDOUT as well as curl output.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure conditions currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ rvm_install
</code></pre>

</td><td class=code><div class=highlight><pre>
<span class="c">#!/usr/bin/env bash</span>

rvm_install<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_version</span><span class="o">=</span><span class="k">${</span><span class="nv">1</span><span class="k">:-</span><span class="nv">latest</span><span class="k">}</span> <span class="nv">_result</span><span class="o">=</span>0
  <span class="nb">local </span><span class="nv">url</span><span class="o">=</span><span class="s2">&quot;https://rvm.beginrescueend.com/install/rvm&quot;</span>
  <span class="o">(</span>
    <span class="nb">set</span> -o errexit
    curl -s <span class="s2">&quot;$url&quot;</span> -o rvm-installer
    ensure_files_are_executable <span class="s2">&quot;rvm-installer&quot;</span>
    ./rvm-installer --version <span class="k">${</span><span class="nv">_version</span><span class="k">}</span>
    remove_files <span class="s2">&quot;rvm-installer&quot;</span>
  <span class="o">)</span> <span class="o">||</span> <span class="nv">_result</span><span class="o">=</span><span class="nv">$?</span>
  <span class="k">return</span> <span class="nv">$_result</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>install_gem()</h2>

<p>installs the named gem(s) with --no-rdoc --no-ri flags</p>

<h3>Input Parameters</h3>

<p>One or more gem names</p>

<h3>Stream Outputs</h3>

<p>The output of the gem install command will be printed to the calling
environments streams.</p>

<h3>Environmental effects</h3>

<p>Ruby gem(s) will be installed on the system, potentially enabling new commands.</p>

<h3>Return Codes</h3>

<p>0 if gem install was successful
1 if gem install was not successful</p>

<h3>Failure Scenarios</h3>

<p>Fails if ...</p>

<h3>Usage Examples</h3>

<pre><code>user$ {{ setup the scenario }}
user$ function_name {{ parameters }}
user$ {{ demonstrate the results}}
</code></pre>

</td><td class=code><div class=highlight><pre>
install_gem<span class="o">()</span>
<span class="o">{</span>
  <span class="k">if </span>gem install --no-rdoc --no-ri -q <span class="s2">&quot;$*&quot;</span>
  <span class="k">then</span>
<span class="k">    return </span>0
  <span class="k">else</span>
<span class="k">    return </span>1
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>install_gems()</h2>

<p>Installs listed gems using the install_gem function.</p>

<h3>Input Parameters</h3>

<p>One or more rubygems names</p>

<h3>Stream Outputs</h3>

<p>Output from underlying gem install will be printed to the calling environments
streams.</p>

<h3>Environmental effects</h3>

<p>One or more new commands may become available.</p>

<h3>Return Codes</h3>

<p>0 if all gem installs were successful
n where n is the number of unsuccessful gem installs otherwise.</p>

<h3>Failure Scenarios</h3>

<p>Fails if no gems were given to install.</p>

<h3>Usage Examples</h3>

<pre><code>user$ install_gems rake rack
</code></pre>

</td><td class=code><div class=highlight><pre>
install_gems<span class="o">()</span> <span class="o">{</span>
  <span class="nb">local </span>_gem <span class="nv">_gems</span><span class="o">=(</span><span class="s2">&quot;$@&quot;</span><span class="o">)</span> <span class="nv">_result</span><span class="o">=</span>0

  <span class="o">((</span> <span class="k">${#</span><span class="nv">_gems</span><span class="p">[@]</span><span class="k">}</span> &gt; 0 <span class="o">))</span> <span class="o">||</span>
    fail <span class="s2">&quot;Cannot install gems as no gem names were given!&quot;</span>

  <span class="k">for </span>_gem in <span class="s2">&quot;${_gems[@]}&quot;</span>
  <span class="k">do</span>
<span class="k">    </span>install_gem <span class="k">${</span><span class="nv">_gem</span><span class="k">}</span> <span class="o">||</span> <span class="o">((</span> _result++ <span class="o">))</span>
  <span class="k">done</span>

<span class="k">  return</span> <span class="nv">$_result</span>
<span class="o">}</span>



</td><td class=code><div class=highlight><pre>
</pre></div></td></tr><tr><td class=docs>

</pre></div></td></tr><tr><td class=docs>
</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs></td><td class='code'></td></tr>
    </tbody>
    </table>
</div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
    <meta http-eqiv='content-type' content='text/html;charset=utf-8'>
    <title>dsl</title>
    <link rel=stylesheet href="http://jashkenas.github.com/docco/resources/docco.css">
</head>
<body>
<div id=container>
    <div id=background></div>
    <table cellspacing=0 cellpadding=0>
    <thead>
      <tr>
        <th class=docs><h1>dsl</h1></th>
        <th class=code></th>
      </tr>
    </thead>
    <tbody>
        <tr><td class='docs'><h1>General Services functions.</h1>

<h2>services_list()</h2>

<p>List installed services. These are extensions that have loaded the service
module.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>A list of available services to install are printed to STDOUT of
the calling environment.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>NIY
No failure conditions currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ services_avilable
Available service listing has not yet been implemented.
This feature has not yet been implemented.
</code></pre>

<h1>General Services functions.</h1>

<h2>services_list()</h2>

<p>List installed services. These are extensions that have loaded the service
module.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>A list of available services to install are printed to STDOUT of
the calling environment.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>NIY
No failure conditions currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ services_avilable
Available service listing has not yet been implemented.
This feature has not yet been implemented.
</code></pre>

</td><td class=code><div class=highlight><pre>
<span class="c">#!/usr/bin/env bash</span>

services_avilable<span class="o">()</span>
<span class="o">{</span>
  log <span class="s2">&quot;Available service listing has not yet been implemented.&quot;</span>
  NIY
  services_installed
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>services_installed()</h2>

<p>List installed services. These are extensions that have loaded the service
module.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>A list of installed extensions that load the service module are printed
to the STDOUT of the calling environment.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>NIY
No failure conditions currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ services_installed
nginx unicorn redis postgresql
</code></pre>

</td><td class=code><div class=highlight><pre>
services_installed<span class="o">()</span>
<span class="o">{</span>
  log <span class="s2">&quot;Installed services has not yet been implemented.&quot;</span>
  NIY
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>services_available()</h2>

<p>List available services. These are extensions that load the service module.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>A list of available extensions that load the service module are printed to
STDOUT of the calling environment.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>NIY
No failure conditions currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ services_available
nginx redis postgresql mongodb ...
</code></pre>

</td><td class=code><div class=highlight><pre>
services_available<span class="o">()</span>
<span class="o">{</span>
  log <span class="s2">&quot;Installed services has not yet been implemented.&quot;</span>
  NIY
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h1>Single Service functions.</h1>

<h2>service_setup()</h2>

<p>Service setup and configuration.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>Creates a system service user with the same name as the service.
Sets up the service init_d file from template, if it exists.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ service=redis
user$ service_setup
...
</code></pre>

</td><td class=code><div class=highlight><pre>
service_setup<span class="o">()</span>
<span class="o">{</span>
  log <span class="s2">&quot;#creating paths for ${service} ${package_version}...&quot;</span>

  ensure_paths_exist <span class="s2">&quot;${service_paths[@]}&quot;</span> <span class="s2">&quot;${install_path}&quot;</span>

  chown_paths_recursively <span class="s2">&quot;${service_user}:${service_user}&quot;</span> <span class="s2">&quot;${service_paths[@]}&quot;</span>
  chown_paths_recursively <span class="s2">&quot;${service_user}:${service_user}&quot;</span><span class="se">\</span>
    <span class="s2">&quot;${service_root_paths[@]}&quot;</span>

  <span class="k">if </span>user_is_root
  <span class="k">then</span>
</pre></div></td></tr><tr><td class=docs>

<p>TODO: create an 'user_exists' function and use it here.</p>

</td><td class=code><div class=highlight><pre>
    user_create_if_missing <span class="s2">&quot;${service_user}&quot;</span><span class="se">\</span>
      with group <span class="s2">&quot;${service_user}&quot;</span> 2&gt;/dev/null

    ensure_paths_exist <span class="s2">&quot;${service_root_paths[@]}&quot;</span>

    chown_paths_recursively <span class="s2">&quot;${service_user}:${service_user}&quot;</span><span class="se">\</span>
      <span class="s2">&quot;${service_root_paths[@]}&quot;</span>
  <span class="k">fi</span>

<span class="k">  </span>service_install_init_d <span class="s2">&quot;${service}&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h1>Single Service functions.</h1>

<h2>service_uninstall()</h2>

<p>Service uninstall and configuration.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>Creates a system service user with the same name as the service.
Sets up the service init_d file from template, if it exists.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ service=redis
user$ service_uninstall
...
</code></pre>

</td><td class=code><div class=highlight><pre>
service_uninstall<span class="o">()</span>
<span class="o">{</span>
  log <span class="s2">&quot;TODO: service_uninstall is NIY&quot;</span>
</pre></div></td></tr><tr><td class=docs>

<ol>
<li>Remove init scripts</li>
<li>Unload OS service hooks</li>
<li>Deactivate database path.
</td><td class=code><div class=highlight><pre>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs></li>
</ol>

<h2>service_start()</h2>

<p>Starts the given service using init scripts.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Whatever stream output comes from the called init script.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if extension was not set.
Fails if the init script is missing or not executable.</p>

<h3>Usage Examples</h3>

<pre><code>user$ extension=redis
user$ service_start
...
</code></pre>

</td><td class=code><div class=highlight><pre>
service_start<span class="o">()</span>
<span class="o">{</span>
  <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${service}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;In order to start a service the &#39;service&#39; variable must be set.&quot;</span>
  <span class="k">fi</span>

<span class="k">  if </span>command_exists <span class="s2">&quot;${service}_start&quot;</span>
  <span class="k">then</span>
    <span class="s2">&quot;${service}_start&quot;</span>
  <span class="k">else</span>
<span class="k">    if </span>file_is_executable <span class="s2">&quot;${init_scripts_path}/${service}&quot;</span>
    <span class="k">then</span>
<span class="k">      </span>service_init_start
    <span class="k">else</span>
<span class="k">      </span>fail <span class="s2">&quot;${init_scripts_path}/${service} is missing or not executable.&quot;</span>
    <span class="k">fi</span>
<span class="k">  fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>service_stop()</h2>

<p>stops the given service using init scripts.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Whatever stream output comes from the called init script.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if service was not set.
Fails if the init script is missing or not executable.</p>

<h3>Usage Examples</h3>

<pre><code>user$ service=redis
user$ service_stop
...
</code></pre>

</td><td class=code><div class=highlight><pre>
service_stop<span class="o">()</span>
<span class="o">{</span>
  <span class="k">if </span>command_exists <span class="s2">&quot;${service}_stop&quot;</span>
  <span class="k">then</span>
    <span class="s2">&quot;${service}_stop&quot;</span>
  <span class="k">else</span>
<span class="k">    if </span>file_is_executable <span class="s2">&quot;${init_scripts_path}/${service}&quot;</span>
    <span class="k">then</span>
<span class="k">      </span>service_init_stop
    <span class="k">else</span>
<span class="k">      </span>fail <span class="s2">&quot;${init_scripts_path}/${service} is missing or not executable.&quot;</span>
    <span class="k">fi</span>
<span class="k">  fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>service_reload()</h2>

<p>reloads the given service using init scripts.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Whatever stream output comes from the called init script.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if service was not set.
Fails if the init script is missing or not executable.</p>

<h3>Usage Examples</h3>

<pre><code>user$ service=redis
user$ service_reload
...
</code></pre>

</td><td class=code><div class=highlight><pre>
service_reload<span class="o">()</span>
<span class="o">{</span>
  <span class="k">if </span>command_exists <span class="s2">&quot;${service}_reload&quot;</span>
  <span class="k">then</span>
    <span class="s2">&quot;${service}_reload&quot;</span>
  <span class="k">else</span>
<span class="k">    if </span>file_is_executable <span class="s2">&quot;${init_scripts_path}/${service}&quot;</span>
    <span class="k">then</span>
<span class="k">      </span>service_init_reload
    <span class="k">else</span>
<span class="k">      </span>fail <span class="s2">&quot;${init_scripts_path}/${service} is missing or not executable.&quot;</span>
    <span class="k">fi</span>
<span class="k">  fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>service_restart()</h2>

<p>restarts the given service using init scripts.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Whatever stream output comes from the called init script.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if service was not set.
Fails if the init script is missing or not executable.</p>

<h3>Usage Examples</h3>

<pre><code>user$ service=redis
user$ service_restart
...
</code></pre>

</td><td class=code><div class=highlight><pre>
service_restart<span class="o">()</span>
<span class="o">{</span>
  <span class="k">if </span>command_exists <span class="s2">&quot;${service}_restart&quot;</span>
  <span class="k">then</span>
    <span class="s2">&quot;${service}_restart&quot;</span>
  <span class="k">else</span>
<span class="k">    if </span>file_is_executable <span class="s2">&quot;${init_scripts_path}/${service}&quot;</span>
    <span class="k">then</span>
<span class="k">      </span>service_init_stop
      service_init_start
    <span class="k">else</span>
<span class="k">      </span>fail <span class="s2">&quot;${init_scripts_path}/${service} is missing or not executable.&quot;</span>
    <span class="k">fi</span>
<span class="k">  fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>service_status()</h2>

<p>statuss the given service using init scripts.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Whatever stream output comes from the called init script.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if service was not set.
Fails if the init script is missing or not executable.</p>

<h3>Usage Examples</h3>

<pre><code>user$ service=redis
user$ service_status
...
</code></pre>

</td><td class=code><div class=highlight><pre>
service_status<span class="o">()</span>
<span class="o">{</span>
  <span class="k">if </span>command_exists <span class="s2">&quot;${service}_status&quot;</span>
  <span class="k">then</span>
    <span class="s2">&quot;${service}_status&quot;</span>
  <span class="k">else</span>
<span class="k">    if </span>file_is_executable <span class="s2">&quot;${init_scripts_path}/${service}&quot;</span>
    <span class="k">then</span>
<span class="k">      </span>service_init_status
    <span class="k">else</span>
<span class="k">      </span>fail <span class="s2">&quot;${init_scripts_path}/${service} is missing or not executable.&quot;</span>
    <span class="k">fi</span>
<span class="k">  fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>service_logtail()</h2>

<p>logtails the given service using init scripts.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Whatever stream output comes from the called init script.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if service was not set.
Fails if the init script is missing or not executable.</p>

<h3>Usage Examples</h3>

<pre><code>user$ service=redis
user$ service_logtail
...
</code></pre>

</td><td class=code><div class=highlight><pre>
service_logtail<span class="o">()</span>
<span class="o">{</span>
  <span class="k">if </span>command_exists <span class="s2">&quot;${service}_logtail&quot;</span>
  <span class="k">then</span>
    <span class="s2">&quot;${service}_logtail&quot;</span>
  <span class="k">else</span>
<span class="k">    if </span>file_is_executable <span class="s2">&quot;${init_scripts_path}/${service}&quot;</span>
    <span class="k">then</span>
<span class="k">      </span>service_init_logtail
    <span class="k">else</span>
<span class="k">      </span>fail <span class="s2">&quot;${init_scripts_path}/${service} is missing or not executable.&quot;</span>
    <span class="k">fi</span>

<span class="k">  fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>service_info()</h2>

<p>infos the given service using init scripts.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Whatever stream output comes from the called init script.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if service was not set.
Fails if the init script is missing or not executable.</p>

<h3>Usage Examples</h3>

<pre><code>user$ service=redis
user$ service_info
...
</code></pre>

</td><td class=code><div class=highlight><pre>
service_info<span class="o">()</span>
<span class="o">{</span>
  <span class="k">if </span>command_exists <span class="s2">&quot;${service}_info&quot;</span>
  <span class="k">then</span>
    <span class="s2">&quot;${service}_info&quot;</span>
  <span class="k">else</span>
<span class="k">    if </span>file_is_executable <span class="s2">&quot;${init_scripts_path}/${service}&quot;</span>
    <span class="k">then</span>
<span class="k">      </span>service_init_info
    <span class="k">else</span>
<span class="k">      </span>fail <span class="s2">&quot;${init_scripts_path}/${service} is missing or not executable.&quot;</span>
    <span class="k">fi</span>

<span class="k">  fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>service_configcheck()</h2>

<p>configchecks the given service using init scripts.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Whatever stream output comes from the called init script.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if service was not set.
Fails if the init script is missing or not executable.</p>

<h3>Usage Examples</h3>

<pre><code>user$ service=redis
user$ service_configcheck
...
</code></pre>

</td><td class=code><div class=highlight><pre>
service_configcheck<span class="o">()</span>
<span class="o">{</span>
  <span class="k">if </span>command_exists <span class="s2">&quot;${service}_configcheck&quot;</span>
  <span class="k">then</span>
    <span class="s2">&quot;${service}_configcheck&quot;</span>
  <span class="k">else</span>
<span class="k">    </span>file_is_executable <span class="s2">&quot;${init_scripts_path}/${service}&quot;</span> <span class="o">||</span>
      fail <span class="s2">&quot;${init_scripts_path}/${service} is missing or not executable.&quot;</span>

    <span class="s2">&quot;${init_scripts_path}/${service}&quot;</span> configcheck
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>service_usage()</h2>

<p>usages the given service using init scripts.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Whatever stream output comes from the called init script.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if service was not set.
Fails if the init script is missing or not executable.</p>

<h3>Usage Examples</h3>

<pre><code>user$ service=redis
user$ service_usage
...
</code></pre>

</td><td class=code><div class=highlight><pre>
service_usage<span class="o">()</span> <span class="o">{</span>
</pre></div></td></tr><tr><td class=docs>

<p>TODO: Update this for service specific items.</p>

</td><td class=code><div class=highlight><pre>
  <span class="nb">printf</span> <span class="s2">&quot;</span>
<span class="s2">Usage:</span>

<span class="s2">  $0 [options]</span>

<span class="s2">Options:</span>

<span class="s2">  --prefix   - specify prefix path</span>
<span class="s2">  --src)     - specify source directory</span>
<span class="s2">  --data)    - specify data directory</span>
<span class="s2">  --user)    - specify user to install as</span>
<span class="s2">  --version) - specify version to install</span>
<span class="s2">  --licence) - view licence</span>
<span class="s2">  --help)    - view this usage information</span>

<span class="s2">  &quot;</span>
  <span class="k">return </span>0
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>service_cli()</h2>

<p>clis the given service using init scripts.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Whatever stream output comes from the called init script.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if service was not set.
Fails if the init script is missing or not executable.</p>

<h3>Usage Examples</h3>

<pre><code>user$ service=redis
user$ service_cli
...
</code></pre>

</td><td class=code><div class=highlight><pre>
service_cli<span class="o">()</span>
<span class="o">{</span>
</pre></div></td></tr><tr><td class=docs>

<p>TODO: Update this for service specific items.</p>

</td><td class=code><div class=highlight><pre>
  <span class="nb">local </span><span class="nv">_ignored_args</span><span class="o">=()</span>

  <span class="nv">number_of_args</span><span class="o">=</span><span class="k">${#</span><span class="nv">extension_args</span><span class="p">[@]</span><span class="k">}</span>

  <span class="k">for</span> <span class="o">((</span> <span class="nv">index</span><span class="o">=</span>0 ; index &lt; <span class="nv">$number_of_args</span> ; index++ <span class="o">))</span>
  <span class="k">do</span>
<span class="k">    </span><span class="nv">token</span><span class="o">=</span><span class="s2">&quot;${extension_args[$index]}&quot;</span>

    <span class="k">case</span> <span class="s2">&quot;$token&quot;</span> in
      --prefix<span class="o">)</span>
        <span class="nv">prefix_path</span><span class="o">=</span><span class="s2">&quot;${extension_args[$((++index))]}&quot;</span>
        ;;
      --src<span class="o">)</span>
        <span class="nv">src_path</span><span class="o">=</span><span class="s2">&quot;${extension_args[$((++index))]}&quot;</span>
        ;;
      --data<span class="o">)</span>
        <span class="nv">data_path</span><span class="o">=</span><span class="s2">&quot;${extension_args[$((++index))]}&quot;</span>
        ;;
      --user<span class="o">)</span>
        <span class="nv">service_user</span><span class="o">=</span><span class="s2">&quot;${extension_args[$((++index))]}&quot;</span>
        ;;
      --version<span class="o">)</span>
        <span class="nv">service_version</span><span class="o">=</span><span class="s2">&quot;${extension_args[$((++index))]}&quot;</span>
        ;;
      --base_url<span class="o">)</span>
        <span class="nv">service_base_url</span><span class="o">=</span><span class="s2">&quot;${extension_args[$((++index))]}&quot;</span>
        ;;
      --file<span class="o">)</span>
        <span class="nv">service_file</span><span class="o">=</span><span class="s2">&quot;${extension_args[$((++index))]}&quot;</span>
        ;;
      --directory<span class="o">)</span>
        <span class="nv">service_directory</span><span class="o">=</span><span class="s2">&quot;${extension_args[$((++index))]}&quot;</span>
        ;;
      --archive_format<span class="o">)</span>
        <span class="nv">archive_format</span><span class="o">=</span><span class="s2">&quot;${extension_args[$((++index))]}&quot;</span>
        ;;
      --activate|activate<span class="o">)</span>
</pre></div></td></tr><tr><td class=docs>

<p>TODO: Throw error if parameter is not specified.</p>

</td><td class=code><div class=highlight><pre>
        <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">extension_args</span><span class="p">[@]</span><span class="k">}</span> &gt; 0 <span class="o">))</span>
        <span class="k">then</span>
<span class="k">          </span>service_activate <span class="s2">&quot;${service}&quot;</span> <span class="s2">&quot;${extension_args[$((++index))]}&quot;</span>
        <span class="k">else</span>
<span class="k">          </span>error <span class="s2">&quot;Cannot activate ${service}, no version was given.&quot;</span>
        <span class="k">fi</span>
        ;;
      --deactivate|deactivate<span class="o">)</span>
        service_deactivate <span class="s2">&quot;${service}&quot;</span>
        ;;
      --md5<span class="o">)</span>
        <span class="nv">service_md5</span><span class="o">=</span><span class="s2">&quot;${extension_args[$((++index))]}&quot;</span>
        ;;
      --help<span class="o">)</span>
        service_usage
        <span class="nb">exit </span>0
        ;;
      --trace<span class="o">)</span>
        <span class="nb">set</span> -o xtrace
        ;;
      *<span class="o">)</span>
        _ignored_args+<span class="o">=(</span><span class="s2">&quot;${token}&quot;</span><span class="o">)</span>
        ;;
    <span class="k">esac</span>

<span class="k">    if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">_ignored_args</span><span class="p">[@]</span><span class="k">}</span> &gt; 0 <span class="o">))</span>
    <span class="k">then</span>
<span class="k">      </span><span class="nv">extension_args</span><span class="o">=(</span> <span class="s2">&quot;${_ignored_args[@]}&quot;</span> <span class="o">)</span>
    <span class="k">fi</span>
<span class="k">  done</span>

<span class="k">  </span>service_init_path
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>service_pid()</h2>

<p>List installed services. These are extensions that have loaded the service
module.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>A list of extensions that load the service module are printed to STDOUT of
the calling environment.</p>

<h3>Environmental effects</h3>

<p>Sets the variable 'service_pid' to contain the pid of the process or 0.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>None currently.</p>

<h3>Usage Examples</h3>

<pre><code>root# service=redis
root# service_pid
root# echo $service_pid
0
</code></pre>

</td><td class=code><div class=highlight><pre>
service_pid<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_path</span><span class="o">=</span><span class="s2">&quot;${run_path:=&quot;</span>/var/run<span class="s2">&quot;}/${service}&quot;</span>
  <span class="nb">local </span><span class="nv">_pid</span><span class="o">=</span>0

  ensure_paths_exist <span class="s2">&quot;${_path}&quot;</span>

  <span class="k">if </span>file_is_nonempty <span class="s2">&quot;${_path}/${service}.pid&quot;</span>
  <span class="k">then</span>
<span class="k">    </span><span class="nb">read</span> -r _pid &lt; <span class="s2">&quot;${_path}/${service}.pid&quot;</span>
    <span class="k">if </span>os_is_linux
    <span class="k">then</span> <span class="c"># Sanity check.</span>
      <span class="k">if</span> ! directory_exists <span class="s2">&quot;/proc/${pid}&quot;</span>
      <span class="k">then</span>
<span class="k">        </span><span class="nv">_pid</span><span class="o">=</span>0
        rm -f <span class="s2">&quot;${_path}/${service}.pid&quot;</span>
      <span class="k">fi</span>
<span class="k">    fi</span>
<span class="k">  fi</span>

<span class="k">  </span><span class="nv">service_pid</span><span class="o">=</span><span class="k">${</span><span class="nv">_pid</span><span class="k">}</span>

  <span class="k">return </span>0
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>service<em>load</em>conf_d()</h2>

<p>Load the /etc/conf.d/{service}.conf configuration file into the calling
environment.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>None, unless the configuration file contains any print statements.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure conditions currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ service=redis
user$ service_load_conf_d
</code></pre>

</td><td class=code><div class=highlight><pre>
service_load_conf_d<span class="o">()</span>
<span class="o">{</span>
  source_files <span class="s2">&quot;${confd_path}/${service}.conf&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h1>Service init functions.</h1>

<h2>service<em>install</em>init_d()</h2>

<p>Installs the BDSM service module init.d script for the current extension.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Logging messages informing the end user of what is occurring.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure conditions currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ service_install_init_d
</code></pre>

</td><td class=code><div class=highlight><pre>
service_install_init_d<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_service</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span> <span class="nv">_version</span><span class="o">=</span><span class="s2">&quot;${2:-${package_version}}&quot;</span>

  variables_must_be_nonempty _service

  <span class="k">if </span>directory_exists <span class="s2">&quot;${init_scripts_path}&quot;</span>
  <span class="k">then</span>
<span class="k">    if </span>user_is_root
    <span class="k">then</span>
<span class="k">      </span>ensure_paths_exist <span class="s2">&quot;/etc/conf.d&quot;</span> <span class="s2">&quot;${init_scripts_path}&quot;</span>

      log <span class="s2">&quot;Installing init scripts for ${_service}&quot;</span>

</pre></div></td></tr><tr><td class=docs>

<p>TODO: Install the service init script...</p>

</td><td class=code><div class=highlight><pre>

      <span class="k">if </span>template_exists <span class="s2">&quot;${_service}&quot;</span>
      <span class="k">then</span>
<span class="k">        </span>install_template <span class="s2">&quot;${_service}&quot;</span> to <span class="s2">&quot;${init_scripts_path}/${_service}&quot;</span> <span class="se">\</span>
          mode 0755
      <span class="k">else</span>
</pre></div></td></tr><tr><td class=docs>

<p>Use core srv init.d template</p>

</td><td class=code><div class=highlight><pre>
        install_template <span class="s2">&quot;init.d&quot;</span> <span class="se">\</span>
          from <span class="s2">&quot;${extensions_path}/srv/templates&quot;</span> <span class="se">\</span>
          to <span class="s2">&quot;${init_scripts_path}/${_service}&quot;</span> mode 0755

        seed_template <span class="s2">&quot;${init_scripts_path}/${_service}&quot;</span> <span class="se">\</span>
          modules_path <span class="s2">&quot;${modules_path}&quot;</span> <span class="se">\</span>
          service <span class="s2">&quot;${service}&quot;</span> <span class="se">\</span>
          service_user <span class="s2">&quot;${service_user}&quot;</span>
      <span class="k">fi</span>

<span class="k">      </span>service_activate <span class="s2">&quot;${service}&quot;</span> <span class="s2">&quot;${package_version}&quot;</span>

</pre></div></td></tr><tr><td class=docs>

<p>TODO: Replace this with install<em>template + seed</em>template</p>

</td><td class=code><div class=highlight><pre>
      log <span class="s2">&quot;%s\n&quot;</span> <span class="s2">&quot;[ -d \&quot;${prefix_path}/${_service}/active/bin\&quot; ] &amp;&amp; &quot;</span> <span class="se">\</span>
        to <span class="s2">&quot;/etc/profile.d/${_service}.sh&quot;</span>

      log <span class="s2">&quot;%s\n&quot;</span> <span class="s2">&quot;PATH=\&quot;\$PATH:${prefix_path}/${_service}/active/bin\&quot; ; export PATH; &quot;</span> <span class="se">\</span>
        append to <span class="s2">&quot;/etc/profile.d/${_service}.sh&quot;</span>

      chmod_files 0755 <span class="s2">&quot;/etc/profile.d/${_service}.sh&quot;</span>
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">    return </span>0 <span class="c"># No bin/ dir, no need for it to be in the path.</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>service<em>init</em>path()</h2>

<p>Sets the PATH explicitely for purposes of the current service extension.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>Alters the PATH variable.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure conditions currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ service_init_path
</code></pre>

</td><td class=code><div class=highlight><pre>
service_init_path<span class="o">()</span>
<span class="o">{</span>
  <span class="nv">PATH</span><span class="o">=</span><span class="s2">&quot;${prefix_path}/bin:/bin:/usr/bin:/usr/local/bin:/sbin:/usr/sbin:/usr/local/sbin:${PATH}&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>service<em>init</em>start()</h2>

<p>This is the generalized service init start function.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Logging telling the end user what is happening.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure conditions currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ service_init_start
</code></pre>

</td><td class=code><div class=highlight><pre>
service_init_start<span class="o">()</span>
<span class="o">{</span>
  log <span class="s2">&quot;Starting ${service}...&quot;</span>

  service_init_path

  <span class="nb">local </span><span class="nv">_result</span><span class="o">=</span>0 <span class="nv">_command</span><span class="o">=(</span> <span class="s2">&quot;${service_binary}&quot;</span> <span class="o">)</span>

  <span class="k">if </span>array_is_nonempty service_start_flags
  <span class="k">then</span>
<span class="k">    </span>_command+<span class="o">=(</span><span class="s2">&quot;${service_start_flags[@]}&quot;</span><span class="o">)</span>
  <span class="k">fi</span>

<span class="k">  if </span>array_is_nonempty service_flags
  <span class="k">then</span>
<span class="k">    </span>_command+<span class="o">=(</span><span class="s2">&quot;${service_flags[@]}&quot;</span><span class="o">)</span>
  <span class="k">fi</span>

<span class="k">  if</span> <span class="o">((</span> <span class="nv">service_run_as_root_flag</span> <span class="o">==</span> 1 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    if</span> <span class="k">${</span><span class="nv">_command</span><span class="p">[*]</span><span class="k">}</span>
    <span class="k">then</span>
<span class="k">      </span><span class="nb">true</span>
<span class="nb">    </span><span class="k">else</span>
<span class="k">      </span>error <span class="s2">&quot;${service} failed to start.&quot;</span>
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">    if</span> ! user_run_as <span class="s2">&quot;${service_user}&quot;</span> <span class="s2">&quot;${_command[*]}&quot;</span>
    <span class="k">then</span>
<span class="k">      </span><span class="nb">true</span>
<span class="nb">    </span><span class="k">else</span>
<span class="k">      </span>error <span class="s2">&quot;${service} failed to start.&quot;</span>
    <span class="k">fi</span>
<span class="k">  fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>service<em>init</em>stop()</h2>

<p>This is the generalized service init stop function.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Logging telling the end user what is happening.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure conditions currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ service_init_stop
</code></pre>

</td><td class=code><div class=highlight><pre>
service_init_stop<span class="o">()</span>
<span class="o">{</span>
  service_init_path

  <span class="k">if</span> <span class="o">((</span> service_pid &gt; 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    </span>log <span class="s2">&quot;Stopping ${service}...&quot;</span>

    <span class="k">if </span><span class="nb">kill</span> -QUIT <span class="s2">&quot;${service_pid}&quot;</span>
    <span class="k">then</span>
<span class="k">      </span>rm -f <span class="s2">&quot;$service_pid_file&quot;</span>
    <span class="k">else</span>
<span class="k">      return</span> <span class="nv">$?</span>
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">    </span>error <span class="s2">&quot;Service pid has not been set or is zero.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>service<em>init</em>status()</h2>

<p>This is the generalized service init status function.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Logging telling the end user what is happening.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure conditions currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ service_init_status
</code></pre>

</td><td class=code><div class=highlight><pre>
service_init_status<span class="o">()</span>
<span class="o">{</span>
  log <span class="s2">&quot;statusing ${service}...&quot;</span>

  service_init_path

  <span class="nb">local </span><span class="nv">_command</span><span class="o">=(</span> <span class="s2">&quot;${service_binary}&quot;</span> <span class="o">)</span>

  <span class="k">if </span>array_is_nonempty service_status_flags
  <span class="k">then</span>
<span class="k">    </span>_command+<span class="o">=(</span><span class="s2">&quot;${service_status_flags[@]}&quot;</span><span class="o">)</span>
  <span class="k">fi</span>

<span class="k">  if </span>array_is_nonempty service_flags
  <span class="k">then</span>
<span class="k">    </span>_command+<span class="o">=(</span><span class="s2">&quot;${service_flags[@]}&quot;</span><span class="o">)</span>
  <span class="k">fi</span>

<span class="k">  if </span>user_run_as <span class="s2">&quot;${service_user}&quot;</span> <span class="s2">&quot;${_command[*]}&quot;</span>
  <span class="k">then</span>
<span class="k">    return </span>0
  <span class="k">else</span>
<span class="k">    </span>touch <span class="s2">&quot;$service_pid_file&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>service<em>init</em>reload()</h2>

<p>This is the generalized service init reload function.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Logging telling the end user what is happening.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure conditions currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ service_init_reload
</code></pre>

</td><td class=code><div class=highlight><pre>
service_init_reload<span class="o">()</span>
<span class="o">{</span>
  log <span class="s2">&quot;reloading ${service}...&quot;</span>

  service_init_path

  <span class="nb">local </span><span class="nv">_command</span><span class="o">=(</span> <span class="s2">&quot;${service_binary}&quot;</span> <span class="o">)</span>

  <span class="k">if </span>array_is_nonempty service_reload_flags
  <span class="k">then</span>
<span class="k">    </span>_command+<span class="o">=(</span><span class="s2">&quot;${service_reload_flags[@]}&quot;</span><span class="o">)</span>
  <span class="k">fi</span>

<span class="k">  if </span>array_is_nonempty service_flags
  <span class="k">then</span>
<span class="k">    </span>_command+<span class="o">=(</span><span class="s2">&quot;${service_flags[@]}&quot;</span><span class="o">)</span>
  <span class="k">fi</span>

<span class="k">  if </span>user_run_as <span class="s2">&quot;${service_user}&quot;</span> <span class="s2">&quot;${_command[*]}&quot;</span>
  <span class="k">then</span>
<span class="k">    </span>touch <span class="s2">&quot;$service_pid_file&quot;</span>
  <span class="k">else</span>
<span class="k">    return</span> <span class="nv">$?</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>service<em>init</em>usage()</h2>

<p>This is the generalized service init usage function.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Logging telling the end user what is happening.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure conditions currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ service_init_usage
</code></pre>

</td><td class=code><div class=highlight><pre>
service_init_usage<span class="o">()</span>
<span class="o">{</span>
  log <span class="s2">&quot;Usage:\n\n  $0 {start|stop|restart|status|info|logtail}&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>service<em>init</em>logtail()</h2>

<p>This is the generalized service init logtail function.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Logging telling the end user what is happening.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure conditions currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ service_init_logtail
</code></pre>

</td><td class=code><div class=highlight><pre>
service_init_logtail<span class="o">()</span>
<span class="o">{</span>
</pre></div></td></tr><tr><td class=docs>

<p>TODO: Adjust this to allow for parameter passing.</p>

</td><td class=code><div class=highlight><pre>

  <span class="nb">exec </span>tail -n 10 <span class="s2">&quot;${service_log_file}&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>service<em>init</em>info()</h2>

<p>This is the generalized service init info function.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Outputs information about the service (version, etc...).</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure conditions currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ service_init_info
</code></pre>

</td><td class=code><div class=highlight><pre>
service_init_info<span class="o">()</span>
<span class="o">{</span>
  NIY <span class="s2">&quot;service_init_info has not yet been implemented for the service module.&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>service<em>conf</em>d()</h2>

<p>Installs the conf.d template for the service, if it exists.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Logging updates to inform the user what is happening.</p>

<h3>Environmental effects</h3>

<p>Once completed a conf.d file should be in place.
For example /etc/conf.d/redis.conf for the redis service.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure conditions currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ service=redis
user$ service_conf_d
</code></pre>

</td><td class=code><div class=highlight><pre>
service_conf_d<span class="o">()</span>
<span class="o">{</span>
</pre></div></td></tr><tr><td class=docs>

<p>TODO: Install a default conf.d template if extension does not define one.</p>

</td><td class=code><div class=highlight><pre>
  <span class="k">if </span>template_exists <span class="s2">&quot;conf.d&quot;</span>
  <span class="k">then</span>
<span class="k">    </span>install_template <span class="s2">&quot;conf.d.template&quot;</span> to <span class="s2">&quot;/etc/conf.d/${service}.conf&quot;</span> <span class="se">\</span>
      mode 0644 owner <span class="s2">&quot;${service_user}:${service_user}&quot;</span>

    <span class="k">if </span>template_exists <span class="s2">&quot;/etc/conf.d/${service}.conf&quot;</span>
    <span class="k">then</span>
<span class="k">      </span>seed_template <span class="s2">&quot;/etc/conf.d/${service}.conf&quot;</span> <span class="se">\</span>
        prefix_path <span class="s2">&quot;${prefix_path}&quot;</span> <span class="se">\</span>
        init_scripts_path <span class="s2">&quot;${init_scripts_path}&quot;</span> <span class="se">\</span>
        modules_path <span class="s2">&quot;${modules_path}&quot;</span> <span class="se">\</span>
        data_path <span class="s2">&quot;${data_path}&quot;</span> <span class="se">\</span>
        confd_path <span class="s2">&quot;${confd_path}&quot;</span> <span class="se">\</span>
        extension <span class="s2">&quot;${service}&quot;</span> <span class="se">\</span>
        service <span class="s2">&quot;${service}&quot;</span>
    <span class="k">fi</span>
<span class="k">  fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>service<em>init</em>start()</h2>

<p>This is the generalized service init start function.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Logging telling the end user what is happening.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure conditions currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ service_init_action start
</code></pre>

</td><td class=code><div class=highlight><pre>
service_init_action<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_action</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  service_load_conf_d

  <span class="k">if </span>command_exists <span class="s2">&quot;${service}_${action}&quot;</span>
  <span class="k">then</span>
    <span class="s2">&quot;${service}_${action}&quot;</span>
  <span class="k">else</span>
<span class="k">    if</span> <span class="o">[[</span> <span class="s2">&quot;${service_actions[*]}&quot;</span> <span class="o">=</span> *<span class="o">[[</span>:space:<span class="o">]]</span><span class="k">${</span><span class="nv">action</span><span class="k">}</span><span class="o">[[</span>:space:<span class="o">]]</span>* <span class="o">]]</span>
    <span class="k">then</span>
<span class="k">      </span>service_init_<span class="k">${</span><span class="nv">action</span><span class="k">}</span>
    <span class="k">else</span>
<span class="k">      </span>service_init_usage
    <span class="k">fi</span>
<span class="k">  fi</span>

<span class="k">  return</span> <span class="nv">$?</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>service<em>init</em>d()</h2>

<p>The main logic for generalized service init.d scripts.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Logging updates to inform the user what is happening.</p>

<h3>Environmental effects</h3>

<p>May alter the runstate of the service extension.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure conditions currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ service=redis
user$ service_init_d
</code></pre>

</td><td class=code><div class=highlight><pre>
service_init_d<span class="o">()</span>
<span class="o">{</span>
  enable_backtrace <span class="c"># Enable backtrace on script error.</span>

  service_load_conf_d <span class="c"># Load the configuration file.</span>

</pre></div></td></tr><tr><td class=docs>

<p>Sanity checks go here.</p>

</td><td class=code><div class=highlight><pre>
  <span class="k">if </span>file_is_executable <span class="s2">&quot;${service_binary}&quot;</span>
  <span class="k">then</span>
<span class="k">    </span>service_pid

    service_cli <span class="c"># Parse the script arguments and take action accordingly.</span>

    service_init_action <span class="s2">&quot;${service_action}&quot;</span>
  <span class="k">else</span>
<span class="k">    </span>fail <span class="s2">&quot;Could not find ${service_binary} or ${service_binary} is not executable.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>service_deactivate()</h2>

<p>Deactivates the named service or</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Logging updates to inform the user what is happening.</p>

<h3>Environmental effects</h3>

<p>Changes the current or named service's init script to be nonexecutable.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure conditions currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ service=redis
user$ service_deactivate
</code></pre>

</td><td class=code><div class=highlight><pre>
service_deactivate<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_service</span><span class="o">=</span><span class="s2">&quot;${1:-&quot;</span><span class="k">${</span><span class="nv">service</span><span class="k">}</span><span class="s2">&quot;}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_service}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;a service name must be set or passed in in order to deactivate a service.&quot;</span>
  <span class="k">fi</span>

<span class="k">  if </span>file_exists <span class="s2">&quot;${init_scripts_path}/${_service}&quot;</span>
  <span class="k">then</span>
<span class="k">    </span>chmod_files 0644 <span class="s2">&quot;${init_scripts_path}/${_service}&quot;</span>

    <span class="k">if </span>user_is_root
    <span class="k">then</span> <span class="c"># Add service to system startup</span>
      <span class="k">if </span>command_exists rc-update
      <span class="k">then</span>
<span class="k">        </span>rc-update add <span class="k">${</span><span class="nv">service</span><span class="k">}</span> default

      <span class="k">elif </span>command_exists chkconfig
      <span class="k">then</span>
<span class="k">        </span>chkconfig <span class="k">${</span><span class="nv">service</span><span class="k">}</span> on

      <span class="c">#elif command_exists svc</span>
      <span class="c">#then</span>
</pre></div></td></tr><tr><td class=docs>

<p>svc ${service} on # TODO: daemontools start on boot</p>

</td><td class=code><div class=highlight><pre>
      <span class="k">else</span> <span class="c"># Fall back on rc.local to start redis at system startup.</span>
        <span class="k">if</span> ! file_contains <span class="s2">&quot;/etc/rc.local&quot;</span> <span class="s2">&quot;${service} start&quot;</span>
        <span class="k">then</span>
<span class="k">          </span>log <span class="s2">&quot;${init_scripts_path}/${service} start&quot;</span> <span class="se">\</span>
            append to /etc/rc.local
        <span class="k">fi</span>
<span class="k">      fi</span>
<span class="k">    fi</span>
<span class="k">  fi</span>
</pre></div></td></tr><tr><td class=docs>

<p>TDOO: hook into system's paths.</p>

</td><td class=code><div class=highlight><pre>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>service_activate()</h2>

<p>Activates the named service or</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Logging updates to inform the user what is happening.</p>

<h3>Environmental effects</h3>

<p>Changes the current or named service's init script to be nonexecutable.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure conditions currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ service=redis
user$ service_deactivate
</code></pre>

</td><td class=code><div class=highlight><pre>
service_activate<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_service</span><span class="o">=</span><span class="s2">&quot;${1:-&quot;</span><span class="k">${</span><span class="nv">service</span><span class="k">}</span><span class="s2">&quot;}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_service}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;the service name must be set or passed in in order to activate a service.&quot;</span>
  <span class="k">fi</span>

<span class="k">  </span><span class="nb">local </span><span class="nv">_version</span><span class="o">=</span><span class="s2">&quot;${2:-${package_version}}&quot;</span>

  variables_must_be_nonempty _service _version

  <span class="k">if </span>symlink_exists <span class="s2">&quot;${service_db_path}/active&quot;</span>
  <span class="k">then</span>
<span class="k">    </span>service_deactivate <span class="s2">&quot;${_service}&quot;</span>
  <span class="k">fi</span>

<span class="k">  if</span> ! directory_exists <span class="s2">&quot;${service_db_path}/${_version}&quot;</span>
  <span class="k">then</span>
<span class="k">    </span>log <span class="s2">&quot;Skipping activation of ${_service} ${_version} as &#39;${install_path}&#39; does not exist.&quot;</span>
  <span class="k">fi</span>

<span class="k">  </span>log <span class="s2">&quot;Activating service ${_service} version ${_version}&quot;</span>

  link --force <span class="s2">&quot;${service_db_path}/${_version}&quot;</span> to <span class="s2">&quot;${service_db_path}/active&quot;</span>

  <span class="k">if </span>file_exists <span class="s2">&quot;${init_scripts_path}/${service}&quot;</span>
  <span class="k">then</span>
<span class="k">    </span>chmod_files 0755 <span class="s2">&quot;${init_scripts_path}/${service}&quot;</span>

    <span class="k">if </span>os_is_linux
    <span class="k">then</span>
<span class="k">      if </span>user_is_root
      <span class="k">then</span> <span class="c"># Add service to system startup</span>
        <span class="k">if </span>command_exists rc-update
        <span class="k">then</span>
<span class="k">          </span>rc-update remove <span class="k">${</span><span class="nv">service</span><span class="k">}</span> default

        <span class="k">elif </span>command_exists chkconfig
        <span class="k">then</span>
<span class="k">          </span>chkconfig <span class="k">${</span><span class="nv">service</span><span class="k">}</span> off

          <span class="c">#elif command_exists svc</span>
          <span class="c">#then</span>
</pre></div></td></tr><tr><td class=docs>

<p>svc ${service} off
 TODO: daemontools remove start on boot</p>

</td><td class=code><div class=highlight><pre>

        <span class="k">else</span> <span class="c"># Fall back on rc.local to start redis at system startup.</span>
          <span class="k">if</span> ! file_contains <span class="s2">&quot;/etc/rc.local&quot;</span> <span class="s2">&quot;${service} start&quot;</span>
          <span class="k">then</span>
<span class="k">            </span>sed -i -e <span class="s2">&quot;d#${init_scripts_path}/${service} start#&quot;</span> /etc/rc.local
          <span class="k">fi</span>
<span class="k">        fi</span>
<span class="k">      fi</span>
<span class="k">    elif </span>os_is_darwin
    <span class="k">then</span>
<span class="k">      </span><span class="nb">true</span> <span class="c"># TODO: launchctl</span>
    <span class="k">else</span> <span class="c"># ::shrug::</span>
      <span class="k">if</span> ! file_contains <span class="s2">&quot;/etc/rc.local&quot;</span> <span class="s2">&quot;${service} start&quot;</span>
      <span class="k">then</span>
<span class="k">        </span>sed -i -e <span class="s2">&quot;d#${init_scripts_path}/${service} start#&quot;</span> /etc/rc.local
      <span class="k">fi</span>
<span class="k">    fi</span>
<span class="k">  fi</span>
<span class="o">}</span>

service_status<span class="o">()</span>
<span class="o">{</span>
  log <span class="s2">&quot;${service}:&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -s <span class="s2">&quot;${service_pid_file}&quot;</span> <span class="o">]]</span> <span class="o">&amp;&amp;</span> <span class="o">((</span> <span class="k">$(</span>head -1 <span class="k">${</span><span class="nv">service_pid_file</span><span class="k">})</span> &gt; 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    </span><span class="nb">local </span><span class="nv">pid</span><span class="o">=</span><span class="k">$(</span>head -1 <span class="k">${</span><span class="nv">service_pid_file</span><span class="k">})</span>
    <span class="nb">local </span><span class="nv">ps</span><span class="o">=</span><span class="k">$(</span>ps -p <span class="k">${</span><span class="nv">pid</span><span class="k">}</span> -ostate,sgi_rss,vsize | tail -1<span class="k">)</span>

    log <span class="s2">&quot;  status: running&quot;</span>
    log <span class="s2">&quot;  version: ${service_version}&quot;</span>
    log <span class="s2">&quot;  process: &quot;</span>
    log <span class="s2">&quot;    pid: ${pid}&quot;</span>
    <span class="k">if </span>os_is_linux
    <span class="k">then</span>
<span class="k">      </span>log <span class="s2">&quot;    parent_pid: $(awk  &#39;/^PPid:/{print $2}&#39; /proc/${pid}/status)&quot;</span>
      log <span class="s2">&quot;    state: $(printf &quot;</span><span class="nv">$ps</span><span class="s2">&quot; | awk &#39;{print $1}&#39;)&quot;</span>
      log <span class="s2">&quot;    rss: $(printf &quot;</span><span class="nv">$ps</span><span class="s2">&quot; | awk &#39;{print $2}&#39;)&quot;</span>
      log <span class="s2">&quot;    vsz: $(printf &quot;</span><span class="nv">$ps</span><span class="s2">&quot; | awk &#39;{print $3}&#39;)&quot;</span>
    <span class="k">fi</span>

<span class="k">    if </span>command_exists lsof
    <span class="k">then</span>
<span class="k">      </span><span class="nb">local </span><span class="nv">cwd</span><span class="o">=</span> <span class="nv">binary</span><span class="o">=</span> <span class="nv">libraries</span><span class="o">=()</span> <span class="nv">tcp_ports</span><span class="o">=()</span> <span class="nv">udp_ports</span><span class="o">=()</span> <span class="nv">sockets</span><span class="o">=()</span> <span class="nv">logs</span><span class="o">=()</span> string
      <span class="k">while </span><span class="nb">read</span> -r line
      <span class="k">do</span>
<span class="k">        case</span> <span class="s2">&quot;$line&quot;</span> in
          <span class="o">(</span>*<span class="o">[[</span>:space:<span class="o">]]</span>cwd<span class="o">[[</span>:space:<span class="o">]]</span>*<span class="o">)</span>
            <span class="nv">cwd</span><span class="o">=</span><span class="s2">&quot;${line##* }&quot;</span>
            ;;
          <span class="o">(</span>*<span class="o">[[</span>:space:<span class="o">]]</span>txt<span class="o">[[</span>:space:<span class="o">]]</span>*<span class="o">)</span>
            <span class="nv">binary</span><span class="o">=</span><span class="s2">&quot;${line##* }&quot;</span>
            ;;
          <span class="o">(</span>*/lib/*<span class="o">)</span>
            <span class="nv">string</span><span class="o">=</span><span class="s2">&quot;${line%% (*}&quot;</span>
            libraries+<span class="o">=(</span><span class="s2">&quot;${string##* }&quot;</span><span class="o">)</span>
            ;;
          <span class="o">(</span>*.log*<span class="o">)</span>
            logs+<span class="o">=(</span><span class="s2">&quot;${line##* }&quot;</span><span class="o">)</span>
            ;;
          <span class="o">(</span>*.sock*<span class="o">)</span>
            sockets+<span class="o">=(</span><span class="s2">&quot;${line##* }&quot;</span><span class="o">)</span>
            ;;
          <span class="o">(</span>*TCP*<span class="o">)</span>
            <span class="nv">string</span><span class="o">=</span><span class="s2">&quot;${line%% (*}&quot;</span>
            tcp_ports+<span class="o">=(</span><span class="s2">&quot;${string##* }&quot;</span><span class="o">)</span>
            ;;
          <span class="o">(</span>*<span class="o">)</span>
            <span class="nb">true</span> <span class="c"># ignore</span>
          ;;
        <span class="k">esac</span>
<span class="k">      done</span> &lt; &lt;<span class="o">(</span>lsof -U -p <span class="k">${</span><span class="nv">pid</span><span class="k">}</span><span class="o">)</span>

      log <span class="s2">&quot;    cwd: ${cwd}&quot;</span>
      log <span class="s2">&quot;    binary: ${binary}&quot;</span>

      <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">logs</span><span class="p">[@]</span><span class="k">}</span> &gt; 0 <span class="o">))</span>
      <span class="k">then</span>
<span class="k">        </span>log <span class="s2">&quot;    logs:&quot;</span>
        array_sort_asc logs
        array_unique logs
        <span class="k">for </span>log in <span class="s2">&quot;${logs[@]}&quot;</span>
        <span class="k">do</span>
<span class="k">          </span><span class="nb">printf</span> <span class="s2">&quot;      - %s\n&quot;</span> <span class="s2">&quot;${log}&quot;</span>
        <span class="k">done</span>
<span class="k">      fi</span>

<span class="k">      if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">libraries</span><span class="p">[@]</span><span class="k">}</span> &gt; 0 <span class="o">))</span>
      <span class="k">then</span>
<span class="k">        </span>log <span class="s2">&quot;    libraries:&quot;</span>
        array_sort_asc libraries
        array_unique libraries
        <span class="k">for </span>library in <span class="s2">&quot;${libraries[@]}&quot;</span>
        <span class="k">do</span>
<span class="k">          </span><span class="nb">printf</span> <span class="s2">&quot;      - %s\n&quot;</span> <span class="s2">&quot;${library}&quot;</span>
        <span class="k">done</span>
<span class="k">      fi</span>

<span class="k">      if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">tcp_ports</span><span class="p">[@]</span><span class="k">}</span> &gt; 0 <span class="o">))</span>
      <span class="k">then</span>
<span class="k">        </span>log <span class="s2">&quot;    tcp_ports:&quot;</span>
        array_sort_asc tcp_ports
        array_unique tcp_ports
        <span class="k">for </span>tcp_port in <span class="s2">&quot;${tcp_ports[@]}&quot;</span>
        <span class="k">do</span>
<span class="k">          </span><span class="nb">printf</span> <span class="s2">&quot;      - %s\n&quot;</span> <span class="s2">&quot;${tcp_port}&quot;</span>
        <span class="k">done</span>
<span class="k">      fi</span>

<span class="k">      if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">sockets</span><span class="p">[@]</span><span class="k">}</span> &gt; 0 <span class="o">))</span>
      <span class="k">then</span>
<span class="k">        </span>log <span class="s2">&quot;    sockets:&quot;</span>
        array_sort_asc sockets
        array_unique sockets
        <span class="k">for </span>socket in <span class="s2">&quot;${sockets[@]}&quot;</span>
        <span class="k">do</span>
<span class="k">          </span><span class="nb">printf</span> <span class="s2">&quot;      - %s\n&quot;</span> <span class="s2">&quot;${socket}&quot;</span>
        <span class="k">done</span>
<span class="k">      fi</span>
<span class="k">    fi</span>
<span class="k">  else</span>
<span class="k">    </span>log <span class="s2">&quot;  status: not running&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>


</td><td class=code><div class=highlight><pre>
</pre></div></td></tr><tr><td class=docs>

</pre></div></td></tr><tr><td class=docs>
</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs></td><td class='code'></td></tr>
    </tbody>
    </table>
</div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
    <meta http-eqiv='content-type' content='text/html;charset=utf-8'>
    <title>dsl</title>
    <link rel=stylesheet href="http://jashkenas.github.com/docco/resources/docco.css">
</head>
<body>
<div id=container>
    <div id=background></div>
    <table cellspacing=0 cellpadding=0>
    <thead>
      <tr>
        <th class=docs><h1>dsl</h1></th>
        <th class=code></th>
      </tr>
    </thead>
    <tbody>
        <tr><td class='docs'><h2>init<em>scripts</em>path()</h2>

<p>Returns the system init scripts path (eg. /etc/init.d /etc/rc.d)</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>The system init scripts path is printed to the calling environments STDOUT.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Fails the OS is not of a (yet) recognized type.</p>

<h3>Usage Examples</h3>

<pre><code>user@archlinux$ init_scripts_path
/etc/rc.d
</code></pre>

</td><td class=code><div class=highlight><pre>
<span class="c">#!/usr/bin/env bash</span>

init_scripts_path<span class="o">()</span>
<span class="o">{</span>
  <span class="k">if</span> <span class="o">((</span> <span class="nv">UID</span> <span class="o">==</span> 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    case</span> <span class="s2">&quot;$MACHTYPE&quot;</span> in
      *darwin*<span class="o">)</span>
        <span class="nb">printf</span> <span class="s2">&quot;/etc/init.d&quot;</span> <span class="c"># Service module will create and use this.</span>
        ;;

      *linux-gnu*|*<span class="o">)</span>
        <span class="k">if</span> <span class="o">[[</span> -d <span class="s2">&quot;/etc/init.d&quot;</span> <span class="o">]]</span>
        <span class="k">then</span>
<span class="k">          </span><span class="nb">printf</span> <span class="s2">&quot;/etc/init.d&quot;</span>

        <span class="k">elif</span> <span class="o">[[</span> -d <span class="s2">&quot;/etc/rc.d&quot;</span> <span class="o">]]</span>
        <span class="k">then</span>
<span class="k">          </span><span class="nb">printf</span> <span class="s2">&quot;/etc/rc.d&quot;</span>

        <span class="k">else</span>
<span class="k">          </span>fail <span class="s2">&quot;Unknown init scripts directory (/etc/init.d or /etc/rc.d not found).&quot;</span>
        <span class="k">fi</span>
        ;;
    <span class="k">esac</span>
<span class="k">  else</span>
<span class="k">    </span><span class="nb">printf</span> <span class="s2">&quot;$HOME/.init.d&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>confd_path()</h2>

<p>Return the system conf.d path.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Prints the conf.d path for the current system and user.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>root# confd_path
/etc/conf.d
</code></pre>

</td><td class=code><div class=highlight><pre>
confd_path<span class="o">()</span>
<span class="o">{</span>
  <span class="k">if</span> <span class="o">((</span> <span class="nv">UID</span> <span class="o">==</span> 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    </span><span class="nb">printf</span> <span class="s2">&quot;/etc/conf.d&quot;</span>
  <span class="k">else</span>
<span class="k">    </span><span class="nb">printf</span> <span class="s2">&quot;$HOME/.conf.d&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>os<em>is</em>linux()</h2>

<p>Tests if the operating system the process is running on is Linux.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 if the operating system is linux
1 if the operating system is not linux</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>root@archlinux# os_is_linux
root@archlinux# echo $?
0
</code></pre>

</td><td class=code><div class=highlight><pre>
os_is_linux<span class="o">()</span>
<span class="o">{</span>
  <span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;$MACHTYPE&quot;</span> <span class="o">=</span> *linux* <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    return </span>0
  <span class="k">else</span>
<span class="k">    return </span>1
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>os<em>is</em>darwin()</h2>

<p>Tests if the operating system the process is running on is darwin.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 if the operating system is darwin
1 if the operating system is not darwin</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>user@OSX# os_is_darwin
user@OSX# echo $?
0
</code></pre>

</td><td class=code><div class=highlight><pre>
os_is_darwin<span class="o">()</span>
<span class="o">{</span>
  <span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;$MACHTYPE&quot;</span> <span class="o">=</span> *darwin* <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    return </span>0
  <span class="k">else</span>
<span class="k">    return </span>1
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>os<em>is</em>bsd()</h2>

<p>Tests if the operating system the process is running on is bsd.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 if the operating system is bsd
1 if the operating system is not bsd</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>root@bsd# os_is_bsd
root@bsd# echo $?
0
</code></pre>

</td><td class=code><div class=highlight><pre>

os_is_bsd<span class="o">()</span>
<span class="o">{</span>
  <span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;$MACHTYPE&quot;</span> <span class="o">=</span> *bsd* <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    return </span>0
  <span class="k">else</span>
<span class="k">    return </span>1
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>os<em>is</em>solaris()</h2>

<p>Tests if the operating system the process is running on is solaris.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 if the operating system is linux
1 if the operating system is not linux</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>root@linux# os_is_linux
root@linux# echo $?
0
</code></pre>

</td><td class=code><div class=highlight><pre>
os_is_solaris<span class="o">()</span>
<span class="o">{</span>
  <span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;$MACHTYPE&quot;</span> <span class="o">=</span> *solaris* <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    return </span>0
  <span class="k">else</span>
<span class="k">    return </span>1
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>os<em>is</em>aix()</h2>

<p>Tests if the operating system the process is running on is aix.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 if the operating system is aix
1 if the operating system is not aix</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>root@aix# os_is_aix
root@aix# echo $?
0
</code></pre>

</td><td class=code><div class=highlight><pre>
os_is_aix<span class="o">()</span>
<span class="o">{</span>
  <span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;$MACHTYPE&quot;</span> <span class="o">=</span> *aix* <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    return </span>0
  <span class="k">else</span>
<span class="k">    return </span>1
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>os_type()</h2>

<p>Prints out the operating system category / type.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Prints the OS category/type to the calling environments STDOUT.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>root@archlinux# os_type
linux

user@osx# os_type
darwin
</code></pre>

</td><td class=code><div class=highlight><pre>
os_type<span class="o">()</span>
<span class="o">{</span>
  <span class="k">case</span> <span class="s2">&quot;$MACHTYPE&quot;</span> in
    <span class="o">(</span>*linux*<span class="o">)</span>
      <span class="nb">printf</span> <span class="s2">&quot;%s&quot;</span> <span class="s2">&quot;linux&quot;</span>
      ;;
    <span class="o">(</span>*darwin*<span class="o">)</span>
      <span class="nb">printf</span> <span class="s2">&quot;%s&quot;</span> <span class="s2">&quot;darwin&quot;</span>
      ;;
    <span class="o">(</span>*bsd*<span class="o">)</span>
      <span class="nb">printf</span> <span class="s2">&quot;%s&quot;</span> <span class="s2">&quot;bsd&quot;</span>
      ;;
    <span class="o">(</span>*solaris*<span class="o">)</span>
      <span class="nb">printf</span> <span class="s2">&quot;%s&quot;</span> <span class="s2">&quot;solaris&quot;</span>
      ;;
    <span class="o">(</span>*aix*<span class="o">)</span>
      <span class="nb">printf</span> <span class="s2">&quot;%s&quot;</span> <span class="s2">&quot;aix&quot;</span>
      ;;
    <span class="o">(</span>*<span class="o">)</span>
      <span class="nb">printf</span> <span class="s2">&quot;%s&quot;</span> <span class="s2">&quot;$MACHTYPE&quot;</span>
      ;;
  <span class="k">esac</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>os<em>arch</em>type()</h2>

<p>Prints out the OS Arch type.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Prints out the architecture type string of the system that is running the
current process.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ os_arch_type
x86_64
</code></pre>

</td><td class=code><div class=highlight><pre>
os_arch_type<span class="o">()</span>
<span class="o">{</span>
  <span class="k">case</span> <span class="s2">&quot;${MACHTYPE//-*}&quot;</span> in
    <span class="o">(</span>i386|i686|i86pc<span class="o">)</span>
      <span class="nb">printf</span> <span class="s2">&quot;%s&quot;</span> <span class="s2">&quot;i386&quot;</span>
      ;;
    <span class="o">(</span>*x86_64*<span class="o">)</span>
      <span class="nb">printf</span> <span class="s2">&quot;%s&quot;</span> <span class="s2">&quot;x86_64&quot;</span>
      ;;
    <span class="o">(</span>*ppc*<span class="o">)</span>
      <span class="nb">printf</span> <span class="s2">&quot;%s&quot;</span> <span class="s2">&quot;ppc&quot;</span>
      ;;
  <span class="k">esac</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>os_arch()</h2>

<p>Prints out the full OS machine type string.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Print the OS machine type string to STDOUT of the calling environment.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>user@OSX# os_arch
i386-apple-darwin10.7.0
</code></pre>

</td><td class=code><div class=highlight><pre>
os_arch<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">printf</span> <span class="s1">&#39;%s&#39;</span> <span class="s2">&quot;${MACHTYPE//-*}&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>os<em>arch</em>capable()</h2>

<p>Tests if the operating system the process is running on is Linux.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 if the operating system is linux
1 if the operating system is not linux</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>user@OSX$ os_arch_capable
x86_64
</code></pre>

</td><td class=code><div class=highlight><pre>
os_arch_capable<span class="o">()</span>
<span class="o">{</span>
  <span class="k">if </span>os_is_darwin
  <span class="k">then</span>
<span class="k">    </span><span class="nb">local </span>_string
    <span class="nb">read</span> -r _string &lt; &lt;<span class="o">(</span>sysctl hw.cpu64bit_capable<span class="o">)</span>
    <span class="k">if</span> <span class="o">((</span> <span class="k">${</span><span class="nv">_string</span><span class="p">//* </span><span class="k">}</span> <span class="o">==</span> 1 <span class="o">))</span>
    <span class="k">then</span>
<span class="k">      </span><span class="nb">printf</span> <span class="s2">&quot;%s&quot;</span> <span class="s2">&quot;x86_64&quot;</span>
    <span class="k">else</span>
<span class="k">      </span>os_arch_type <span class="c"># Either i386 or ppc</span>
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">    </span>os_arch_type
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>os<em>cpu</em>count()</h2>

<p>Print the number of cpu cores on the current system to STDOUT</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>An integer representing the number of CPU cores or 1 if unknown.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ os_cpu_count
24
</code></pre>

</td><td class=code><div class=highlight><pre>
os_cpu_count<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_count</span><span class="o">=</span>1 <span class="c"># Defaulting to 1.</span>

  <span class="k">if </span>os_is_darwin
  <span class="k">then</span>
<span class="k">    </span><span class="nb">read</span> -r _count &lt; &lt;<span class="o">(</span>sysctl hw.ncpu<span class="o">)</span>
    <span class="nv">_count</span><span class="o">=</span><span class="s2">&quot;${_count//* }&quot;</span>
  <span class="k">elif </span>os_is_linux
  <span class="k">then</span>
<span class="k">    </span><span class="nv">_count</span><span class="o">=</span><span class="k">$(</span>awk <span class="s1">&#39;/^processor/{count++} END{print count}&#39;</span> /proc/cpuinfo 2&gt;&amp;1<span class="k">)</span>
  <span class="k">fi</span>

<span class="k">  </span><span class="nb">printf</span> <span class="s1">&#39;%d&#39;</span> <span class="k">${</span><span class="nv">_count</span><span class="k">}</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>os_version()</h2>

<p>Prints the OS version to STDOUT and sets the 'os_version' variable</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>The OS (Kernel) Version is printed to STDOUT.</p>

<h3>Environmental effects</h3>

<p>After running this function the os version is stored in the 'os_version'
variable.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>user@archlinux$ os_version
2.6.38

user@osx$ os_version
10.7.0
</code></pre>

</td><td class=code><div class=highlight><pre>
os_version<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">read</span> -r os_version &lt; &lt;<span class="o">(</span>uname -r<span class="o">)</span>
  <span class="nv">os_version</span><span class="o">=</span><span class="k">${</span><span class="nv">os_version</span><span class="p">//-*</span><span class="k">}</span>
  <span class="nb">printf</span> <span class="s1">&#39;%s&#39;</span> <span class="s2">&quot;${os_version}&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>os<em>version</em>major()</h2>

<p>Prints the OS major version to STDOUT and sets the 'os<em>version</em>major' variable</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>The OS Major Version is printed to STDOUT.</p>

<h3>Environmental effects</h3>

<p>After running this function the os major version is stored in the
'os<em>version</em>major' variable.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>user@archlinux$ os_version
2.6.38

user@osx$ os_version_major
2
</code></pre>

</td><td class=code><div class=highlight><pre>
os_version_major<span class="o">()</span>
<span class="o">{</span>
  <span class="nv">os_version_major</span><span class="o">=</span><span class="k">$(</span>os_version<span class="k">)</span>
  <span class="nv">os_version_major</span><span class="o">=</span><span class="s2">&quot;${os_version_major//\.*}&quot;</span>
  <span class="nb">printf</span> <span class="s2">&quot;${os_version_major}&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>os<em>version</em>minor()</h2>

<p>Prints the OS minor version to STDOUT and sets the 'os<em>version</em>minor' variable</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>The OS minor Version is printed to STDOUT.</p>

<h3>Environmental effects</h3>

<p>After running this function the os minor version is stored in the
'os<em>version</em>minor' variable.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>user@archlinux$ os_version
2.6.38

user@osx$ os_version_minor
6
</code></pre>

</td><td class=code><div class=highlight><pre>
os_version_minor<span class="o">()</span>
<span class="o">{</span>
  <span class="nv">os_version_minor</span><span class="o">=</span><span class="k">$(</span>os_version<span class="k">)</span>
  <span class="nv">os_version_minor</span><span class="o">=</span><span class="s2">&quot;${os_version_minor#*\.}&quot;</span>
  <span class="nv">os_version_minor</span><span class="o">=</span><span class="s2">&quot;${os_version_minor%\.*}&quot;</span>
  <span class="nb">printf</span> <span class="s2">&quot;${os_version_minor}&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>os<em>version</em>patch()</h2>

<p>Prints the OS patch version to STDOUT and sets the 'os<em>version</em>patch' variable</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>The OS patch Version is printed to STDOUT.</p>

<h3>Environmental effects</h3>

<p>After running this function the os patch version is stored in the
'os<em>version</em>patch' variable.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>user@archlinux$ os_version
2.6.38

user@osx$ os_version_patch
38
</code></pre>

</td><td class=code><div class=highlight><pre>
os_version_patch<span class="o">()</span>
<span class="o">{</span>
  <span class="nv">os_version_patch</span><span class="o">=</span><span class="k">$(</span>os_version<span class="k">)</span>
  <span class="nv">os_version_patch</span><span class="o">=</span><span class="s2">&quot;${os_version_patch//*\.}&quot;</span>
  <span class="nb">printf</span> <span class="s2">&quot;${os_version_patch}&quot;</span>
<span class="o">}</span>


</td><td class=code><div class=highlight><pre>
</pre></div></td></tr><tr><td class=docs>

</pre></div></td></tr><tr><td class=docs>
</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs></td><td class='code'></td></tr>
    </tbody>
    </table>
</div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
    <meta http-eqiv='content-type' content='text/html;charset=utf-8'>
    <title>dsl</title>
    <link rel=stylesheet href="http://jashkenas.github.com/docco/resources/docco.css">
</head>
<body>
<div id=container>
    <div id=background></div>
    <table cellspacing=0 cellpadding=0>
    <thead>
      <tr>
        <th class=docs><h1>dsl</h1></th>
        <th class=code></th>
      </tr>
    </thead>
    <tbody>
        <tr><td class='docs'><h2>template_exists()</h2>

<p>Checks if a named template file exists in the extension<em>templates</em>path</p>

<h3>Input Parameters</h3>

<p>First parameter must be the name of a template file, eg. a string.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 if the named template file exists and is nonempty.
1 if the named template file does not exist or is empty.</p>

<h3>Failure Scenarios</h3>

<p>Fails if no template name is given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ {{ setup the scenario }}
user$ function_name {{ parameters }}
user$ {{ demonstrate the results}}
</code></pre>

</td><td class=code><div class=highlight><pre>
<span class="c">#!/usr/bin/env bash</span>

template_exists<span class="o">()</span>
<span class="o">{</span>
  <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${1:-}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot check if a template exists as no template name was given.&quot;</span>
  <span class="k">fi</span>

<span class="k">  </span><span class="nb">local </span><span class="nv">_template</span><span class="o">=</span><span class="s2">&quot;${extension_templates_path}/${1}.template&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -s <span class="s2">&quot;${_template}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    return </span>0
  <span class="k">else</span>
<span class="k">    return </span>1
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>install_template()</h2>

<p>Installs a named template to a given location.</p>

<h3>Input Parameters</h3>

<p>The first parameter should be the template name.
Remaining parameters specify the target, mode and owner:
  owner "&lt;<user>>[:&lt;<group>>]"
  mode 0755
  to "/path/to/new/file"</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 if successful
1 otherwise</p>

<h3>Failure Scenarios</h3>

<p>Fails if no template name was given.
Fails if the template name given is a directory.</p>

<h3>Usage Examples</h3>

<pre><code>user$ install_template "nginx.conf" \
      to "${nginx_path}/nginx.conf" \
      mode 0644 owner "${nginx_user}"
</code></pre>

</td><td class=code><div class=highlight><pre>
install_template<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_template _name _target <span class="nv">_source</span><span class="o">=</span><span class="s2">&quot;${extension_templates_path}&quot;</span> <span class="nv">_mode</span><span class="o">=</span>0644 <span class="nv">_owner</span><span class="o">=</span><span class="nv">$USER</span>

  <span class="k">while</span> <span class="o">((</span> <span class="nv">$# </span>&gt; 0 <span class="o">))</span> ; <span class="k">do</span>
<span class="k">    </span><span class="nv">token</span><span class="o">=</span><span class="s2">&quot;${1}&quot;</span> ; <span class="nb">shift</span>

<span class="nb">    </span><span class="k">case</span> <span class="s2">&quot;${token}&quot;</span> in
      to<span class="o">)</span>
         <span class="nv">_target</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span> ; <span class="nb">shift</span>
        ;;

      mode<span class="o">)</span>
         <span class="nv">_mode</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span> ; <span class="nb">shift</span>
        ;;

      owner<span class="o">)</span>
         <span class="nv">_owner</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span> ; <span class="nb">shift</span>
        ;;

      from<span class="o">)</span> <span class="c"># TODO: finish this part.</span>
         <span class="nv">_source</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span> ; <span class="nb">shift</span>
        ;;

      *<span class="o">)</span>
        <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_name}&quot;</span> <span class="o">]]</span> ; <span class="k">then</span>
<span class="k">          </span><span class="nv">_name</span><span class="o">=</span><span class="s2">&quot;$token&quot;</span>
        <span class="k">elif</span> <span class="o">[[</span> -z <span class="s2">&quot;${_target}&quot;</span> <span class="o">]]</span> ; <span class="k">then</span>
<span class="k">          </span><span class="nv">_target</span><span class="o">=</span><span class="s2">&quot;$token&quot;</span>
          <span class="nb">break</span> <span class="c"># When we have a target we are done.</span>
</pre></div></td></tr><tr><td class=docs>

<p>An alternative idea would be to allow an array of multiple targets
to symlink to...</p>

</td><td class=code><div class=highlight><pre>
        <span class="k">fi</span>
        ;;
    <span class="k">esac</span>
<span class="k">  done</span>

<span class="k">  if </span>file_exists <span class="s2">&quot;${_name}&quot;</span>
  <span class="k">then</span>
<span class="k">    </span><span class="nv">_template</span><span class="o">=</span><span class="s2">&quot;${_name}&quot;</span>
  <span class="k">elif </span>file_exists <span class="s2">&quot;${_source}/${_name}&quot;</span>
  <span class="k">then</span>
<span class="k">    </span><span class="nv">_template</span><span class="o">=</span><span class="s2">&quot;${_source}/${_name}&quot;</span>
  <span class="k">else</span>
<span class="k">    </span><span class="nv">_template</span><span class="o">=</span><span class="s2">&quot;${_source}/${_name}.template&quot;</span>
  <span class="k">fi</span>

<span class="k">  </span>ensure_paths_exist <span class="s2">&quot;$(dirname &quot;</span><span class="k">${</span><span class="nv">_target</span><span class="k">}</span><span class="s2">&quot;)&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -f <span class="s2">&quot;${_template}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    if</span> <span class="o">[[</span> -d <span class="s2">&quot;${_target}&quot;</span> <span class="o">]]</span>
    <span class="k">then</span>
<span class="k">      if</span> <span class="o">[[</span> -d <span class="s2">&quot;${_target}/${_name}&quot;</span> <span class="o">]]</span>
      <span class="k">then</span>
<span class="k">        </span>fail <span class="s2">&quot;Cannot install the template &#39;${_template}&#39; to ${_target}/${_name} &quot;</span><span class="se">\</span>
          <span class="s2">&quot; as it is a directory&quot;</span>
      <span class="k">else</span>
<span class="k">        </span>cp -f <span class="s2">&quot;${_template}&quot;</span> <span class="s2">&quot;${_target}/${_name}&quot;</span>

        <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_mode:-}&quot;</span> <span class="o">]]</span>
        <span class="k">then</span>
<span class="k">          </span>chmod <span class="s2">&quot;${_mode}&quot;</span> <span class="s2">&quot;${_target}/${_name}&quot;</span>
        <span class="k">fi</span>

<span class="k">        if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_owner:-}&quot;</span> <span class="o">]]</span>
        <span class="k">then</span>
<span class="k">          </span>chown <span class="s2">&quot;${_owner}&quot;</span> <span class="s2">&quot;${_target}/${_name}&quot;</span>
        <span class="k">fi</span>
<span class="k">      fi</span>
<span class="k">    else</span>
<span class="k">      </span>cp -f <span class="s2">&quot;${_template}&quot;</span> <span class="s2">&quot;${_target}&quot;</span>

      <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_mode:-}&quot;</span> <span class="o">]]</span>
      <span class="k">then</span>
<span class="k">        </span>chmod <span class="s2">&quot;${_mode}&quot;</span> <span class="s2">&quot;${_target}&quot;</span>
      <span class="k">fi</span>

<span class="k">      if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_owner:-}&quot;</span> <span class="o">]]</span>
      <span class="k">then</span>
<span class="k">        </span>chown <span class="s2">&quot;${_owner}&quot;</span> <span class="s2">&quot;${_target}&quot;</span>
      <span class="k">fi</span>
<span class="k">    fi</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot install template as the template file &#39;${_template}&#39; is missing.&#39;&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>seed_template()</h2>

<p>Seed a template file replacing all given keys with given values.</p>

<h3>Input Parameters</h3>

<p>First parameter must be the template filename to seed.
Remaining parameters must come in pairs, the first of each pair specifies
the key to search and replace in the template file and the second is the
value to replace {{$key}} with.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if no template filename is given.
Fails if the template given does not exist.
Fails if no key/value pairs are given.
Fails if for every key there is no associated value.
Fails if the intermediate template file does not exist...</p>

<h3>Usage Examples</h3>

<p>user$ seed<em>template "/etc/conf.d/${extension}.conf" \
     prefix</em>path "${prefix<em>path}" \
     init</em>scripts<em>path "${init</em>scripts<em>path}" \
     modules</em>path "${modules<em>path}" \
     data</em>path "${data<em>path}" \
     confd</em>path "${confd_path}" \
     extension "${extension}"</p>

</td><td class=code><div class=highlight><pre>
seed_template<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_template</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_template}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span><span class="nb">shift</span>
<span class="nb">    local </span><span class="nv">_args</span><span class="o">=(</span><span class="s2">&quot;$@&quot;</span><span class="o">)</span> <span class="nv">_strings</span><span class="o">=()</span>
    <span class="k">if</span> <span class="o">[[</span> -f <span class="s2">&quot;${_template}&quot;</span> <span class="o">]]</span>
    <span class="k">then</span>
<span class="k">      if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">_args</span><span class="p">[@]</span><span class="k">}</span> <span class="o">==</span> 0 <span class="o">))</span>
      <span class="k">then</span>
<span class="k">        </span>fail <span class="s2">&quot;Cannot seed template &#39;${_template}&#39; as no replacement keys were&quot;</span><span class="se">\</span>
          <span class="s2">&quot;specified&quot;</span>
      <span class="k">else</span>
<span class="k">        if</span> <span class="o">((</span> <span class="o">(</span> <span class="k">${#</span><span class="nv">_args</span><span class="p">[@]</span><span class="k">}</span> % 2 <span class="o">)</span> <span class="o">==</span> 1 <span class="o">))</span>
        <span class="k">then</span>
<span class="k">          </span>fail <span class="s2">&quot;Every replacement key must have a replacement value.&quot;</span>
        <span class="k">fi</span>
<span class="k">      fi</span>

<span class="k">      </span>warn <span class="s2">&quot;Template Seeding (replacing defaults) has not yet fully implemented.&quot;</span>

</pre></div></td></tr><tr><td class=docs>

<p>Aggregate the replacement strings.</p>

</td><td class=code><div class=highlight><pre>
      <span class="k">for</span> <span class="o">((</span> <span class="nv">index</span><span class="o">=</span>0 ; index &lt; <span class="k">${#</span><span class="nv">_args</span><span class="p">[@]</span><span class="k">}</span> ; index++ <span class="o">))</span>
      <span class="k">do</span>
<span class="k">        </span>_strings+<span class="o">=(</span><span class="s2">&quot; -e &#39;s#${_args[${index}]}#${_args[$((++index))]}#g&#39; &quot;</span><span class="o">)</span>
      <span class="k">done</span>

</pre></div></td></tr><tr><td class=docs>

<p>Filter the template with the replacments.</p>

</td><td class=code><div class=highlight><pre>
      sed <span class="k">${</span><span class="nv">_strings</span><span class="p">[@]</span><span class="k">}</span> <span class="k">${</span><span class="nv">_template</span><span class="k">}</span> &gt;&gt; <span class="k">${</span><span class="nv">_template</span><span class="k">}</span>.<span class="k">${</span><span class="nv">timestamp</span><span class="k">}</span>

      <span class="k">if </span>file_exists <span class="s2">&quot;${_template}.${timestamp}&quot;</span>
      <span class="k">then</span>
<span class="k">        </span>mv -f <span class="s2">&quot;${_template}.${timestamp}&quot;</span> <span class="s2">&quot;${_template}&quot;</span>
      <span class="k">else</span>
<span class="k">        </span>fail <span class="s2">&quot;Something went horribly wrong, the template intermediate file &quot;</span><span class="se">\</span>
          <span class="s2">&quot;&#39;${_template}.${timestamp}&#39; does not exist.&quot;</span>
      <span class="k">fi</span>
<span class="k">    else</span>
<span class="k">      </span>fail <span class="s2">&quot;Can not seed template template file &#39;${_template}&#39; does not exist.&quot;</span>
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Can not install template as no template was given.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>



</td><td class=code><div class=highlight><pre>
</pre></div></td></tr><tr><td class=docs>

</pre></div></td></tr><tr><td class=docs>
</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs></td><td class='code'></td></tr>
    </tbody>
    </table>
</div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
    <meta http-eqiv='content-type' content='text/html;charset=utf-8'>
    <title>dsl</title>
    <link rel=stylesheet href="http://jashkenas.github.com/docco/resources/docco.css">
</head>
<body>
<div id=container>
    <div id=background></div>
    <table cellspacing=0 cellpadding=0>
    <thead>
      <tr>
        <th class=docs><h1>dsl</h1></th>
        <th class=code></th>
      </tr>
    </thead>
    <tbody>
        <tr><td class='docs'><h2>timestamp_set()</h2>

<p>Sets the variable named 'timestamp' to the current timestamp.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>Sets the variable named 'timestamp' to the current timestamp.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ cat ./test
#!/usr/bin/env bash
source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
modules trace time # Load the trace module.

timestamp_set
echo $timestamp

user$ $PWD/test
2011-04-24T22:28:16
</code></pre>

</td><td class=code><div class=highlight><pre>
<span class="c">#!/usr/bin/env bash</span>

timestamp_set<span class="o">()</span>
<span class="o">{</span>
  <span class="nv">timestamp</span><span class="o">=</span><span class="k">$(</span>timestamp<span class="k">)</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>timestamp()</h2>

<p>Prints out the current timestamp.</p>

<h3>Input Parameters</h3>

<p>None required. The first parameter may optionally specify the format to output
the time string in. See 'man 1 date' for formatting options.</p>

<h3>Stream Outputs</h3>

<p>Prints the current timestamp as a formatted datetime string to the STDOUT of
the calling environment.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>No failure conditions currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ cat ./test
#!/usr/bin/env bash
source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
modules trace time # Load the trace module.

timestamp
echo

user$ $PWD/test
2011-04-24T22:31:54
</code></pre>

</td><td class=code><div class=highlight><pre>
timestamp<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_format</span><span class="o">=</span><span class="s2">&quot;${1:-&quot;</span>%Y-%m-%dT%H:%M:%S<span class="s2">&quot;}&quot;</span>

  <span class="nb">printf</span> <span class="s2">&quot;%s&quot;</span> <span class="s2">&quot;$(date +&quot;</span><span class="k">${</span><span class="nv">_format</span><span class="k">}</span><span class="s2">&quot;)&quot;</span>
<span class="o">}</span>



</td><td class=code><div class=highlight><pre>
</pre></div></td></tr><tr><td class=docs>

</pre></div></td></tr><tr><td class=docs>
</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs></td><td class='code'></td></tr>
    </tbody>
    </table>
</div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
    <meta http-eqiv='content-type' content='text/html;charset=utf-8'>
    <title>dsl</title>
    <link rel=stylesheet href="http://jashkenas.github.com/docco/resources/docco.css">
</head>
<body>
<div id=container>
    <div id=background></div>
    <table cellspacing=0 cellpadding=0>
    <thead>
      <tr>
        <th class=docs><h1>dsl</h1></th>
        <th class=code></th>
      </tr>
    </thead>
    <tbody>
        <tr><td class='docs'><h2>set_ps4()</h2>

<p>Set the environmental PS4 variable for informative tracing.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ echo "'$PS4'"
'+ '
user$ set_ps4
user$ echo "'$PS4'"
' &gt; ${BASH_SOURCE##${bdsm_path}\/} ${FUNCNAME[0]:+${FUNCNAME[0]}()} ${LINENO} $ '
</code></pre>

</td><td class=code><div class=highlight><pre>
<span class="c">#!/usr/bin/env bash</span>

set_ps4<span class="o">()</span>
<span class="o">{</span>
  <span class="nv">PS4</span><span class="o">=</span><span class="s2">&quot; &gt; \${BASH_SOURCE##\${bdsm_path}\/} \${FUNCNAME[0]:+\${FUNCNAME[0]}()} \${LINENO} $ &quot;</span>
  <span class="nb">export </span>PS4
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>trace()</h2>

<p>Toggle tracing functionality on or off. If 'on' is triggered then every line
of code execution after the function returns will be displayed in the format
specified by the PS4 environment variable (see set_ps4).</p>

<h3>Input Parameters</h3>

<p>First parameter is either empty, 'on' or 'off'</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ trace on
user$ echo "hi"
&gt;   1 $ echo hi
user$ trace off
&gt;  trace() 1 $ local _option=off
&gt;  trace() 3 $ [[ off = \o\n ]]
&gt;  trace() 8 $ set +o xtrace
</code></pre>

</td><td class=code><div class=highlight><pre>
trace<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_option</span><span class="o">=</span><span class="s2">&quot;${1:-on}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;${_option}&quot;</span> <span class="o">=</span> <span class="s2">&quot;on&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span><span class="nb">export </span><span class="nv">trace_flag</span><span class="o">=</span>1
    <span class="nb">set</span> -o xtrace
  <span class="k">else</span>
<span class="k">    </span><span class="nb">set</span> +o xtrace
    <span class="nb">export </span><span class="nv">trace_flag</span><span class="o">=</span>0
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>enable_trace()</h2>

<p>Turns tracing on.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ enable_trace
</code></pre>

</td><td class=code><div class=highlight><pre>
enable_trace<span class="o">()</span>
<span class="o">{</span>
  trace on
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>disable_trace()</h2>

<p>Turns tracing off.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No current failure scenarios.</p>

<h3>Usage Examples</h3>

<pre><code>user$ disable_trace
</code></pre>

</td><td class=code><div class=highlight><pre>
disable_trace<span class="o">()</span>
<span class="o">{</span>
  trace off
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>debug()</h2>

<p>Toggle verbose debugging functionality on or off. If 'on' is triggered then
every line of code execution after the function returns will be displayed.</p>

<h3>Input Parameters</h3>

<p>First parameter is either empty, 'on' or 'off'</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ debug on
user$ echo "hi"
&gt;   1 $ echo hi
user$ debug off
&gt;  debug() 1 $ local _option=off
&gt;  debug() 3 $ [[ off = \o\n ]]
&gt;  debug() 8 $ set +o xdebug
</code></pre>

</td><td class=code><div class=highlight><pre>
debug<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_option</span><span class="o">=</span><span class="s2">&quot;${1:-on}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> <span class="s2">&quot;${_option}&quot;</span> <span class="o">=</span> <span class="s2">&quot;on&quot;</span> <span class="o">]]</span> ;<span class="k">then</span>
<span class="k">    </span><span class="nb">export </span><span class="nv">debug_flag</span><span class="o">=</span>1
    <span class="nb">set</span> -o verbose
  <span class="k">else</span>
<span class="k">    </span><span class="nb">set</span> +o verbose
    <span class="nb">export </span><span class="nv">debug_flag</span><span class="o">=</span>0
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>enable_debug()</h2>

<p>Enables verbose debugging output.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ enable_debug
</code></pre>

</td><td class=code><div class=highlight><pre>
enable_debug<span class="o">()</span>
<span class="o">{</span>
  debug on
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>disable_debug()</h2>

<p>Disables verbose debugging output.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ disable_debug
</code></pre>

</td><td class=code><div class=highlight><pre>
disable_debug<span class="o">()</span>
<span class="o">{</span>
  debug off
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>enable_backtrace()</h2>

<p>Enables backtrace and program exit whenever a command returns a nonzero value
that is not handled.</p>

<h3>Input Parameters</h3>

<p>First parameter is optional. If it is passed it is a message that will be
outputed when a command trigger the program to error exit.</p>

<h3>Stream Outputs</h3>

<p>What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure conditions currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ cat ./test
#!/usr/bin/env bash
source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
modules trace # Load the trace module.
enable_backtrace
echo "Error exit with backtrace is now off."
false # Does not cause exiting with backtrace printing.

user$ $PWD/test
Error exit with backtrace is on.
ERROR: A command has returned an unhandled error code (nonzero return value).
Error Backtrace:
   Trace   Function           Line  File
      1.   main()                7  /Users/wayneeseguin/test
</code></pre>

</td><td class=code><div class=highlight><pre>
enable_backtrace<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_message</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_message}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span><span class="nb">trap</span> <span class="s2">&quot;backtrace \&quot;${_message}\&quot;&quot;</span> ERR
  <span class="k">else</span>
<span class="k">    </span><span class="nb">trap</span> <span class="s2">&quot;backtrace \&quot;A command has returned an unhandled error code (nonzero return value).\&quot;&quot;</span> ERR
  <span class="k">fi</span>
<span class="k">  </span><span class="nb">set</span> -o errexit
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>function_name()</h2>

<p>Function Description</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure conditions currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ cat ./test
#!/usr/bin/env bash
source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
modules trace # Load the trace module.
disable_backtrace
echo "Error exit with backtrace is now off."
false # Does not cause exiting with backtrace printing.

user$ ./test
Error exit with backtrace is now off.
</code></pre>

</td><td class=code><div class=highlight><pre>

disable_backtrace<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">set</span> +o errexit
  <span class="nb">trap</span> - ERR
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>backtrace()</h2>

<p>Display a backtrace of the current call stack to the point that backtrace was
called from. Currently trace is turned on as well so that execution after
calling backtrace is traced.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>The call stack up to the current point of execution is printed to STDOUT of
the calling environment.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ cat ./test
#!/usr/bin/env bash
source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
modules trace # Load the trace module.

functiona()
{
  echo "function a"
  functionb
  echo "function a"
}

functionb()
{
  echo "function b"
  functionc
  echo "function b"
}

functionc()
{
  echo "function c"
  backtrace
  echo "function c"
}

functiona

user$ $PWD/test
function a
function b
function c
Error Backtrace:
   Trace   Line Function             File
      4.     25 functionc()          /Users/wayneeseguin/test
      3.     18 functionb()          /Users/wayneeseguin/test
      2.     11 functiona()          /Users/wayneeseguin/test
      1.     29 main()               /Users/wayneeseguin/test
 &gt; /Users/wayneeseguin/test functionc() 26 $ echo 'function c'
function c
 &gt; /Users/wayneeseguin/test functionb() 19 $ echo 'function b'
function b
 &gt; /Users/wayneeseguin/test functiona() 12 $ echo 'function a'
function a
</code></pre>

</td><td class=code><div class=highlight><pre>
backtrace<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">set</span> +o xtrace
  <span class="nb">local </span>_separator <span class="nv">_columns</span><span class="o">=</span><span class="k">$(</span>tput cols<span class="k">)</span>
  <span class="nb">printf</span> -v _separator <span class="s1">&#39;%*s&#39;</span> <span class="s2">&quot;${_columns:-${COLUMNS:-80}}&quot;</span>
  <span class="nb">local </span><span class="nv">_message</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_message}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span><span class="nb">printf</span> <span class="s2">&quot;\n${_message}\n\n&quot;</span>
  <span class="k">fi</span>

<span class="k">  </span><span class="nb">local </span>_source _function _line _index _largest _format _digits _longest

  <span class="k">for</span> <span class="o">((</span> <span class="nv">_index</span><span class="o">=</span>0 ; _index &lt; <span class="k">${#</span><span class="nv">FUNCNAME</span><span class="p">[@]</span><span class="k">}</span> ; _index++ <span class="o">))</span>
  <span class="k">do</span>
<span class="k">    if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">FUNCNAME</span><span class="p">[</span><span class="k">${</span><span class="nv">_index</span><span class="k">}</span><span class="p">]</span><span class="k">}</span> &gt; <span class="k">${#</span><span class="nv">_largest</span><span class="k">}</span> <span class="o">))</span>
    <span class="k">then</span>
<span class="k">      </span><span class="nv">_largest</span><span class="o">=</span><span class="k">${</span><span class="nv">FUNCNAME</span><span class="p">[</span><span class="k">${</span><span class="nv">_index</span><span class="k">}</span><span class="p">]</span><span class="k">}</span>
    <span class="k">fi</span>
<span class="k">  done</span>

<span class="k">  for</span> <span class="o">((</span> <span class="nv">_index</span><span class="o">=</span>0 ; _index &lt; <span class="k">${#</span><span class="nv">BASH_SOURCE</span><span class="p">[@]</span><span class="k">}</span> ; _index++ <span class="o">))</span>
  <span class="k">do</span>
<span class="k">    if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">BASH_SOURCE</span><span class="p">[</span><span class="k">${</span><span class="nv">_index</span><span class="k">}</span><span class="p">]</span><span class="k">}</span> &gt; <span class="k">${#</span><span class="nv">_longest</span><span class="k">}</span> <span class="o">))</span>
    <span class="k">then</span>
<span class="k">      </span><span class="nv">_longest</span><span class="o">=</span><span class="k">${</span><span class="nv">BASH_SOURCE</span><span class="p">[</span><span class="k">${</span><span class="nv">_index</span><span class="k">}</span><span class="p">]</span><span class="k">}</span>
    <span class="k">fi</span>
<span class="k">  done</span>

<span class="k">  for</span> <span class="o">((</span> <span class="nv">_index</span><span class="o">=</span>0 ; _index &lt; <span class="k">${#</span><span class="nv">BASH_LINENO</span><span class="p">[@]</span><span class="k">}</span> ; _index++ <span class="o">))</span>
  <span class="k">do</span>
<span class="k">    if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">BASH_LINENO</span><span class="p">[</span><span class="k">${</span><span class="nv">_index</span><span class="k">}</span><span class="p">]</span><span class="k">}</span> &gt; <span class="k">${#</span><span class="nv">_digits</span><span class="k">}</span> <span class="o">))</span>
    <span class="k">then</span>
<span class="k">      </span><span class="nv">_digits</span><span class="o">=</span><span class="k">${</span><span class="nv">BASH_LINENO</span><span class="p">[</span><span class="k">${</span><span class="nv">_index</span><span class="k">}</span><span class="p">]</span><span class="k">}</span>
    <span class="k">fi</span>
<span class="k">  done</span>

<span class="k">  case</span> <span class="s2">&quot;${EDITOR:-}&quot;</span> in
    <span class="o">(</span>mvim*|mate*<span class="o">)</span>
      <span class="c">#_format=&quot; %-$((${#_largest} + 2))s %-$((${#EDITOR} + ${#_digits} + 19 + ${#_longest}))s\n&quot;</span>
      <span class="nv">_format</span><span class="o">=</span><span class="s2">&quot;%-$((${#_largest} + 2))s %-s\n&quot;</span>
      <span class="nb">printf</span> <span class="s2">&quot;${_format}&quot;</span> <span class="s2">&quot;function()&quot;</span> <span class="s2">&quot;Source&quot;</span>  1&gt;&amp;2
      ;;
    <span class="o">(</span>vi*|gvim*|emacs*|*<span class="o">)</span>
      <span class="nv">_format</span><span class="o">=</span><span class="s2">&quot;%-$((${#_largest} + 2))s $ %${#EDITOR}s +%-$((${#_digits}))s %-$((${#_longest} + 2))s %s\n&quot;</span>
      <span class="nb">printf</span> <span class="s2">&quot;${_format}&quot;</span> <span class="s2">&quot;function()&quot;</span> <span class="s1">&#39; &#39;</span> <span class="s2">&quot;#&quot;</span> <span class="s2">&quot;source file&quot;</span>  1&gt;&amp;2

      ;;
  <span class="k">esac</span>

<span class="k">  </span><span class="nb">printf</span> <span class="s2">&quot;${_separator// /=}\n&quot;</span> 1&gt;&amp;2

  <span class="k">for</span> <span class="o">((</span> <span class="nv">_index</span><span class="o">=</span>1 ; _index &lt; <span class="k">${#</span><span class="nv">FUNCNAME</span><span class="p">[@]</span><span class="k">}</span> ; ++_index <span class="o">))</span>
  <span class="k">do</span>
<span class="k">    </span><span class="nv">_source</span><span class="o">=</span><span class="s2">&quot;${BASH_SOURCE[${_index}]}&quot;</span>
    <span class="nv">_function</span><span class="o">=</span><span class="s2">&quot;${FUNCNAME[${_index}]:+${FUNCNAME[${_index}]}()}&quot;</span>
    <span class="nv">_line</span><span class="o">=</span><span class="k">${</span><span class="nv">BASH_LINENO</span><span class="p">[</span><span class="k">$((</span> _index <span class="o">-</span> <span class="m">1</span> <span class="k">))</span><span class="p">]</span><span class="k">}</span>

    <span class="k">case</span> <span class="s2">&quot;$_function&quot;</span> in
      fail<span class="se">\(\)</span>|error<span class="se">\(\)</span>|command_not_found_handle<span class="se">\(\)</span>|command_not_found<span class="se">\(\)</span><span class="o">)</span>
        <span class="k">continue</span>
        ;;
    <span class="k">esac</span>

<span class="k">    case</span> <span class="s2">&quot;${EDITOR:-}&quot;</span> in
      <span class="o">(</span>mvim*|mate*<span class="o">)</span>
        <span class="nb">printf</span> <span class="s2">&quot;${_format}&quot;</span> <span class="s2">&quot;${_function}&quot;</span> <span class="s2">&quot;${EDITOR// *}://open?url=file://${_source}&amp;line=${_line}&quot;</span> 1&gt;&amp;2
        ;;
      <span class="o">(</span>vi*|gvim*|emacs*|*<span class="o">)</span>
        <span class="nb">printf</span> <span class="s2">&quot;${_format}&quot;</span> <span class="s2">&quot;${_function}&quot;</span> <span class="s2">&quot;${EDITOR}&quot;</span> <span class="s2">&quot;${_line}&quot;</span> <span class="s2">&quot;${_source} &quot;</span> 1&gt;&amp;2
        ;;
    <span class="k">esac</span>
<span class="k">  done</span>
<span class="k">  </span><span class="nb">printf</span> <span class="s2">&quot;${_separator// /=}\n&quot;</span> 1&gt;&amp;2

  <span class="k">if</span> <span class="o">((</span> trace_flag &gt; 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    </span>enable_trace
  <span class="k">fi</span>
<span class="o">}</span>



</td><td class=code><div class=highlight><pre>
</pre></div></td></tr><tr><td class=docs>

</pre></div></td></tr><tr><td class=docs>
</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs></td><td class='code'></td></tr>
    </tbody>
    </table>
</div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
    <meta http-eqiv='content-type' content='text/html;charset=utf-8'>
    <title>dsl</title>
    <link rel=stylesheet href="http://jashkenas.github.com/docco/resources/docco.css">
</head>
<body>
<div id=container>
    <div id=background></div>
    <table cellspacing=0 cellpadding=0>
    <thead>
      <tr>
        <th class=docs><h1>dsl</h1></th>
        <th class=code></th>
      </tr>
    </thead>
    <tbody>
        <tr><td class='docs'><h2>user<em>create</em>if_missing()</h2>

<p>Create a system user if it does not exist on the system.</p>

<h3>Input Parameters</h3>

<p>The first parameter should be the user name, then optionally
  [with] group {{groupname}}</p>

<h3>Stream Outputs</h3>

<p>What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.</p>

<h3>Environmental effects</h3>

<p>What, if any, environmental side effects this function causes. 'None.' for none.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if no username is given.</p>

<h3>Usage Examples</h3>

<pre><code>user$ user_create_if_missing "nginx" with group "nginx"
</code></pre>

</td><td class=code><div class=highlight><pre>
<span class="c">#!/usr/bin/env bash</span>

user_create_if_missing<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_token _group
</pre></div></td></tr><tr><td class=docs>

<p>parse arguments</p>

</td><td class=code><div class=highlight><pre>
  <span class="k">while</span> <span class="o">((</span> <span class="nv">$# </span>&gt; 0 <span class="o">))</span> ; <span class="k">do</span>
<span class="k">    </span><span class="nv">_token</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span> ; <span class="nb">shift</span>

<span class="nb">    </span><span class="k">case</span> <span class="s2">&quot;${_token}&quot;</span> in
      group<span class="o">)</span>
        <span class="nv">_group</span><span class="o">=</span><span class="s2">&quot;${1}&quot;</span> ; <span class="nb">shift</span>
        ;;
      with<span class="o">)</span>
        <span class="k">continue</span> <span class="c"># Syntatic sugar, ignore, next!</span>
        ;;
      from<span class="o">)</span>
        <span class="nv">_source</span><span class="o">=</span><span class="s2">&quot;${1}&quot;</span> ; <span class="nb">shift</span>
        ;;
      --force<span class="o">)</span>
        <span class="nv">_force_flag</span><span class="o">=</span>1
        ;;

      *<span class="o">)</span>
        <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_group}&quot;</span> <span class="o">]]</span> ; <span class="k">then</span>
<span class="k">          </span><span class="nv">_group</span><span class="o">=</span><span class="s2">&quot;${_token}&quot;</span>
          <span class="nb">break</span>
<span class="nb">        </span><span class="k">fi</span>
        ;;
    <span class="k">esac</span>
<span class="k">  done</span>

<span class="k">  if</span> <span class="o">((</span> <span class="nv">UID</span> <span class="o">==</span> 0 <span class="o">))</span> ; <span class="k">then</span>
    <span class="o">(</span>
    <span class="k">case</span> <span class="s2">&quot;$(uname)&quot;</span> in
      <span class="s2">&quot;OpenBSD&quot;</span><span class="o">)</span>
        groupadd <span class="s2">&quot;$package_user&quot;</span>
        useradd -g <span class="s2">&quot;$package_user&quot;</span> <span class="s2">&quot;$package_user&quot;</span> -s /bin/bash
        usermod -s /bin/bash <span class="s2">&quot;$package_user&quot;</span>
        ;;

      <span class="s2">&quot;FreeBSD&quot;</span><span class="o">)</span>
        pw groupadd -q <span class="s2">&quot;$package_user&quot;</span>
        ;;

      <span class="s2">&quot;Linux&quot;</span><span class="o">)</span>
</pre></div></td></tr><tr><td class=docs>

<p>groupadd nginx
useradd -G nginx -M nginx</p>

</td><td class=code><div class=highlight><pre>
        <span class="k">if</span> <span class="o">[[</span> -f <span class="s2">&quot;/etc/SuSE-release&quot;</span> <span class="o">]]</span> ; <span class="k">then</span>
<span class="k">          </span>groupadd <span class="s2">&quot;$package_user&quot;</span>
        <span class="k">else</span>
<span class="k">          </span>groupadd -f <span class="s2">&quot;$package_user&quot;</span>
        <span class="k">fi</span>

<span class="k">        </span>useradd -g <span class="s2">&quot;${package_user}&quot;</span> <span class="s2">&quot;${package_user}&quot;</span>
        usermod -d <span class="s2">&quot;${data_path%\/*}&quot;</span> <span class="s2">&quot;${package_user}&quot;</span>
        usermod -s /bin/bash <span class="s2">&quot;${package_user}&quot;</span>
      ;;

      <span class="s2">&quot;Darwin&quot;</span><span class="o">)</span>
        <span class="nv">current_max_gid</span><span class="o">=</span><span class="k">$(</span>dscl . -list /Groups gid | awk <span class="s1">&#39;{print $2}&#39;</span> | sort -g -r | head -1<span class="k">)</span>
        <span class="nv">next_gid</span><span class="o">=</span><span class="k">$((</span>current_max_gid+1<span class="k">))</span>

        <span class="nv">current_max_uid</span><span class="o">=</span><span class="k">$(</span>dscl . -list /Users UniqueID | awk <span class="s1">&#39;{print $2}&#39;</span> | sort -g -r | head -1<span class="k">)</span>
        <span class="nv">next_uid</span><span class="o">=</span><span class="k">$((</span>current_max_uid+1<span class="k">))</span>

        <span class="k">if</span> ! dscl . -list /Users | grep -q <span class="s2">&quot;^${package_user}$&quot;</span> ; <span class="k">then</span>
<span class="k">          </span>dscl . -create <span class="s2">&quot;/Groups/$package_user&quot;</span>
          dscl . -create <span class="s2">&quot;/Groups/$package_user&quot;</span> gid <span class="s2">&quot;$next_gid&quot;</span>
          dscl . -create <span class="s2">&quot;/Users/${package_user}&quot;</span>
          dscl . -create <span class="s2">&quot;/Users/${package_user}&quot;</span> PrimaryGroupID <span class="s2">&quot;$gid&quot;</span> <span class="c"># UserShell /bin/bash</span>
          dscl . -create <span class="s2">&quot;/Users/${package_user}&quot;</span> uid <span class="s2">&quot;$next_uid&quot;</span>
          dscl . -create <span class="s2">&quot;/Users/${package_user}&quot;</span> realname <span class="s2">&quot;Postgresql User&quot;</span>
          dscl . -create <span class="s2">&quot;/Users/${package_user}&quot;</span> home <span class="s2">&quot;${data_path%\/*}&quot;</span>
          dscl . -create <span class="s2">&quot;/Users/${package_user}&quot;</span> shell <span class="s2">&quot;/bin/bash&quot;</span>
          dscl . -create <span class="s2">&quot;/Users/${package_user}&quot;</span> gid <span class="s2">&quot;$gid&quot;</span>
          dscl . -create <span class="s2">&quot;/Users/${package_user}&quot;</span> passwd <span class="s2">&quot;*&quot;</span>
        <span class="k">fi</span>
      ;;

      <span class="s2">&quot;SunOS&quot;</span><span class="o">)</span>
        groupadd <span class="s2">&quot;$package_user&quot;</span>
        useradd -g <span class="s2">&quot;$package_user&quot;</span> -s /bin/bash -d <span class="s2">&quot;${data_path}&quot;</span> <span class="s2">&quot;$package_user&quot;</span>
        usermod -s /bin/bash <span class="s2">&quot;$package_user&quot;</span>
        ;;
    <span class="k">esac</span>
    <span class="o">)</span> <span class="o">||</span> <span class="nb">true</span> <span class="c"># Ignore failures with this for now...</span>
  <span class="k">else</span>
<span class="k">    </span>fail <span class="s2">&quot;Users and groups may be manipulated only by the super user (root) via su or sudo.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>user_delete()</h2>

<p>Deletes the named system user.</p>

<h3>Input Parameters</h3>

<p>The first parameter is the system user to delete.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>The given user will no longer exist on the system.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if the user name was not specified.</p>

<h3>Usage Examples</h3>

<pre><code>user$ user_delete "nginx"
</code></pre>

</td><td class=code><div class=highlight><pre>
user_delete<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_token _group
</pre></div></td></tr><tr><td class=docs>

<p>parse arguments</p>

</td><td class=code><div class=highlight><pre>
  <span class="k">while</span> <span class="o">((</span> <span class="nv">$# </span>&gt; 0 <span class="o">))</span> ; <span class="k">do</span>
<span class="k">    </span><span class="nv">_token</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span> ; <span class="nb">shift</span>

<span class="nb">    </span><span class="k">case</span> <span class="s2">&quot;${_token}&quot;</span> in
      group<span class="o">)</span>
        <span class="nv">_group</span><span class="o">=</span><span class="s2">&quot;${1}&quot;</span> ; <span class="nb">shift</span>
        ;;
      with<span class="o">)</span>
        <span class="k">continue</span> <span class="c"># Syntatic sugar, ignore, next!</span>
        ;;
      from<span class="o">)</span>
        <span class="nv">_source</span><span class="o">=</span><span class="s2">&quot;${1}&quot;</span> ; <span class="nb">shift</span>
        ;;
      --force<span class="o">)</span>
        <span class="nv">_force_flag</span><span class="o">=</span>1
        ;;

      *<span class="o">)</span>
        <span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_group}&quot;</span> <span class="o">]]</span> ; <span class="k">then</span>
<span class="k">          </span><span class="nv">_group</span><span class="o">=</span><span class="s2">&quot;${_token}&quot;</span>
          <span class="nb">break</span>
<span class="nb">        </span><span class="k">fi</span>
        ;;
    <span class="k">esac</span>
<span class="k">  done</span>

<span class="k">  if</span> <span class="o">((</span> <span class="nv">UID</span> <span class="o">==</span> 0 <span class="o">))</span> ; <span class="k">then</span>
    <span class="o">(</span>
    <span class="k">case</span> <span class="s2">&quot;$(uname)&quot;</span> in
      <span class="s2">&quot;OpenBSD&quot;</span><span class="o">)</span>
        groupdel <span class="s2">&quot;$package_user&quot;</span>
        userdel -g <span class="s2">&quot;$package_user&quot;</span> <span class="s2">&quot;$package_user&quot;</span>
        ;;

      <span class="s2">&quot;FreeBSD&quot;</span><span class="o">)</span>
        pw groupdel -q <span class="s2">&quot;$package_user&quot;</span>
        ;;

      <span class="s2">&quot;Linux&quot;</span><span class="o">)</span>
        userdel <span class="s2">&quot;${package_user}&quot;</span>
      ;;

      <span class="s2">&quot;Darwin&quot;</span><span class="o">)</span>
        <span class="nv">gid</span><span class="o">=</span><span class="s2">&quot;501&quot;</span> <span class="c">#only gids &gt; 500 show up in user preferences</span>

        <span class="c">#Find an open gid</span>
        <span class="k">while </span><span class="nb">true</span>; <span class="k">do</span>
<span class="k">          </span><span class="nv">name</span><span class="o">=</span><span class="k">$(</span>dscl . search /groups PrimaryGroupID <span class="nv">$gid</span> | cut -f1 -s<span class="k">)</span>
          <span class="k">if</span> <span class="o">[</span> -z <span class="s2">&quot;$name&quot;</span> <span class="o">]</span> ; <span class="k">then</span>
<span class="k">            </span><span class="nb">break</span>
<span class="nb">          </span><span class="k">fi</span>
<span class="k">          </span><span class="nv">gid</span><span class="o">=</span><span class="nv">$[$gid</span> +1<span class="o">]</span>
        <span class="k">done</span>

        <span class="c">#Create the group</span>
        dscl . -delete <span class="s2">&quot;/Users/${package_user}&quot;</span> PrimaryGroupID <span class="s2">&quot;$gid&quot;</span> <span class="c"># UserShell /bin/bash</span>
        dscl . -delete <span class="s2">&quot;/Groups/$package_user&quot;</span>
        dscl . -delete <span class="s2">&quot;/Groups/$package_user&quot;</span> gid <span class="s2">&quot;$gid&quot;</span>
      ;;

      <span class="s2">&quot;SunOS&quot;</span><span class="o">)</span>
        groupdel <span class="s2">&quot;$package_user&quot;</span>
        userdel <span class="s2">&quot;$package_user&quot;</span>
        ;;
    <span class="k">esac</span>
    <span class="o">)</span> <span class="o">||</span> <span class="nb">true</span> <span class="c"># Ignore failures with this for now...</span>
  <span class="k">else</span>
<span class="k">    </span>fail <span class="s2">&quot;Users and groups may be manipulated only by the super user (root) via su or sudo.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>user<em>is</em>root()</h2>

<p>Tests if the user the current process is running as is root.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 if user is root (UID 0).
1 if user is not root (UID 0).</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently.</p>

<h3>Usage Examples</h3>

<pre><code>user$ user_is_root
user$ echo $?
1

root# user_is_root
root# echo $?
0
</code></pre>

</td><td class=code><div class=highlight><pre>
user_is_root<span class="o">()</span>
<span class="o">{</span>
  <span class="k">if</span> <span class="o">((</span> <span class="nv">UID</span> <span class="o">==</span> 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    return </span>0
  <span class="k">else</span>
<span class="k">    return </span>1
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>user<em>is</em>not_root()</h2>

<p>Tests if the user the current process is running as is not root.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 if user is not root (eg UID is nonzero)
1 if user is root (UID 0)</p>

<h3>Failure Scenarios</h3>

<p>No failure scenarios currently</p>

<h3>Usage Examples</h3>

<pre><code>user$ user_is_not_root
user$ echo $?
0

root# user_is_not_root
root# echo $?
1
</code></pre>

</td><td class=code><div class=highlight><pre>
user_is_not_root<span class="o">()</span>
<span class="o">{</span>
  <span class="k">if</span> <span class="o">((</span> UID !<span class="o">=</span> 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    return </span>0
  <span class="k">else</span>
<span class="k">    return </span>1
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>user<em>must</em>be_root()</h2>

<p>Halts the calling program with a failure message if the user is not root.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>A failure message is output to STDERR if the failure condition is met.</p>

<h3>Environmental effects</h3>

<p>What, if any, environmental side effects this function causes. 'None.' for none.</p>

<h3>Return Codes</h3>

<p>0 if the user is root</p>

<h3>Failure Scenarios</h3>

<p>Fails if the program user running is not root.</p>

<h3>Usage Examples</h3>

<pre><code>user$ user_must_be_root
ERROR: bdsm test test must be run as root and NOT as a user(user)
</code></pre>

</td><td class=code><div class=highlight><pre>
user_must_be_root<span class="o">()</span>
<span class="o">{</span>
  user_is_root <span class="o">||</span>
    fail <span class="s2">&quot;bdsm $extension $action must be run as a root and NOT as a user ($USER).&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>user<em>must</em>not<em>be</em>root()</h2>

<p>Halts the calling program with a failure message if the user is not root.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>A failure message is output to STDERR if the failure condition is met.</p>

<h3>Environmental effects</h3>

<p>What, if any, environmental side effects this function causes. 'None.' for none.</p>

<h3>Return Codes</h3>

<p>0 if the user is root</p>

<h3>Failure Scenarios</h3>

<p>Fails if the program user running is root.</p>

<h3>Usage Examples</h3>

<pre><code>user$ user_must_not_be_root
ERROR: bdsm test test must be run as a (project) user and NOT as a root.
</code></pre>

</td><td class=code><div class=highlight><pre>
user_must_not_be_root<span class="o">()</span>
<span class="o">{</span>
  user_is_not_root <span class="o">||</span>
    fail <span class="s2">&quot;bdsm $extension $action must be run as a (project) user and NOT as root.&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>user<em>run</em>as()</h2>

<p>Runs a command as a given user.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Any stream outputs of the command being run.</p>

<h3>Environmental effects</h3>

<p>Any environmental effects of the command being run.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if no user was specified.</p>

<h3>Usage Examples</h3>

<pre><code>root# user_run_as "user" pwd
/home/user
</code></pre>

</td><td class=code><div class=highlight><pre>
user_run_as<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_user</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span>

  <span class="o">[[</span> -n <span class="s2">&quot;${_user:-}&quot;</span> <span class="o">]]</span> <span class="o">||</span>
    fail <span class="s2">&quot;Cannot run as user as no user or commands were given.&quot;</span>
  <span class="nb">shift</span>

<span class="nb">  </span>su <span class="s2">&quot;${_user}&quot;</span> -c <span class="s2">&quot;$*&quot;</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>user<em>run</em>as_login()</h2>

<p>Runs a command as a given user, in that users login shell.</p>

<h3>Input Parameters</h3>

<p>None.</p>

<h3>Stream Outputs</h3>

<p>Any stream outputs of the command being run.</p>

<h3>Environmental effects</h3>

<p>Any environmental effects of the command being run.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if no user was specified.</p>

<h3>Usage Examples</h3>

<pre><code>root# user_run_as_login "deploy" bdsm unicorn restart
&lt;&lt; unicorn restart output &gt;&gt;
</code></pre>

</td><td class=code><div class=highlight><pre>
user_run_as_login<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_user</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span>

  <span class="o">[[</span> -n <span class="s2">&quot;${_user:-}&quot;</span> <span class="o">]]</span> <span class="o">||</span>
    fail <span class="s2">&quot;Cannot run as login user as no user or commands were given.&quot;</span>
  <span class="nb">shift</span>

<span class="nb">  </span>su - <span class="s2">&quot;${_user}&quot;</span> -c <span class="s2">&quot;$*&quot;</span>
<span class="o">}</span>


</td><td class=code><div class=highlight><pre>
</pre></div></td></tr><tr><td class=docs>

</pre></div></td></tr><tr><td class=docs>
</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs></td><td class='code'></td></tr>
    </tbody>
    </table>
</div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
    <meta http-eqiv='content-type' content='text/html;charset=utf-8'>
    <title>dsl</title>
    <link rel=stylesheet href="http://jashkenas.github.com/docco/resources/docco.css">
</head>
<body>
<div id=container>
    <div id=background></div>
    <table cellspacing=0 cellpadding=0>
    <thead>
      <tr>
        <th class=docs><h1>dsl</h1></th>
        <th class=code></th>
      </tr>
    </thead>
    <tbody>
        <tr><td class='docs'><h2>first()</h2>

<p>Returns the first parameter.</p>

<h3>Input Parameters</h3>

<p>One or more parameters.</p>

<h3>Stream Outputs</h3>

<p>Prints the first positional parameter to STDOUT of the calling environment.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if no parameters are passed.</p>

<h3>Usage Examples</h3>

<pre><code>user$ first one two three
one

user$ array=($(ls $HOME))
user$ first ${array[@]}
Desktop
</code></pre>

</td><td class=code><div class=highlight><pre>
<span class="c">#!/usr/bin/env bash</span>

first<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_array</span><span class="o">=(</span><span class="s2">&quot;$@&quot;</span><span class="o">)</span>

  <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">_array</span><span class="p">[@]</span><span class="k">}</span> &gt; 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    </span><span class="nb">printf</span> <span class="s2">&quot;%s&quot;</span> <span class="s2">&quot;${_array[0]}&quot;</span>
  <span class="k">else</span>
<span class="k">    </span>fail <span class="s2">&quot;No parameters given, cannot return the first one.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>last()</h2>

<p>Returns the last parameter.</p>

<h3>Input Parameters</h3>

<p>One or more parameters.</p>

<h3>Stream Outputs</h3>

<p>Prints the last positional parameter to STDOUT of the calling environment.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if no parameters are passed.</p>

<h3>Usage Examples</h3>

<pre><code>user$ last one two three
one

user$ array=($(ls $HOME))
user$ last ${array[@]}
tmp
</code></pre>

</td><td class=code><div class=highlight><pre>
last<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_array</span><span class="o">=(</span><span class="s2">&quot;$@&quot;</span><span class="o">)</span>

  <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">_array</span><span class="p">[@]</span><span class="k">}</span> &gt; 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    </span><span class="nb">printf</span> <span class="s2">&quot;%s&quot;</span> <span class="s2">&quot;${_array[$((${#_array[@]} - 1))]}&quot;</span>
  <span class="k">else</span>
<span class="k">    </span>fail <span class="s2">&quot;No parameters given, cannot return the last one.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>match()</h2>

<p>Tests to see if a value matches a given regex (shell extended glob pattern).</p>

<h3>Input Parameters</h3>

<p>Positional Parameter listing and descriptions.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 if the value matches the regex (shell extended glob pattern)
1 if the value does not match the regex (shell extended glob pattern)</p>

<h3>Failure Scenarios</h3>

<p>Fails if no value is given
Fails if no regex is given</p>

<h3>Usage Examples</h3>

<pre><code>user$ match "The quick brown fox jumped over the lazy dog." "*fox*"
user$ echo $?
0

user$ match "The quick brown fox jumped over the lazy dog." "*smurf*"
user$ echo $?
1
</code></pre>

</td><td class=code><div class=highlight><pre>
match<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_value</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_value}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    </span><span class="nb">shift</span>
<span class="nb">    local </span><span class="nv">_regex</span><span class="o">=</span><span class="s2">&quot;$1&quot;</span>
    <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_value}&quot;</span> <span class="o">]]</span>
    <span class="k">then</span>
<span class="k">      </span><span class="nb">shopt</span> -s extglob
      <span class="k">case</span> <span class="s2">&quot;${_value}&quot;</span> in
        <span class="o">(</span><span class="k">${</span><span class="nv">_regex</span><span class="k">}</span><span class="o">)</span>
          <span class="k">return </span>0
          ;;
        <span class="o">(</span>*<span class="o">)</span>
          <span class="k">return </span>1
          ;;
      <span class="k">esac</span>
<span class="k">    else</span>
<span class="k">      </span>fail <span class="s2">&quot;A regex must be specified in order to match ${_value} against it.&quot;</span>
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;A value and regex must be specified in order to match.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>variables<em>must</em>be_nonempty()</h2>

<p>Halts the program with a fail message if any of the named variables are empty
or undefined.</p>

<h3>Input Parameters</h3>

<p>One or more parameters specifying the names of variables.</p>

<h3>Stream Outputs</h3>

<p>None if all are</p>

<h3>Environmental effects</h3>

<p>What, if any, environmental side effects this function causes. 'None.' for none.</p>

<h3>Return Codes</h3>

<p>0 for success</p>

<h3>Failure Scenarios</h3>

<p>Fails if no varaible names were given.
Fails if any of the named variables are empty.</p>

<h3>Usage Examples</h3>

<pre><code>user$ cat test
#!/usr/bin/env bash
source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
modules trace variables # Load the trace module.
unset HOME
variables_must_be_nonempty HOME

user$ $PWD/test
ERROR: Required variable 'HOME' is not set.
ERROR: A command has returned an unhandled error code (nonzero return value).
Backtrace:
   Trace   Line Function             File
      3.     37 fail()               /usr/local/bdsm/modules/bash/logging/dsl
      2.    192 variables_must_be_nonempty() /usr/local/bdsm/modules/bash/variables/dsl
      1.      6 main()               /Users/wayneeseguin/test
 &gt; modules/bash/logging/dsl fail() 38 $ exit 1
</code></pre>

</td><td class=code><div class=highlight><pre>
variables_must_be_nonempty<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_variable <span class="nv">_variables</span><span class="o">=(</span><span class="s2">&quot;$@&quot;</span><span class="o">)</span>

  <span class="k">if</span> <span class="o">((</span> <span class="k">${#</span><span class="nv">_variables</span><span class="p">[@]</span><span class="k">}</span> &gt; 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    for </span>_variable in <span class="s2">&quot;${_variables}&quot;</span>
    <span class="k">do</span>
<span class="k">      if </span><span class="nb">eval</span> <span class="s2">&quot;[[ -n \&quot;\${${_variable}}\&quot; ]]&quot;</span>
      <span class="k">then</span>
<span class="k">        continue</span>
<span class="k">      else</span>
<span class="k">        </span>fail <span class="s2">&quot;Required variable &#39;$_variable&#39; is not set.&quot;</span>
      <span class="k">fi</span>
<span class="k">    done</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot ensure variables are nonempty as no variables were given.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>variable<em>is</em>nonempty()</h2>

<p>Test to see if a variable is empty.</p>

<h3>Input Parameters</h3>

<p>First parameter is a string containing a variable name.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Fails if no variable name was given as the first argument.</p>

<h3>Usage Examples</h3>

<pre><code>user$ variable_is_nonempty asdf
user$ echo $?
1

user$ asdf="w00t! "
user$ variable_is_nonempty asdf
user$ echo $?
0
</code></pre>

</td><td class=code><div class=highlight><pre>
variable_is_nonempty<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_variable</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_variable}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    if </span><span class="nb">eval</span> <span class="s2">&quot;[[ -n \&quot;\${${_variable}:-}\&quot; ]]&quot;</span>
    <span class="k">then</span>
<span class="k">      return </span>0
    <span class="k">else</span>
<span class="k">      return </span>1
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot check if variable is nonempty, no variable was given.&quot;</span>
  <span class="k">fi</span>

<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>variable<em>is</em>empty()</h2>

<p>Test to see if a variable is empty.</p>

<h3>Input Parameters</h3>

<p>First parameter is a string containing a variable name.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 for success.</p>

<h3>Failure Scenarios</h3>

<p>Fails if no variable name was given as the first argument.</p>

<h3>Usage Examples</h3>

<pre><code>user$ variable_is_empty asdf
user$ echo $?
1

user$ asdf="w00t! "
user$ variable_is_empty asdf
user$ echo $?
0
</code></pre>

</td><td class=code><div class=highlight><pre>
variable_is_empty<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span><span class="nv">_variable</span><span class="o">=</span><span class="s2">&quot;${1:-}&quot;</span>

  <span class="k">if</span> <span class="o">[[</span> -n <span class="s2">&quot;${_variable}&quot;</span> <span class="o">]]</span>
  <span class="k">then</span>
<span class="k">    if </span><span class="nb">eval</span> <span class="s2">&quot;[[ -z \&quot;\${${_variable}:-}\&quot; ]]&quot;</span>
    <span class="k">then</span>
<span class="k">      return </span>0
    <span class="k">else</span>
<span class="k">      return </span>1
    <span class="k">fi</span>
<span class="k">  else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot check if variable is empty as no variable was given.&quot;</span>
  <span class="k">fi</span>
<span class="o">}</span>

</pre></div></td></tr><tr><td class=docs>

<h2>variables<em>are</em>nonempty()</h2>

<p>Test to see if any of a given list of variables are empty.</p>

<h3>Input Parameters</h3>

<p>First parameter is a string containing a variable name.</p>

<h3>Stream Outputs</h3>

<p>None.</p>

<h3>Environmental effects</h3>

<p>None.</p>

<h3>Return Codes</h3>

<p>0 if all variables given are nonempty.
1 if any variable given is nonempty.</p>

<h3>Failure Scenarios</h3>

<p>Fails if no variable names were given as arguments.</p>

<h3>Usage Examples</h3>

<pre><code>user$ variables_are_nonempty BASH_VERSION asdf
user$ echo $?
1

user$ asdf="w00t! "
user$ variables_are_nonempty BASH_VERSION asdf
user$ echo $?
0
</code></pre>

</td><td class=code><div class=highlight><pre>
variables_are_nonempty<span class="o">()</span>
<span class="o">{</span>
  <span class="nb">local </span>_variable <span class="nv">_variables</span><span class="o">=(</span><span class="s2">&quot;$@&quot;</span><span class="o">)</span>

  <span class="k">if</span> <span class="o">((</span> <span class="s2">&quot;${#_variables[@]}&quot;</span> &gt; 0 <span class="o">))</span>
  <span class="k">then</span>
<span class="k">    for </span>_variable in <span class="s2">&quot;${_variables}&quot;</span>
    <span class="k">do</span>
<span class="k">      if </span><span class="nb">eval</span> <span class="s2">&quot;[[ -z \&quot;\${${_variable}:-}\&quot; ]]&quot;</span>
      <span class="k">then</span>
<span class="k">        return </span>1
      <span class="k">fi</span>
<span class="k">    done</span>
<span class="k">    return </span>0
  <span class="k">else</span>
<span class="k">    </span>fail <span class="s2">&quot;Cannot check if variables are nonempty as no variables were given.&quot;</span>
  <span class="k">fi</span>

<span class="o">}</span>



</td><td class=code><div class=highlight><pre>
</pre></div></td></tr><tr><td class=docs>

</pre></div></td></tr><tr><td class=docs>
</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs></td><td class='code'></td></tr>
    </tbody>
    </table>
</div>
</body>
</html>
<!DOCTYPE html>
<html>
<head>
    <meta http-eqiv='content-type' content='text/html;charset=utf-8'>
    <title>dsl</title>
    <link rel=stylesheet href="http://jashkenas.github.com/docco/resources/docco.css">
</head>
<body>
<div id=container>
    <div id=background></div>
    <table cellspacing=0 cellpadding=0>
    <thead>
      <tr>
        <th class=docs><h1>dsl</h1></th>
        <th class=code></th>
      </tr>
    </thead>
    <tbody>
        <tr><td class='docs'><p>TODO: Use git cli instead of awking it :)</p>

</td><td class=code><div class=highlight><pre>
<span class="c">#!/usr/bin/env bash</span>

scm_fetch<span class="o">()</span>
<span class="o">{</span>
<span class="nb">local </span><span class="nv">_url</span><span class="o">=</span><span class="s2">&quot;${1:-${extension_url:-}}&quot;</span>

<span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_url}&quot;</span> <span class="o">]]</span>
<span class="k">then</span>
fail <span class="s2">&quot;Cannot fetch an extension from a url as no url was given&quot;</span>
<span class="k">fi</span>

<span class="nb">local </span><span class="nv">_identifier</span><span class="o">=</span><span class="s2">&quot;${_url//\//_}&quot;</span> <span class="c"># Convert &#39;/&#39; to an invalid url component &#39;_&#39;</span>
<span class="nb">local </span><span class="nv">repo_path</span><span class="o">=</span><span class="s2">&quot;${repos_path}/${_identifier}&quot;</span>

ensure_paths_exist <span class="s2">&quot;${repos_path}&quot;</span>

<span class="k">case</span> <span class="s2">&quot;${_url}&quot;</span> in
*git*<span class="o">)</span>
<span class="k">if </span>directory_exists <span class="s2">&quot;${repo_path}/.git&quot;</span>
<span class="k">then</span>
<span class="nb">true</span> <span class="c"># already fetched!</span>
<span class="k">else</span>
<span class="k">if </span>directory_exists <span class="s2">&quot;${repo_path}&quot;</span>
<span class="k">then</span>
remove_paths <span class="s2">&quot;${repo_path}&quot;</span>
<span class="k">fi</span>

<span class="k">if</span> ! git clone --depth 1 <span class="k">${</span><span class="nv">_url</span><span class="k">}</span> <span class="s2">&quot;${repo_path}&quot;</span>
<span class="k">then</span>
error <span class="s2">&quot;There was an error while cloning the repository from the url &#39;${_url}&#39;&quot;</span>
<span class="k">fi</span>
<span class="k">fi</span>
;;
*svn*<span class="o">)</span>
NIY
;;
*hg*<span class="o">)</span>
NIY
;;
*fossil*<span class="o">)</span>
NIY
;;
*<span class="o">)</span>
;;
<span class="k">esac</span>
<span class="o">}</span>

scm_update<span class="o">()</span>
<span class="o">{</span>
<span class="nb">local </span><span class="nv">_url</span><span class="o">=</span><span class="s2">&quot;${1:-${extension_url:-}}&quot;</span>

<span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;${_url}&quot;</span> <span class="o">]]</span>
<span class="k">then</span>
fail <span class="s2">&quot;Cannot fetch an extension from a url as no url was given&quot;</span>
<span class="k">fi</span>

<span class="nb">local </span><span class="nv">_identifier</span><span class="o">=</span><span class="s2">&quot;${_url//\//_}&quot;</span> <span class="c"># Convert &#39;/&#39; to an invalid url component &#39;_&#39;</span>
<span class="nb">local </span><span class="nv">repo_path</span><span class="o">=</span><span class="s2">&quot;${repos_path}/${_identifier}&quot;</span>

<span class="k">case</span> <span class="s2">&quot;${_url}&quot;</span> in
*git*<span class="o">)</span>
<span class="k">if</span> <span class="o">[[</span> -z <span class="s2">&quot;$(git branch | awk &quot;</span>/<span class="k">${</span><span class="nv">branch</span><span class="p">:=master</span><span class="k">}</span><span class="nv">$/</span><span class="s2">&quot;)&quot;</span> <span class="o">]]</span>
      <span class="k">then</span>
<span class="k">        if</span> ! <span class="o">(</span> <span class="nb">builtin cd</span>  <span class="s2">&quot;${repo_path}&quot;</span>;
          git checkout -b <span class="s2">&quot;$branch&quot;</span> --track <span class="s2">&quot;$remote/$branch&quot;</span> 2&gt;/dev/null <span class="o">)</span>
        <span class="k">then</span>
<span class="k">          </span>error <span class="s2">&quot;$remote $branch remote branch not found. Halting.&quot;</span>
        <span class="k">fi</span>

<span class="k">      elif</span> <span class="o">[[</span> -z <span class="s2">&quot;$(git branch | awk &quot;</span>/<span class="se">\*</span> <span class="nv">$branch$/</span><span class="o">{</span>print <span class="se">\$</span>2<span class="o">}</span><span class="s2">&quot;)&quot;</span> <span class="o">]]</span>
      <span class="k">then</span>
<span class="k">        if</span> ! <span class="o">(</span> <span class="nb">builtin cd</span> <span class="s2">&quot;${repo_path}&quot;</span>;
          git checkout <span class="nv">$branch</span> 2&gt;/dev/null<span class="o">)</span>
        <span class="k">then</span>
<span class="k">          </span>error <span class="s2">&quot;Unable to checkout $branch.\nCould not get head. Halting.&quot;</span>
        <span class="k">fi</span>
<span class="k">      fi</span>

<span class="k">      if</span> ! <span class="o">(</span> <span class="nb">builtin cd</span> <span class="s2">&quot;${repo_path}&quot;</span> ;
        git pull --rebase origin <span class="nv">$branch</span> <span class="o">)</span>
      <span class="k">then</span>
<span class="k">        </span>error <span class="s2">&quot;Git pull failed. Halting.&quot;</span>
      <span class="k">fi</span>
      ;;
    *svn*<span class="o">)</span>
      NIY <span class="s2">&quot;Subversion scm_update&quot;</span>
      ;;
    *hg*<span class="o">)</span>
      NIY <span class="s2">&quot;hg scm_update&quot;</span>
      ;;
    *fossil*<span class="o">)</span>
      NIY <span class="s2">&quot;fossil scm_update&quot;</span>
      ;;
    *<span class="o">)</span>
      error <span class="s2">&quot;Unknownn SCM for url &#39;${_url}&#39;&quot;</span>
      ;;
  <span class="k">esac</span>
<span class="o">}</span>



</td><td class=code><div class=highlight><pre>
</pre></div></td></tr><tr><td class=docs>

</pre></div></td></tr><tr><td class=docs>
</td><td class=code><div class=highlight><pre>

</pre></div></td></tr><tr><td class=docs></td><td class='code'></td></tr>
    </tbody>
    </table>
</div>
</body>
</html>
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h1 Array Module
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
          %tr
            %td.docs
              %h2
                array
                %em> is
                nonempty()
              %p
                Checks to see if an array with the name given as the first parameter
                is nonempty.
              %h3 Input Parameters
              %p The first parameter is the name of the array variable.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p
                0 if the array is non-empty.
                1 if the array is empty.
              %h3 Failure Scenarios
              %p Fails if the array name, the first parameter, is not given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ the_array=(1 2 3 4 5)
                    user$ array_is_nonempty the_array
                    user$ echo $?
                    0
                    
                    user$ the_array=()
                    user$ array_is_nonempty the_array
                    user$ echo $?
                    1
            %td.code
              .highlight
                %pre
                  array_is_nonempty
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb eval
                  %span.s2 &quot;(( \${#${_array_name}[@]} &gt; 0 ))&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot push onto array as an array name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                array
                %em> is
                empty()
              %p Checks to see if an array with the name given as the first parameter is empty.
              %h3 Input Parameters
              %p The first parameter is the name of the array variable.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p
                0 if the array is empty.
                1 if the array is non-empty.
              %h3 Failure Scenarios
              %p Fails if the array name, the first parameter, is not given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ the_array=()
                    user$ array_is_empty the_array
                    user$ echo $?
                    0
                    
                    user$ the_array=(1 2 3 4 5)
                    user$ array_is_empty the_array
                    user$ echo $?
                    1
            %td.code
              .highlight
                %pre
                  array_is_empty
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb eval
                  %span.s2 &quot;(( \${#${_array_name}[@]} == 0 ))&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot push onto array as an array name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 array_length()
              %p Return the length of the given array.
              %h3 Input Parameters
              %p First parameter is the name of the array variable.
              %h3 Stream Outputs
              %p
                Prints the length of the named array to the STDOUT stream of the calling
                environment.
              %h3 Return Codes
              %p returns 0
              %h3 Failure Scenarios
              %p Fails if the array name, first parameter, is not given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ the_array=(1 2 3 4 5)
                    user$ array_length the_array
                    5
            %td.code
              .highlight
                %pre
                  array_length
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb eval
                  %span.s2 &quot;printf \&quot;%s\\n\&quot; \&quot;\${#${_array_name}[@]}\&quot;&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot push onto array as an array name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                array
                %em> last
                element()
              %p Print the last element of the given array.
              %h3 Input Parameters
              %p First parameter is the name of the array variable.
              %h3 Stream Outputs
              %p
                Prints the last element of the named array to the STDOUT stream of the
                calling environment.
              %h3 Failure Scenarios
              %p Fails if the array name, first parameter, is not given.
              %h3 Return Codes
              %p 0 denoting success
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    $ the_array=(one two three four five)
                    $ array_last_element the_array
                    five
            %td.code
              .highlight
                %pre
                  array_last_element
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  _length
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb eval
                  %span.s2 &quot;_length=\${#${_array_name}[@]}&quot;
                  %span.nb eval
                  %span.s2 &quot;printf \&quot;%s\\n\&quot; \&quot;\${${_array_name}[${_length}]}\&quot;&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot push onto array as an array name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                array
                %em> first
                element()
              %p Print the first element of the given array.
              %h3 Input Parameters
              %p First parameter is the name of the array variable.
              %h3 Stream Outputs
              %p
                Prints the first element of the named array to the STDOUT stream of the
                calling environment.
              %h3 Return Codes
              %p 0 denoting success
              %h3 Failure Scenarios
              %p Fails if the array name, the first parameter, is not given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    $ the_array=(one two three four five)
                    $ array_first_element the_array
                    one
            %td.code
              .highlight
                %pre
                  array_first_element
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  _length
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb eval
                  %span.s2 &quot;printf \&quot;%s\\n\&quot; \&quot;\${${_array_name}[0]}\&quot;&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot push onto array as an array name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 array_push()
              %p Appends one or more elements to the array with the given name.
              %h3 Input Parameters
              %p
                The first parameter is the name of the array variable.
                Remaining parameters are the elements to be appended to the array.
              %h3 Stream Outputs
              %p None.
              %h3 Returns
              %p 0 denoting success
              %h3 Failure Scenarios
              %p
                Fails if the array name, the first parameter, is not given.
                Fails if no elements were given (second paramater and beyond).
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    $ the_array=(1 2 3 4 5)
                    $ array_push the_array 6
                    $ array_join the_array # print the contents of the array, space separated
                    1 2 3 4 5 6
            %td.code
              .highlight
                %pre
                  array_push
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  %span.nb                   = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb eval
                  %span.s2 &quot;(( \${#${_array_name}[@]} &gt; 0 ))&quot;
                  = succeed "_element" do
                    %span.nb local
                  %span.nv _elements
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _elements
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot push elements onto array as no elements were given.&quot;
                  %span.k fi
                  = succeed "_element" do
                    %span.k for
                  in
                  %span.s2 &quot;${_elements[@]}&quot;
                  %span.k do
                  %span.k                   %span.nb eval
                  %span.s2 &quot;${_array_name}+=(\${_element})&quot;
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot push elements onto array as an array name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 array_append()
              %p Return the length of the given array.
              %h3 Input Parameters
              %p
                The first parameter is the name of the array variable.
                Remaining parameters are the elements to append to the end of the array.
              %h3 Stream Outputs
              %p None.
              %h3 Returns
              %p 0 denoting success
              %h3 Failure Scenarios
              %p
                Fails if the array name, the first parameter, is not given.
                Fails if no elements were given to append to the array.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ the_array=(1)
                    user$ array_append the_array 2 3 4 5
                    user$ array_join the_array # print the contents of the array,
                    space separated.
                    1 2 3 4 5
            %td.code
              .highlight
                %pre
                  array_append
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb shift
                  = succeed "_element" do
                    %span.nb local
                  %span.nv _elements
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _elements
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot push elements onto array as no elements were given.&quot;
                  %span.k fi
                  = succeed "_element" do
                    %span.k for
                  in
                  %span.s2 &quot;${_elements[@]}&quot;
                  %span.k do
                  %span.k                   %span.nb eval
                  %span.s2 &quot;${_array_name}+=(\${_element})}&quot;
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot push onto array as an array name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 array_shift()
              %p Removes the first element of the array and prints it.
              %h3 Input Parameters
              %p The first parameter is the name of the array variable.
              %h3 Stream Outputs
              %p
                Prints the first element of the named array to the STDOUT stream of the
                calling environment.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat $HOME/test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework.
                    modules array
                    
                    my_array=(1 2 3 4)
                    echo ${my_array[@]}
                    array_shift my_array
                    echo ${my_array[@]}
                    
                    user$ $HOME/test
                    1 2 3 4
                    1
                    2 3 4
            %td.code
              .highlight
                %pre
                  array_shift
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nv new_array
                  %span.o =()
                  index first_element
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb eval
                  %span.s2 &quot;
                  %span.s2 first_element=\${${_array_name}[0]}
                  %span.s2 for (( index=1; index &lt; \${#${_array_name}[@]}; index++ ))
                  %span.s2 do
                  %span.s2 new_array+=(\${${_array_name}[\${index}]})
                  %span.s2 done
                  %span.s2 ${_array_name}=(\&quot;\${new_array[@]}\&quot;)
                  %span.s2 &quot;
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;${first_element}&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot shift from array as an array name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 array_unshift()
              %p
                Prepends one or more elements to the array whose name is given, in the order
                given.
              %h3 Input Parameters Parameters
              %p
                The first parameter is the name of the array variable.
                Remaining parameters are the elements to prepend to the array.
              %h3 Stream Outputs
              %p
                None.
                Yields a failure message if no array name was given.
                Yields a failure message if no elements were given to unshift.
              %h3 Return Codes
              %p 0 denoting success
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    $ the_array=(2 3 4 5)
                    $ array_unshift 1
                    user$ array_join the_array # print contents of the array, space separated.
                    1 2 3 4 5
                    
                    $ the_array=(4 5)
                    $ array_unshift 3 2 1
                    user$ array_join the_array # print contents of the array, space separated.
                    1 2 3 4 5
            %td.code
              .highlight
                %pre
                  array_unshift
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb shift
                  = succeed "_element" do
                    %span.nb local
                  %span.nv _elements
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _elements
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot push elements onto array as no elements were given.&quot;
                  %span.k fi
                  = succeed "_element" do
                    %span.k for
                  in
                  %span.s2 &quot;${_elements[@]}&quot;
                  %span.k do
                  %span.k                   %span.nb eval
                  %span.s2 &quot;${_array_name}=(\&quot;${_element}\&quot; \&quot;\${${_array_name}[@]}\&quot;)&quot;
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot push onto array as an array name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 array_join()
              %p
                Joins the named array into a string separated by either a space or
                a given string.
              %h3 Input Parameters
              %p
                The first parameter is the name of the array variable.
                The second parameter is the separator between elements in the string, this is
                optional and defaults to a space.
              %h3 Stream Outputs
              %p
                Prints the elements of the named array, separated by either the 2nd parameter
                if given or else a space character, to the STDOUT stream of the calling
                environment.
              %h3 Return Codes
              %p 0 denoting success
              %h3 Failure Scenarios
              %p Fails if the array name, the first parameter, is not given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    $ the_array=(1 2 3 4 5)
                    $ array_join the_array
                    1 2 3 4 5
                    
                    $ array_join the_array '.'
                    1.2.3.4.5
            %td.code
              .highlight
                %pre
                  array_join
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb local
                  %span.nv _separator
                  %span.o =
                  %span.s2 &quot;${1:-' '}&quot;
                  %span.nb eval
                  %span.s2 &quot;
                  %span.s2 for (( index=0 ; index &lt; \${#${_array_name}[@]} ; index++ )) ;
                  %span.s2 do (( index &gt;  0 )) &amp;&amp; printf \&quot;%s\&quot;${_separator}\&quot;\&quot; ;
                  %span.s2 printf \&quot;%s\&quot; \&quot;\${${_array_name}[\${index}]}\&quot; ;
                  %span.s2 done&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot join array as an array name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 array_largest()
              %p Outputs the first string in the array with the largest length.
              %h3 Input Parameters
              %p The first element is an array variable name.
              %h3 Stream Outputs
              %p
                Prints the largest elements of the named array to the STDOUT
                stream of the calling environment.
              %h3 Return Codes
              %p 0 denoting success
              %h3 Failure Scenarios
              %p Fails if the array name, the first parameter, is not given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    $ the_array=(billie bob joe)
                    $ array_largest the_array
                    billie
            %td.code
              .highlight
                %pre
                  array_largest
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _index
                  %span.nv _largest
                  %span.o =
                  %span.s2 &quot;&quot;
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb eval
                  %span.s2 &quot;
                  %span.s2 for (( _index=0 ; _index &lt; \${#${_array_name}[@]} ; _index++ ))
                  %span.s2 do
                  %span.s2 if (( \${#${_array_name}[\${_index}]} &gt; \${#_largest} ))
                  %span.s2 then
                  %span.s2 _largest=\${${_array_name}[\${_index}]}
                  %span.s2 fi
                  %span.s2 done
                  %span.s2 &quot;
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;${_largest}&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot find largest element as an array variable name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                array
                %em> sort
                desc()
              %p Sorts the named array contents in descending order.
              %h3 Input Parameters
              %p An array variable name.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 denoting success
              %h3 Failure Scenarios
              %p Fails if the array name, the first parameter, is not given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat $HOME/test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # BDSM framework
                    modules array
                    
                    arr=(c a d e f b h j i )
                    array_sort_desc arr
                    array_join arr
                    echo
                    
                    user$ $HOME/test
                    j i h f e d c b a
            %td.code
              .highlight
                %pre
                  array_sort_desc
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _index
                  %span.nv _largest
                  %span.o =
                  %span.s2 &quot;&quot;
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb eval
                  %span.s2 &quot;${_array_name}=(\$(
                  %span.s2 echo \&quot;\${${_array_name}[@]}\&quot; | tr ' ' \&quot;\n\&quot; | sort -r
                  %span.s2 ))&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot sort an array in decending order as an array&quot;
                  %span.se \
                  %span.s2 &quot;variable name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                array
                %em> sort
                asc()
              %p Sorts the named array contents in ascending order.
              %h3 Input Parameters
              %p An array variable name.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 denoting success
              %h3 Failure Scenarios
              %p Fails if the array name, the first parameter, is not given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat $HOME/test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # BDSM framework
                    modules array
                    
                    arr=(c a d e f b h j i )
                    array_sort_asc arr
                    array_join arr
                    echo
                    
                    user$ $HOME/test
                    a b c d e f h i j
            %td.code
              .highlight
                %pre
                  array_sort_asc
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _index
                  %span.nv _largest
                  %span.o =
                  %span.s2 &quot;&quot;
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb eval
                  %span.s2 &quot;${_array_name}=(\$(
                  %span.s2 echo \&quot;\${${_array_name}[@]}\&quot; | tr ' ' \&quot;\n\&quot; | sort
                  %span.s2 ))&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot sort an array in ascending order as an array &quot;
                  %span.se \
                  %span.s2 &quot;variable name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 array_unique()
              %p Sorts the named array contents in ascending order.
              %h3 Input Parameters
              %p An array variable name.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 denoting success
              %h3 Failure Scenarios
              %p Fails if the array name, the first parameter, is not given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat $HOME/test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # BDSM framework
                    modules array
                    
                    arr=(a a a b b c c c c d d d d d d)
                    array_unique arr
                    array_join arr
                    echo
                    
                    user$ $HOME/test
                    a b c d
            %td.code
              .highlight
                %pre
                  array_unique
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _index
                  %span.nv _largest
                  %span.o =
                  %span.s2 &quot;&quot;
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb eval
                  %span.s2 &quot;${_array_name}=(\$(
                  %span.s2 echo \&quot; \${${_array_name}[@]} \&quot; | awk -v RS=' ' -v ORS=' ' '!(\$0 in a){a[\$0];print}'
                  %span.s2 ))&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot sort an array in ascending order as an array &quot;
                  %span.se \
                  %span.s2 &quot;variable name was not given.&quot;
                  %span.k fi
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 bdsm_exports()
              %p
                Exports bdsm framework relevant environment variables for extension action
                processes.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ bdsm_exports
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  bdsm_exports
                  %span.o ()
                  %span.o {
                  %span.c # TODO: Filter this list of exports down.
                  = succeed "action" do
                    %span.nb export
                  archives_path bdsm_path branch config_path database database_name debug_flag environment error_message extension extension_action extension_args extension_bin_path extension_config_path extension_modules_path extension_path extension_templates_path extensions_path flags framework head_flag hooks_flag keep_releases modules_path old_releases parse_break paths prefix_path previous_path project project_path release_path remote repository result revision shared_path src_path templates_path timestamp tmp_path trace_flag user extension_log_path
                  %span.o }
          %tr
            %td.docs
              %h2 bdsm_version()
              %p Reads the currently installed bdsm version into the variable 'bdsm_version'.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p The variable 'bdsm_version' will be set after the function is executed.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ bdsm_version
                    user$ echo $bdsm_version
                    69.69.69
            %td.code
              .highlight
                %pre
                  bdsm_version
                  %span.o ()
                  %span.o {
                  = succeed "file_is_nonempty" do
                    %span.k if
                  %span.s2 &quot;$bdsm_path/VERSION&quot;
                  %span.k then
                  %span.k                   %span.nb read
                  \-r bdsm_version &lt;
                  %span.s2 &quot;$bdsm_path/VERSION&quot;
                  %span.k else
                  %span.k                   %span.nv bdsm_version
                  %span.o =
                  %span.s2 &quot;?.?.?&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 NIY()
              %p
                Prints a failure message and backtrace to the screen letting the caller know
                that the requested feature has not yet been implemented.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                Prints "This feature has not yet been implemented." to STDERR of the calling
                environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p None, only exit is through failure.
              %h3 Failure Scenarios
              %p Fails always.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat $HOME/test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    NIY
                    
                    user$ $HOME/test
                    ERROR: This feature has not yet been implemented.
                    Backtrace:
                       Trace   Line Function             File
                          3.    262 fail()               /usr/local/bdsm/modules/bash/logging/dsl
                          2.      5 NIY()                /usr/local/bdsm/modules/bash/extensions/dsl
                          1.      5 main()               /Users/wayneeseguin/test
                     &gt; modules/bash/logging/dsl fail() 263 $ exit 1
            %td.code
              .highlight
                %pre
                  NIY
                  %span.o ()
                  %span.o {
                  fail
                  %span.s2 &quot;This feature has not yet been implemented.\n${*:-}&quot;
                  %span.o }
          %tr
            %td.docs
              %p Allow for method_missing when a command is not found during lookup.
            %td.code
              .highlight
                %pre
                  %span.k if
                  %span.o ((
                  %span.k ${
                  %span.nv BASH_VERSINFO
                  %span.p [0]
                  %span.k }
                  \&gt; 3
                  %span.o ))
                  %span.k then
                  = succeed "command_not_found" do
                    %span.k                   %span.o ()
                  %span.o {
                  %span.nb echo
                  %span.s2 &quot;bash: $1: command not found ($*)&quot;
                  \&gt;&amp;2
                  = succeed "127" do
                    %span.k return
                  %span.o }
                  command_not_found_handle
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${MC_SID}&quot;
                  %span.o ||
                  \! -t 1
                  %span.o ]]
                  %span.k then
                  %span.c # do not run when inside Midnight Commander or within a Pipe
                  command_not_found
                  %span.s2 &quot;$@&quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  %span.nv $MACHTYPE
                  %span.o =
                  *linux*
                  %span.o ]]
                  %span.k then
                  %span.c # do not run when within a subshell, Linux version.
                  = succeed "cmd" do
                    %span.nb local
                  state remainder
                  %span.nb local
                  \-i pid ppid pgrp session tty_nr tpgid
                  = succeed "pid" do
                    %span.nb read
                  cmd state ppid pgrp session tty_nr tpgid remainder &lt; /proc/self/stat
                  %span.k if
                  %span.o ((
                  %span.nv $$
                  %span.o ==
                  %span.k ${
                  %span.nv tpgid
                  %span.k }
                  %span.o ))
                  %span.k then
                  = succeed "command_not_found" do
                    %span.k                   %span.s2 &quot;$@&quot;
                  %span.k fi
                  %span.k fi
                  %span.k if
                  %span.nb command
                  \-v method_missing
                  %span.k then
                  %span.c # Pass to method_missing.
                  method_missing
                  %span.s2 &quot;$@&quot;
                  %span.k else
                  %span.c # Default behavior.
                  command_not_found
                  %span.s2 &quot;$@&quot;
                  %span.k fi
                  %span.o }
                  %span.k fi
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 read_default()
              %p Reads default values from an extension's config/defaults file.
              %h3 Input Parameters
              %p
                First parameter is the defaults file key to read (key=value).
                Second parameter is the variable name to store the retrieved value in.
                Remaining parameters are parsed out as token, value and prefix
                into|as
                %variable{:name => ""}
                  prefix
                  %name
                    %variable # If no specifier.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                A variable will be set to the value, if the value is nonempty. If no variable
                name is specified the variable will be assigned the same name as the key.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Fails if no arguments are passed in, at least need to specify a key.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ read_default "version" prefix "package" # extension is nginx for example
                    user$ echo $package_version
                    1.0.0
              %h3 Notes
              %p read_default respects a tiered default file scheme,
              %p
                "/etc/bdsm/${extension}/defaults"
                "$HOME/.bdsm/${extension}/defaults"
                "${extension
                %em> config
                path}/defaults"
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  read_default
                  %span.o ()
                  %span.o {
                  = succeed "key" do
                    %span.nb local
                  variable token value prefix _file _files _temp
                  %span.nv key
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${key}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;$extension $action read_default() no arguments passed! &quot;
                  %span.k else
                  %span.k                   %span.nb shift
                  %span.nb                   %span.k fi
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;$token&quot;
                  in
                  into|as
                  %span.o )
                  %span.nv variable
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  ;;
                  prefix
                  %span.o )
                  %span.nv prefix
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  ;;
                  *
                  %span.o )
                  %span.nv variable
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.nb break
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${variable:-}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${prefix:-}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb true
                  %span.s2 &quot;${variable:=&quot;
                  %span.k ${
                  %span.nv prefix
                  = succeed "_" do
                    %span.k :-}
                  %span.nv $key
                  %span.s2 &quot;}&quot;
                  %span.k else
                  %span.k                   %span.nb true
                  %span.s2 &quot;${variable:=&quot;
                  %span.nv $key
                  %span.s2 &quot;}&quot;
                  %span.k fi
                  %span.k fi
                  %span.k                   %span.nv _files
                  %span.o =(
                  %span.s2 &quot;/etc/bdsm/${extension}/defaults&quot;
                  %span.s2 &quot;$HOME/.bdsm/${extension}/defaults&quot;
                  %span.s2 &quot;${extension_config_path}/defaults&quot;
                  %span.o )
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  = succeed "file_is_nonempty" do
                    %span.k if
                  %span.s2 &quot;${_file}&quot;
                  %span.k then
                  %span.k                   %span.nv _temp
                  %span.o =
                  %span.s2 &quot;$(hash_file &quot;
                  %span.k ${
                  %span.nv _file
                  %span.k }
                  %span.s2 &quot; &quot;
                  %span.k ${
                  %span.nv key
                  %span.k }
                  %span.s2 &quot;)&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_temp}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv value
                  %span.o =
                  %span.s2 &quot;${_temp}&quot;
                  %span.k fi
                  %span.k fi
                  %span.k done
                  %span.k                   %span.nb eval
                  %span.s2 &quot;${variable}=\&quot;${value}\&quot;&quot;
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 command_exists()
              %p Checks to see whether a command exists within the current environment and PATH
              %h3 Input Parameters
              %p First parameter is a command name.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p none.
              %h3 return codes
              %p
                0 if the command was found in the current environment
                1 if the command was not found in the current environment
              %h3 failure scenarios
              %p Fails if no command name was given.
              %h3 usage examples
              %pre
                %code
                  :preserve
                    user$ command_exists adsf
                    user$ echo $?
                    1
                    
                    user$ command_exists ls
                    user$ echo $?
                    0
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  command_exists
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _name
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_name}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.nb command
                  \-v
                  %span.s2 &quot;${_name}&quot;
                  \&gt; /dev/null 2&gt;&amp;1
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot test if command exists as no command name was given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                is
                %em> a
                function()
              %p Checks to see whether a named function exists within the current environment
              %h3 Input Parameters
              %p First parameter is a function name.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p none.
              %h3 return codes
              %p
                0 if the function exists
                1 if the function does not exist
              %h3 failure scenarios
              %p Fails if no function name was given.
              %h3 usage examples
              %pre
                %code
                  :preserve
                    user$ is_a_function rvm
                    user$ echo $?
                    0
                    
                    user$ is_a_function asdf
                    user$ echo $?
                    1
                    
                    user$ is_a_function ls
                    user$ echo $?
                    1
            %td.code
              .highlight
                %pre
                  is_a_function
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _name
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_name}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.nb declare
                  \-f
                  %span.s2 &quot;${_name}&quot;
                  \&gt;/dev/null 2&gt;&amp;1
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot test if function exists as no function name was given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                shell
                %em> is
                interactive()
              %p Checks if the currently running shell is interactive (user controlled).
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p none.
              %h3 return codes
              %p
                0 if the shell is interactive (user controlled)
                1 if the shell is not interactive
              %h3 failure scenarios
              %p None currently.
              %h3 usage examples
              %p user$ cat $HOME/test
              %h1 !/usr/bin/env bash
              %p
                source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                modules environment # Load the trace module.
              %p
                if shell
                %em> is
                interactive
                then
                echo "Shell is Interactive! "
                else
                echo "Shell is Not Interactive! "
                fi
              %p
                user$ "$HOME/test"
                Shell is Not Interactive!
              %p
                user$ source "$HOME/test"
                Shell is Interactive!
            %td.code
              .highlight
                %pre
                  shell_is_interactive
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;$-&quot;
                  %span.o =
                  *i*
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 extension_action()
              %p
                Load the environment for a given extension action and then call it.
                This is the main function for BDSM.
              %h3 Input Parameters
              %p One or more extension names.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                The current extension's initialize file will be resourced into the current
                environment.
              %h3 Return Codes
              %p
                0 for success
                1 for failure
              %h3 Failure Scenarios
              %p
                Fails if no extension was given.
                Fails if no action was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    $ cat $HOME/test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules extensions
                    extension_action ext list
                    
                    $  $HOME/test
                    bash fossil git libevent nginx p7zip postgresql rails redis srv tig tmux zeromq zlib
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  extension_action
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv result
                  = succeed "0" do
                    %span.o =
                  = succeed "extension" do
                    %span.nb unset
                  action
                  %span.nb export
                  %span.nv extension
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${extension}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;'extension' is not set! Something has gone terribly wrong.&quot;
                  %span.k fi
                  %span.k                   %span.nb shift
                  %span.nb export
                  %span.nv action
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${action}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;'action' is not set! Something has gone terribly wrong.&quot;
                  %span.k fi
                  %span.k                   %span.nb shift
                  %span.nb                   %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv extension_args
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nv extension_args
                  %span.o =
                  %span.s2 &quot;$@&quot;
                  %span.k fi
                  %span.k                   = succeed "extension_args" do
                    %span.nb export
                  %span.nv extension_path
                  %span.o =
                  %span.s2 &quot;$extensions_path/$extension&quot;
                  %span.nv extension_config_path
                  %span.o =
                  %span.s2 &quot;$extensions_path/$extension/config&quot;
                  %span.nv extension_templates_path
                  %span.o =
                  %span.s2 &quot;$extensions_path/$extension/templates&quot;
                  %span.nv extension_modules_path
                  %span.o =
                  %span.s2 &quot;$extensions_path/$extension/modules&quot;
                  %span.nv extension_bin_path
                  %span.o =
                  %span.s2 &quot;$extensions_path/$extension/bin&quot;
                  %span.nv extension_log_path
                  %span.o =
                  %span.s2 &quot;$log_path/$extension&quot;
                  %span.nv paths
                  %span.o =
                  = succeed "env" do
                    %span.k $(
                  | awk -F
                  %span.o =
                  \-v
                  %span.nv ORS
                  %span.o =
                  %span.s1 ' '
                  %span.s1 '/_path/{print $1}'
                  %span.k )
                  %span.nv flags
                  %span.o =
                  = succeed "env" do
                    %span.k $(
                  | awk -F
                  %span.o =
                  \-v
                  %span.nv ORS
                  %span.o =
                  %span.s1 ' '
                  %span.s1 '/_flag/{print $1}'
                  %span.k )
                  enter
                  %span.s2 &quot;${extension_path}&quot;
                  %span.o ||
                  fail
                  %span.s2 &quot;Could not enter the extension directory!\n    (${extension_path})&quot;
                  bdsm_exports
                  %span.nv action_file
                  %span.o =
                  %span.s2 &quot;${extension_path}/bin/${action}&quot;
                  file_exists
                  %span.s2 &quot;${action_file}&quot;
                  %span.o ||
                  fail
                  %span.s2 &quot;Action binary/file ${action} missing for extension ${extension}\n    (${action_file})&quot;
                  %span.nv action_file_type
                  %span.o =
                  %span.s2 &quot;$(file &quot;
                  %span.nv $action_file
                  %span.s2 &quot;)&quot;
                  %span.k case
                  %span.s2 &quot;${action_file_type}&quot;
                  in
                  
                  *sh
                  %span.o> [[
                  \:space:
                  %span.o> ]]
                  script*|*POSIX
                  %span.o> [[
                  \:space:
                  %span.o> ]]
                  shell*|*Bourne-Again*
                  %span.o )
                  %span.nv action_type
                  %span.o =
                  %span.s2 &quot;bash&quot;
                  ;;
                  
                  *ASCII*
                  %span.o )
          %tr
            %td.docs
              %p Launch with helper dsl, if possible.
            %td.code
              .highlight
                %pre
                  %span.nv extension
                  %span.o =
                  %span.s2 &quot;${action_file//.}&quot;
                  %span.k case
                  %span.s2 &quot;${extension}&quot;
                  in
                  bash|sh
                  %span.o )
                  %span.nv action_type
                  %span.o =
                  %span.s2 &quot;bash&quot;
                  %span.c #rb) action_type=&quot;ruby&quot;   ;;
                  ;;
                  *
                  %span.o )
                  %span.nb read
                  \-r shebang &lt;
                  %span.s2 &quot;${action_file}&quot;
                  %span.k case
                  %span.s2 &quot;${shebang}&quot;
                  in
                  *ruby|*rbx|*jruby|*macruby
                  %span.o )
                  %span.nv binary
                  %span.o =
                  %span.s2 &quot;${shebang##*(#|!)}&quot;
                  %span.nv binary
                  %span.o =
                  %span.s2 &quot;${binary##* }&quot;
                  %span.nv action_type
                  %span.o =
                  %span.s2 &quot;ruby&quot;
                  ;;
                  *
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-x
                  %span.s2 &quot;${action_file}&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  %span.k                   %span.nv action_type
                  %span.o =
                  %span.s2 &quot;binary&quot;
                  %span.k else
                  %span.k                   %span.nv action_type
                  %span.o =
                  %span.s2 &quot;not executable&quot;
                  %span.k fi
                  ;;
                  %span.k esac
                  ;;
                  %span.k esac
                  %span.k                   %span.nv result
                  %span.o =
                  %span.nv $?
                  ;;
                  
                  cannot
                  %span.o> [[
                  \:space:
                  %span.o> ]]
                  open
                  %span.o )
                  %span.nv action_type
                  %span.o =
                  %span.s2 &quot;dne&quot;
                  ;;
                  
                  *
                  %span.o )
                  = succeed "file_is_executable" do
                    %span.k if
                  %span.s2 &quot;${action_file}&quot;
                  ;
                  %span.k then
                  %span.k                   %span.nv action_type
                  %span.o =
                  %span.s2 &quot;binary&quot;
                  %span.k else
                  %span.k                   %span.nv action_type
                  %span.o =
                  %span.s2 &quot;noexec&quot;
                  %span.k fi
                  ;;
                  %span.k esac
                  %span.o ||
                  %span.nv result
                  %span.o =
                  %span.nv $?
          %tr
            %td.docs
              %p Now based on the determined action_type we launch the extension.
            %td.code
              .highlight
                %pre
                  %span.k case
                  %span.s2 &quot;${action_type}&quot;
                  in
                  bash
                  %span.o )
                  %span.o (
                  enable_backtrace
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;${action}&quot;
                  %span.o =
                  %span.s2 &quot;help&quot;
                  %span.o ]]
                  %span.k then
                  %span.c # Load the help module also.
                  modules core
                  %span.nb help
                  %span.nb                   %span.k else
                  = succeed "modules" do
                    %span.k                   core
                  %span.k fi
                  = succeed "source_files" do
                    %span.k                   %span.se \
                  %span.s2 &quot;${extension_modules_path}/bash/dsl&quot;
                  %span.se \
                  %span.s2 &quot;${extension_modules_path}/bash/initialize&quot;
                  %span.se \
                  %span.s2 &quot;${extension_modules_path}/bash/cli&quot;
                  \.
                  %span.s2 &quot;${action_file}&quot;
                  %span.o )
                  %span.o ||
                  %span.nv result
                  %span.o =
                  %span.nv $?
                  %span.k return
                  %span.nv $result
                  ;;
                  
                  ruby
                  %span.o )
                  %span.nv requires
                  %span.o =()
                  = succeed "script" do
                    %span.k for
                  in dsl initialize
                  %span.k do
                  = succeed "requires+" do
                    %span.k                   %span.o =(
                  %span.s2 &quot;-r${modules_path}/ruby/core/${script}.rb&quot;
                  %span.o )
                  %span.k done
                  %span.s2 &quot;${binary:-ruby}&quot;
                  \-I
                  %span.s2 &quot;${modules_path}/ruby&quot;
                  \-I
                  %span.s2 &quot;${extension_modules_path}/ruby&quot;
                  %span.se \
                  %span.k ${
                  %span.nv requires
                  %span.p [@]
                  %span.k }
                  %span.s2 &quot;${action_file}&quot;
                  ;;
          %tr
            %td.docs
              %p
                python|lua|javascript)
                ADD "${modules
                %em> path}/${action
                type}/" to the lib path so the script can require "bdsm"
                "${action_file}"
                ;;
            %td.code
              .highlight
                %pre
                  dne|noexec
                  %span.o )
                  fail
                  %span.s2 &quot;Processing ${action} failed, file type is unknown, file does not exist or file is not executable.&quot;
                  ;;
                  binary|*
                  %span.o )
                  %span.s2 &quot;${action_file}&quot;
                  %span.s2 &quot;${extension_action}&quot;
                  %span.s2 &quot;${extension_args[@]}&quot;
                  ;;
                  %span.k esac
                  %span.o ||
                  %span.nv result
                  %span.o =
                  %span.nv $?
                  %span.k return
                  %span.nv $result
                  %span.o }
          %tr
            %td.docs
              %h2 extension_reload()
              %p Reloads (re-sources) the current extension's DSL and initialization files.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                The current extension's DSL and initialization files are re-sourced into the
                calling environment.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No current failure scenarios.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ extension_reload
            %td.code
              .highlight
                %pre
                  extension_reload
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${extension_modules_path}/bash&quot;
                  source_files
                  %span.s2 &quot;${_path}/dsl&quot;
                  %span.s2 &quot;${_path}/initialize&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 extension_reinitialize()
              %p Reinitializes the current extension.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                The current extension's initialize file will be resourced into the current
                environment.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ extension_reinitialize
            %td.code
              .highlight
                %pre
                  extension_reinitialize
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${extension_modules_path}/bash&quot;
                  source_files
                  %span.s2 &quot;${_path}/initialize&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 extension_version()
              %p Outputs the named extension's version
              %h3 Input Parameters
              %p First parameter must be the name of an extension.
              %h3 Stream Outputs
              %p The extension-version string for the named extension.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if the extension name is not given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ extension_reinitialize
            %td.code
              .highlight
                %pre
                  extension_version
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _extension
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  variable_is_nonempty
                  %span.o ||
                  fail
                  %span.s2 &quot;Can not retrieve extension version as no extension was given.&quot;
                  %span.nb shift
                  %span.nb true
                  %span.k ${
                  %span.nv extension_path
                  %span.p :=
                  %span.s2 &quot;${extensions_path}/${_extension}&quot;
                  %span.k }
                  = succeed "file_exists" do
                    %span.k if
                  %span.s2 &quot;${extension_path}/VERSION&quot;
                  %span.k then
                  %span.k                   %span.nb read
                  \-r extension_version &lt;
                  %span.s2 &quot;${extension_path}/VERSION&quot;
                  %span.k else
                  %span.k                   %span.nv extension_version
                  %span.o =
                  %span.s2 &quot;head&quot;
                  %span.k fi
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;${extension}-${extension_version}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 extension_licence()
              %p Emits the extension's license file, if it exists.
              %h3 Input Parameters
              %p First parameter may optionally be an extension name.
              %h3 Stream Outputs
              %p If the extension has a LICENSE file then it wil be printed to STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently exist.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    $ cat $HOME/test
                    !/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules extensions
                    extension_license postgresql
                    
                    $ $HOME/test
                    Copyright (c) 2009-2011 Wayne E. Seguin
                    
                    Licensed under the Apache License, Version 2.0 (the \"License\");
                    you may not use this file except in compliance with the License.
                    You may obtain a copy of the License at
                    
                        http://www.apache.org/licenses/LICENSE-2.0
                    
                    Unless required by applicable law or agreed to in writing, software
                    distributed under the License is distributed on an \"AS IS\" BASIS,
                    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                    See the License for the specific language governing permissions and
                    limitations under the License.
            %td.code
              .highlight
                %pre
                  extension_license
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _extension
                  %span.o =
                  %span.s2 &quot;${1:-${extension}}&quot;
                  variable_is_nonempty _extension
                  %span.o ||
                  fail
                  %span.s2 &quot;Can not display extension license as an extension was not given.&quot;
                  cat -v
                  %span.s2 &quot;${extensions_path}/${_extension}/LICENSE&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 extensions_installed()
              %p Lists the extensions installed on the currently running process's system.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                The names of the currently installed non-core extensions are printed to the
                calling environment's STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    $ cat $HOME/test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules extensions
                    extensions_installed
                    
                    $ $HOME/test
                    bash fossil git libevent nginx p7zip postgresql rails redis tig tmux zeromq zlib
            %td.code
              .highlight
                %pre
                  extensions_installed
                  %span.o ()
                  %span.o {
                  extensions_in
                  %span.s2 &quot;${extensions_path}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 extensions_available()
              %p
                Lists the extensions available to install on the currently running process's
                system.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                The names of the available to install non-core extensions are printed to the
                calling environment's STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                     $ cat $HOME/test
                     #!/usr/bin/env bash
                     source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                     modules extensions
                     extensions_available
            %td.code
              .highlight
                %pre
                  :preserve
                    
                    
          %tr
            %td.docs
              %pre
                %code
                  :preserve
                     $  $HOME/test
                     ack androidsdk apache bash bcrypt cacti cmake ctags curl deploy erlang fossil freetype ghc ghostscript git god iconv imagemagick jpeg keepalived lcms libevent libpng libwmf libxml2 libxslt logrotate lua memcached mercurial mongodb monit mysql nginx node npm openpkg openssl p7zip passenger pcre perl postgresql r rails rainbows readline redis riak rsync rvm screen sphinx sqlite3 subversion system thin tiff tig tmux unicorn unrar zeromq zlib zsh
            %td.code
              .highlight
                %pre
                  extensions_available
                  %span.o ()
                  %span.o {
                  extensions_in
                  %span.s2 &quot;${extensions_src_path}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                extensions
                %em> in
                development()
              %p Lists the extensions available in the development repository, if set.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                The names of the available to install non-core development repository
                extensions are printed to the calling environment's STDOUT, if defined.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                     $ cat $HOME/test
                     #!/usr/bin/env bash
                     source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                     modules extensions
                     extensions_in_development
            %td.code
              .highlight
                %pre
                  :preserve
                    
                    
          %tr
            %td.docs
              %pre
                %code
                  :preserve
                     $  $HOME/test
                     ack androidsdk apache bash bcrypt cacti cmake ctags curl deploy erlang fossil freetype ghc ghostscript git god iconv imagemagick jpeg keepalived lcms libevent libpng libwmf libxml2 libxslt logrotate lua memcached mercurial mongodb monit mysql nginx node npm openpkg openssl p7zip passenger pcre perl postgresql r rails rainbows readline redis riak rsync rvm screen sphinx sqlite3 subversion system thin tiff tig tmux unicorn unrar zeromq zlib zsh
            %td.code
              .highlight
                %pre
                  extensions_in_development
                  %span.o ()
                  %span.o {
                  %span.nb true
                  %span.s2 &quot;${extensions_development_path:=&quot;
                  %span.k ${
                  %span.nv extensions_src_path
                  %span.k }
                  %span.s2 &quot;}&quot;
                  list_extensions_in
                  %span.s2 &quot;${extensions_development_path}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 extensions_in()
              %p Lists the extensions in a given directory.
              %h3 Input Parameters
              %p
                First parameter is a full path a BDSM extensions directory.
                (example: /usr/local/bdsm/extensions)
              %h3 Stream Outputs
              %p
                The names of the extensions in the given directory are printed to the
                calling environment's STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    $ cat $HOME/test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules extensions
                    extensions_in /usr/local/bdsm/extensions
                    
                    $  $HOME/test
                    bash fossil git libevent nginx p7zip postgresql rails redis tig tmux zeromq zlib
            %td.code
              .highlight
                %pre
                  extensions_in
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  directory_exists
                  %span.s2 &quot;${_path}&quot;
                  %span.o ||
                  fail
                  %span.s2 &quot;Cannot list extensions in '${_path}' as the directory does not exist.&quot;
                  %span.nv _files
                  %span.o =(
                  = succeed "find" do
                    %span.k $(
                  %span.s2 &quot;${_path}&quot;
                  \-mindepth 2 -maxdepth 2 -name
                  %span.s1 'VERSION'
                  \-type f
                  %span.k )
                  %span.o )
                  %span.nv extensions
                  %span.o =()
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  %span.k                   %span.nv extension_source_path
                  %span.o =
                  %span.s2 &quot;${_file/%\/VERSION}&quot;
                  %span.nv extension_name
                  %span.o =
                  %span.s2 &quot;${extension_source_path//*\/}&quot;
                  %span.k case
                  %span.k ${
                  %span.nv extension_name
                  %span.k }
                  in
                  = succeed "core|ext|mod|pkg|srv|svc|" do
                    %span.o (
                  = succeed "." do
                    %span.o [[=
                  = succeed "*" do
                    %span.o =]]
                  %span.o )
                  %span.nb true
                  %span.c # Ignore core extensions, they are updated with BDSM itself.
                  ;;
                  = succeed "*" do
                    %span.o (
                  %span.o )
                  extensions
                  %span.o [
                  %span.k ${#
                  %span.nv extensions
                  %span.p [@]
                  %span.k }
                  %span.o ]=
                  %span.s2 &quot;${extension_name//*\//}&quot;
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k                   %span.nv extensions
                  %span.o =
                  %span.s2 &quot;${extensions[@]}&quot;
                  %span.nb printf
                  %span.s2 &quot;${extensions}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 extension_actions()
              %p Lists actions exposed by the named extension.
              %h3 Input Parameters
              %p First parameter is the name of the extension to list actions for.
              %h3 Stream Outputs
              %p
                The names of the extensions in the given directory are printed to the
                calling environment's STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Fails if no extension name is given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                     $ cat $HOME/test
                     #!/usr/bin/env bash
                     source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                     modules extensions
                     extension_actions "postgresql"
                    
                     $ $HOME/test
                     backup configure help initialize install restart start status stop uninstall upgrade
            %td.code
              .highlight
                %pre
                  extension_actions
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _extension
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_extension}&quot;
                  %span.o ]]
                  %span.o ||
                  fail
                  %span.s2 &quot;Cannot list actions for extension as no extension was given.&quot;
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;$extensions_path/${_extension}/bin&quot;
                  directory_exists
                  %span.s2 &quot;${_path}&quot;
                  %span.o ||
                  = succeed "0" do
                    %span.k return
                  %span.nb local
                  %span.nv _files
                  %span.o =(
                  = succeed "find" do
                    %span.k $(
                  %span.s2 &quot;${_path}&quot;
                  \-mindepth 1 -maxdepth 1 -type f
                  %span.k )
                  %span.o )
                  = succeed "_file" do
                    %span.nb local
                  %span.nv _actions
                  %span.o =()
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  %span.o [[
                  \! -x
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.o ||
                  _actions+
                  %span.o =(
                  %span.s2 &quot;${_file//*\/}&quot;
                  %span.o )
                  %span.k done
                  %span.k                   %span.nv _actions
                  %span.o =
                  %span.s2 &quot;${_actions[@]}&quot;
                  %span.c # Convert from array to string.
                  %span.nb printf
                  %span.s2 &quot;${_actions}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                extension
                %em> is
                installed()
              %p Tests if a given extension is installed.
              %h3 Input Parameters
              %p First parameter is an extension name.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the extension is installed.
                1 if the extension is not installed.
              %h3 Failure Scenarios
              %p Fails if no extension name is given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    $ cat $HOME/test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules extensions
                    extensions_installed
                    echo
                    for extension in postgresql asdf
                    do
                      if extension_is_installed "${extension}"
                      then
                        echo "${extension} is installed! "
                      else
                        echo "${extension} is NOT installed! "
                      fi
                    done
                    
                    $  $HOME/test
                    bash fossil git libevent mysql nginx node npm p7zip postgresql rails redis tig tmux zeromq zlib
                    postgresql is installed!
                    asdf is NOT installed!
            %td.code
              .highlight
                %pre
                  extension_is_installed
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _name
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_name}&quot;
                  %span.o ]]
                  %span.o ||
                  fail
                  %span.s2 &quot;Can not check for an installed extension as no extension name was given.&quot;
                  %span.nb local
                  %span.nv _extensions
                  %span.o =
                  %span.s2 &quot; $(extensions_in &quot;
                  %span.k ${
                  %span.nv extensions_path
                  %span.k }
                  %span.s2 &quot;) &quot;
                  %span.k case
                  %span.s2 &quot;${_extensions}&quot;
                  in
                  = succeed "*" do
                    %span.o (
                  = succeed ":space:" do
                    %span.o [[
                  %span.o ]]
                  %span.k ${
                  %span.nv _name
                  %span.k }
                  = succeed ":space:" do
                    %span.o [[
                  = succeed "*" do
                    %span.o ]]
                  %span.o )
                  = succeed "0" do
                    %span.k return
                  ;;
                  = succeed "*" do
                    %span.o (
                  %span.o )
                  = succeed "1" do
                    %span.k return
                  ;;
                  %span.k esac
                  %span.o }
          %tr
            %td.docs
              %h2 extensions_install()
              %p Installs the given extensions.
              %h3 Input Parameters
              %p One or more extension names.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                The named extensions will be installed to the filesystem in the BDSM
                extensions directory.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no extensions are passed in to install.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ extensions_install libevent tmux
            %td.code
              .highlight
                %pre
                  extensions_install
                  %span.o ()
                  %span.o {
                  = succeed "_extension" do
                    %span.nb local
                  %span.nb local
                  %span.nv _extensions
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _extensions
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot install extensions as no extensions were given to install.&quot;
                  %span.k fi
          %tr
            %td.docs
              %p
                We need to ensure that the extensions directory already exists before calling
                install in parallel.
            %td.code
              .highlight
                %pre
                  extension_fetch
                  %span.s2 &quot;${extension_uri:=&quot;
                  %span.k ${
                  %span.nv extensions_repository_url
                  %span.k }
                  %span.s2 &quot;}&quot;
                  = succeed "_extension" do
                    %span.k for
                  in
                  %span.s2 &quot;${_extensions[@]}&quot;
                  %span.k do
                  %span.k case
                  %span.s2 &quot;${_extension#\/}&quot;
                  in
                  ext|srv|pkg|core|mod
                  %span.o )
                  %span.k continue
                  %span.c # Skip core extensions.
                  ;;
                  %span.k esac
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_extension}&quot;
                  %span.o ]]
                  %span.k then
                  %span.c # Skip any empty extensions / 'artifact'.
                  %span.k continue
                  %span.k else
                  %span.o (
                  extension_install
                  %span.s2 &quot;${_extension}&quot;
                  = succeed "&amp;amp;" do
                    %span.o )
                  %span.k fi
                  %span.k done
                  %span.k                   %span.nb wait
                  %span.o }
          %tr
            %td.docs
              %h2 extension_install()
              %p Installs the given extension.
              %h3 Input Parameters
              %p First parameter is the name of the extension to install
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                The named extension will be installed to the filesystem in the BDSM
                extension directory.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no extension are passed in to install.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ extension_install redis
            %td.code
              .highlight
                %pre
                  extension_install
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _extension
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_extension}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot install an extension as no extension name was given.&quot;
                  %span.k fi
                  = succeed "extension_is_valid" do
                    %span.k if
                  %span.s2 &quot;${extension_src_path}/${_extension}&quot;
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot; - ${_extension}&quot;
                  copy_directories to
                  %span.s2 &quot;${bdsm_path}/extensions&quot;
                  %span.s2 &quot;${extension_src_path}/${_extension}&quot;
                  log
                  %span.s2 &quot;${extension_uri}&quot;
                  to
                  %span.s2 &quot;${bdsm_path}/extensions/${_extension}/.uri&quot;
          %tr
            %td.docs
              %p TODO: Process extension dependencies...
            %td.code
              .highlight
                %pre
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;${extension_src_path} is not a proper extension.
                  %span.s2 The named extension is missing VERSION and/or bin/help files.
                  %span.s2 Halting installation.&quot;
                  %span.k fi
                  %span.o }
                  extension_fetch_and_install
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _extension
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_extension}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot fetch and install an extension as no extension name was given.&quot;
                  %span.k fi
                  = succeed "extension_fetch" do
                    %span.k                   %span.s2 &quot;${extension_uri:=&quot;
                  %span.k ${
                  %span.nv extensions_repository_url
                  %span.k }
                  %span.s2 &quot;}&quot;
                  extension_install
                  %span.s2 &quot;${_extension}&quot;
                  %span.o }
                  extension_fetch
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _url
                  %span.o =
                  %span.s2 &quot;${1:-$extension_uri}&quot;
                  %span.nb local
                  %span.nv _identifier
                  %span.o =
                  %span.s2 &quot;${_url//\//_}&quot;
                  %span.c # Convert '/' to an invalid url component '_'
                  %span.nb local
                  %span.nv repo_path
                  %span.o =
                  %span.s2 &quot;${repos_path}/${_identifier}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_url}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot fetch an extension from a url as no url was given&quot;
                  %span.k fi
          %tr
            %td.docs
              %p TODO: scm fetch vs tarball fetch
            %td.code
              .highlight
                %pre
                  scm_fetch
                  %span.s2 &quot;${_url}&quot;
                  scm_update
                  %span.s2 &quot;${_url}&quot;
                  %span.nv extension_src_path
                  %span.o =
                  %span.s2 &quot;${repo_path}&quot;
                  %span.o }
                  extension_is_valid
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot determine if an extension is valid as the path to the extension was not given.&quot;
                  %span.k fi
          %tr
            %td.docs
              %p TODO: Add all extension requirement checks here.
            %td.code
              .highlight
                %pre
                  %span.k if
                  %span.o [[
                  \-s
                  %span.s2 &quot;${_path}/VERSION&quot;
                  %span.o &amp;&amp;
                  \-x
                  %span.s2 &quot;${_path}/bin/help&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
                  extension_package
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _name
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_name}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot package an extension as no extension name was given.&quot;
                  %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${extensions_development_path:-&quot;
                  %span.nv $extensions_src_path
                  %span.s2 &quot;}&quot;
                  enter
                  %span.s2 &quot;${_path}&quot;
                  = succeed "extension_is_valid" do
                    %span.k if
                  %span.s2 &quot;${_path}/${_name}&quot;
                  %span.k then
                  %span.k                   %span.nb local
                  %span.nv _version
                  %span.o =
                  %span.s2 &quot;$(cat &quot;
                  %span.k ${
                  %span.nv _name
                  = succeed "/VERSION" do
                    %span.k }
                  %span.s2 &quot;)&quot;
                  log
                  %span.s2 &quot;Packaging extension ${_name}&quot;
                  log
                  %span.s2 &quot;${_name}-${_version}:&quot;
                  = succeed "archiver" do
                    %span.k for
                  in
                  %span.s2 &quot;gzip&quot;
                  %span.s2 &quot;bzip2 -z&quot;
                  %span.s2 &quot;xz -z&quot;
                  %span.k do
                  = succeed "command_exists" do
                    %span.k if
                  %span.k ${
                  %span.nv archiver
                  %span.p // *
                  %span.k }
                  %span.k then
                  = succeed "tar" do
                    %span.k if
                  cf
                  %span.s2 &quot;${_name}-${_version}.tar&quot;
                  %span.s2 &quot;${_name}/&quot;
                  %span.k then
                  %span.k ${
                  %span.nv archiver
                  %span.k }
                  \-f -9
                  %span.s2 &quot;${_name}-${_version}.tar&quot;
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;There was an error ($?) while trying to create a tar of the '${_name}' directory while packaging.&quot;
                  %span.k fi
                  %span.k fi
                  = succeed "ensure_paths_exist" do
                    %span.k                   %span.s2 &quot;${_path}/pkg&quot;
                  = succeed "file" do
                    %span.k for
                  in
                  = succeed ".tar.*" do
                    %span.s2 &quot;${_name}-${_version}&quot;
                  %span.k do
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;  - ${file}&quot;
                  log
                  %span.s2 &quot;$( file_md5 &quot;
                  %span.k ${
                  %span.nv file
                  %span.k }
                  %span.s2 &quot; )&quot;
                  to
                  %span.s2 &quot;${file}.md5&quot;
                  log
                  %span.s2 &quot;  - ${file}.md5&quot;
                  move_files --force
                  %span.s2 &quot;${file}&quot;
                  %span.s2 &quot;${file}.md5&quot;
                  to
                  %span.s2 &quot;${_path}/pkg&quot;
                  %span.k done
                  %span.k done
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Packaging complete (packages are located in '${_path}/pkg' )&quot;
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot package extension '${_name}' as the extension is not valid.&quot;
                  %span.k fi
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h1 Filesystem Module
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
          %tr
            %td.docs
              %h2 source_files
              %p Safely source files only if they exists and are nonempty.
              %h3 Input Parameters
              %p One or more files.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p Nonempty files given will be sourced into the calling environment.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no files are given to sources.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ source_files "$HOME/.dotfiles/scripts/functions"
            %td.code
              .highlight
                %pre
                  source_files
                  %span.o ()
                  %span.o {
                  = succeed "_file" do
                    %span.nb local
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  %span.k                   %span.nv _file
                  %span.o =
                  %span.k ${
                  %span.nv _file
                  %span.p /\~\//
                  %span.nv $HOME
                  %span.p \/
                  %span.k }
                  %span.c # Expand ~/ to full value of $HOME
                  = succeed "file_is_nonempty" do
                    %span.k if
                  %span.s2 &quot;${_file}&quot;
                  %span.k then
                  %span.k                   %span.nb source
                  %span.s2 &quot;${_file}&quot;
          %tr
            %td.docs
              %p
                TODO: figure out how to see if 'source' itself failed or simply
                returning nonzero code.
                || fail "Failed to source ${_file}."
            %td.code
              .highlight
                %pre
                  %span.k fi
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot source files as no files were given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 nonempty_files
              %p Outputs a subset of the named files that are nonempty.
              %h3 Input Parameters
              %p One or more files.
              %h3 Stream Outputs
              %p
                Each nonempty filename parameter will be printed to STDOUT of the calling
                environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no file names are given as arguments.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ nonempty_files a $HOME/.bdmsrc c
                    /Users/wayneeseguin/.bdsmrc
            %td.code
              .highlight
                %pre
                  nonempty_files
                  %span.o ()
                  %span.o {
                  = succeed "_file" do
                    %span.nb local
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  = succeed "file_is_nonempty" do
                    %span.k if
                  %span.s2 &quot;${_file}&quot;
                  %span.k then
                  %span.k                   %span.nb printf
                  %span.s2 &quot;${_file}\n&quot;
                  %span.k fi
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot return nonempty files as no files were given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                ensure
                %em> paths
                exist
              %p
                Iterates over the list of given paths, creates the directory if it
                does not exist.
              %h3 Input Parameters
              %p A list of paths to create if missing.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p Paths that were given but do not exist will be created.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no paths were given to.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ ls -a
                    . ..
                    user$ ensure_paths_exist a b c
                    user$ ls -a
                    . .. a b c
            %td.code
              .highlight
                %pre
                  ensure_paths_exist
                  %span.o ()
                  %span.o {
                  = succeed "_path" do
                    %span.nb local
                  %span.nv _paths
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _paths
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_path" do
                    %span.k for
                  in
                  %span.s2 &quot;${_paths[@]}&quot;
                  %span.k do
                  %span.k if
                  \! directory_exists
                  %span.s2 &quot;${_path}&quot;
                  %span.k then
                  = succeed "mkdir" do
                    %span.k                   \-p
                  %span.s2 &quot;${_path}&quot;
                  %span.k fi
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot ensure paths exist as no paths were given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 remove_files
              %p Removes the given files, if they exist.
              %h3 Input Parameters
              %p One or more file names/paths.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                The named files will no longer exist on the system, if they existed to begin
                with.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no files were named.
                Fails if a named file is a directory.
                Fails if a named file exists but is not a file.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ touch a b c
                    user$ ls -a
                    . .. a b c
                    user$ remove_files a b c
                    user$ ls
                    . ..
            %td.code
              .highlight
                %pre
                  remove_files
                  %span.o ()
                  %span.o {
                  = succeed "_file" do
                    %span.nb local
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  %span.k if
                  %span.o [[
                  \-f
                  %span.s2 &quot;${_file}&quot;
                  %span.o ||
                  \-L
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "rm" do
                    %span.k                   \-f
                  %span.s2 &quot;${_file}&quot;
                  %span.k elif
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot remove the file ${_file} as it is a directory.&quot;
                  %span.k elif
                  %span.o [[
                  \-e
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Unknown filesystem entity type located at ${_file}, cannot remove.&quot;
                  %span.k else
                  %span.k                   %span.nb true
                  %span.c # already gone
                  %span.k fi
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot remove files as no files were given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 remove
              %p Removes the given entries, if they exist.
              %h3 Input Parameters
              %p One or more file, directory or symlink names/paths.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                The named files will no longer exist on the system, if they existed to begin
                with.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no files were named.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ touch a
                    user$ mkdir b
                    user$ ln -s b c
                    user$ ls -a
                    . .. a b c
                    user$ remove a b c
                    user$ ls
                    . ..
            %td.code
              .highlight
                %pre
                  remove
                  %span.o ()
                  %span.o {
                  = succeed "_file" do
                    %span.nb local
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  %span.k if
                  %span.o [[
                  \-f
                  %span.s2 &quot;${_file}&quot;
                  %span.o ||
                  \-L
                  %span.s2 &quot;${_file}&quot;
                  %span.o ||
                  \-d
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "rm" do
                    %span.k                   \-rf
                  %span.s2 &quot;${_file}&quot;
                  %span.k elif
                  %span.o [[
                  \-e
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Unhandled filesystem entity type located at ${_file}, cannot remove. (File, link and directory types are handled)&quot;
                  %span.k fi
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot remove files as no files were given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 remove_paths
              %p Function Description
              %h3 Input Parameters
              %p Positional Parameter listing and descriptions.
              %h3 Stream Outputs
              %p What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
              %h3 Environmental effects
              %p What, if any, environmental side effects this function causes. 'None.' for none.
              %h3 Return Codes
              %p
                0 if ...
                1 if ...
              %h3 Failure Scenarios
              %p Fails if ...
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ {{ setup the scenario }}
                    user$ function_name {{ parameters }}
                    user$ {{ demonstrate the results}}
            %td.code
              .highlight
                %pre
                  remove_paths
                  %span.o ()
                  %span.o {
                  = succeed "_path" do
                    %span.nb local
                  %span.nv _paths
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _paths
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_path" do
                    %span.k for
                  in
                  %span.s2 &quot;${_paths[@]}&quot;
                  %span.k do
                  %span.k if
                  %span.o [[
                  \-f
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot remove the path '${_path}' as it is a file.&quot;
                  %span.k elif
                  %span.o [[
                  \-L
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "rm" do
                    %span.k                   \-f
                  %span.s2 &quot;${_path}&quot;
                  %span.k elif
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "rm" do
                    %span.k                   \-rf
                  %span.s2 &quot;${_path}&quot;
                  %span.k elif
                  %span.o [[
                  \-e
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Unknown filesystem entity type at ${_path}, cannot remove.&quot;
                  %span.k else
                  %span.k                   %span.nb true
                  %span.c # already gone
                  %span.k fi
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot remove paths as no paths were given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                ensure
                %em> files
                exist
              %p
                Iterates over the list of given files, creates the directory if it
                does not exist.
              %h3 Input Parameters
              %p A list of files to create if missing.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p files that were given but do not exist will be created.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no files were given to.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ ls -a
                    . ..
                    user$ ensure_files_exist a b c
                    user$ ls -a
                    . .. a b c
            %td.code
              .highlight
                %pre
                  ensure_files_exist
                  %span.o ()
                  %span.o {
                  = succeed "_file" do
                    %span.nb local
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  _path
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  %span.k                   %span.nv _path
                  %span.o =
                  %span.s2 &quot;${_file%\/*}&quot;
                  %span.k if
                  %span.o [[
                  \! -d
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "mkdir" do
                    %span.k                   \-p
                  %span.s2 &quot;${_path}&quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  \! -e
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "touch" do
                    %span.k                   %span.s2 &quot;${_file}&quot;
                  %span.k fi
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot ensure files exist as no files were given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                ensure
                %em> files
                are_executable
              %p Sets the executable bits on a file if it is not executable.
              %h3 Input Parameters
              %p One or more file name/paths
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p Files that were given and not executable will have their execute bits set.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if no files were given as parameters.
                Fails if one of the files given was a directory.
                Fails if one of the files given does not exist.
                Fails if one of the files paths does not exist.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ ensure_files_are_executable /etc/rc.d/postgresql
              %p
                TODO: change this to be a  fail function if one is not
                make this into make
                %em> files
                executable or some such
            %td.code
              .highlight
                %pre
                  ensure_files_are_executable
                  %span.o ()
                  %span.o {
                  = succeed "_file" do
                    %span.nb local
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  _path
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot make the file '${_file}' executable as it is a directory.&quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  \! -f
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot make the file '${_file}' executable as the file does not exist.&quot;
                  %span.k fi
                  %span.k                   %span.nv _path
                  %span.o =
                  %span.s2 &quot;${_file%\/*}&quot;
                  %span.k if
                  \!
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_path}&quot;
                  %span.o &amp;&amp;
                  \! -d
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot make the file '${_file} executable as '${_path}' does not even exist.&quot;
                  %span.k fi
                  = succeed "chmod" do
                    %span.k                   +x
                  %span.s2 &quot;${_file}&quot;
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot ensure files are executable as no files were given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 link
              %p Create a symlink from source to target.
              %h3 Input Parameters
              %p
                First parameter is the source
                Second parameter is the target
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p Symlink is created if no failure conditions are triggered.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if target exists and is a file.
                Fails if target exists and is a directory.
              %h3 Usage Examples
              %p The following usages are equivalent
              %pre
                %code
                  :preserve
                    user$ link from /home/user/.vim/vimrc to /home/user/.vimrc
                    user$ link /home/user/.vim/vimrc to /home/user/.vimrc
                    user$ link /home/user/.vim/vimrc /home/user/.vimrc
            %td.code
              .highlight
                %pre
                  link
                  %span.o ()
                  %span.o {
                  = succeed "token" do
                    %span.nb local
                  _source _target
                  %span.nv _force_flag
                  = succeed "0" do
                    %span.o =
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${token}&quot;
                  in
                  to
                  %span.o )
                  %span.nv _target
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  from
                  %span.o )
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  \--force
                  %span.o )
                  %span.nv _force_flag
                  = succeed "1" do
                    %span.o =
                  ;;
                  *
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_source}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _source
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.k elif
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _target
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.k fi
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o ((
                  %span.nv _force_flag
                  %span.o ==
                  1
                  %span.o ))
                  %span.k then
                  = succeed "remove" do
                    %span.k                   %span.s2 &quot;${_target}&quot;
                  %span.k fi
          %tr
            %td.docs
              %p TODO: What should we do if files already exist?
            %td.code
              .highlight
                %pre
                  %span.k if
                  %span.o [[
                  \-f
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot link ${_source} to ${_target} exists and is a file!&quot;
                  %span.k elif
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot link ${_source} to ${_target} exists and is a directory&quot;
                  %span.k else
                  = succeed "ensure_paths_exist" do
                    %span.k                   %span.s2 &quot;${_target%\/*}&quot;
                  ln -fs
                  %span.s2 &quot;${_source}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 move_directory
              %p
                Moves a directory from one location to another.
                (This is also used to rename a directory.)
              %h3 Input Parameters
              %p
                The first parameter is the source directory name
                The second parameter is the target directory name
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p If successful, a directory is renamed (moved).
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if the source directory is not specified.
                Fails if the target directory is not specified.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ move_directory "freetds-0.91rc"* to "freetds-0.91"
            %td.code
              .highlight
                %pre
                  move_directory
                  %span.o ()
                  %span.o {
                  = succeed "_source" do
                    %span.nb local
                  _target _mode _owner
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  ;
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  ;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${token}&quot;
                  in
                  to
                  %span.o )
                  %span.nv _target
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  
                  from
                  %span.o )
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  
                  mode
                  %span.o )
                  %span.nv _mode
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  
                  owner
                  %span.o )
                  %span.nv _owner
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  
                  *
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_source}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _source
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.k elif
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _target
                  %span.o =
                  %span.s2 &quot;$token&quot;
          %tr
            %td.docs
              %p When we have a target we are done.
            %td.code
              .highlight
                %pre
                  %span.nb break
                  %span.nb                   %span.k fi
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_source}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot move file as the source and target must be specified. &quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot move file as the source and target must be specified. &quot;
                  %span.k fi
                  = succeed "mv" do
                    %span.k                   %span.s2 &quot;${_source}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_mode:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "chmod" do
                    %span.k                   \-R
                  %span.s2 &quot;${_mode}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_owner:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "chown" do
                    %span.k                   \-R
                  %span.s2 &quot;${_owner}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 move_file
              %p
                Moves a file from one location to another.
                (This is also used to rename a file.)
              %h3 Input Parameters
              %p
                The first parameter is the source file name
                The second parameter is the target file name
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p If successful, a file is renamed (moved).
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if the source file is not specified.
                Fails if the target file is not specified.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ move_file "$HOME/.bashrc" to "$HOME/.bashrc.orig"
            %td.code
              .highlight
                %pre
                  move_file
                  %span.o ()
                  %span.o {
                  = succeed "_source" do
                    %span.nb local
                  _target _mode _owner
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  ;
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  ;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${token}&quot;
                  in
                  to
                  %span.o )
                  %span.nv _target
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  from
                  %span.o )
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  mode
                  %span.o )
                  %span.nv _mode
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  owner
                  %span.o )
                  %span.nv _owner
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  
                  *
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_source}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _source
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.k elif
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _target
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.nb break
                  %span.nb                   %span.k fi
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_source}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot move file as the source and target must be specified. &quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot move file as the source and target must be specified. &quot;
                  %span.k fi
                  = succeed "mv" do
                    %span.k                   %span.s2 &quot;${_source}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_mode:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "chmod" do
                    %span.k                   %span.s2 &quot;${_mode}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_owner:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "chown" do
                    %span.k                   %span.s2 &quot;${_owner}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 copy_file
              %p
                Copys a file from one location to another.
                (This is also used to rename a file.)
              %h3 Input Parameters
              %p
                The first parameter is the source file name
                The second parameter is the target file name
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p If successful, a file is renamed (copyd).
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if the source file is not specified.
                Fails if the target file is not specified.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ copy_file "$HOME/.bashrc" to "$HOME/.bashrc.orig"
            %td.code
              .highlight
                %pre
                  copy_file
                  %span.o ()
                  %span.o {
                  = succeed "_source" do
                    %span.nb local
                  _target
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  ;
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${token}&quot;
                  in
                  to
                  %span.o )
                  %span.nv _target
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  from
                  %span.o )
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  mode
                  %span.o )
                  %span.nv _mode
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  owner
                  %span.o )
                  %span.nv _owner
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  *
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_source:-}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _source
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.nb shift
                  %span.nb                   %span.k elif
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_target:-}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _target
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.nb break
                  %span.nb                   %span.k fi
                  ;;
                  %span.k esac
                  %span.k done
                  = succeed "cp" do
                    %span.k                   %span.s2 &quot;${_source}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_mode:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "chmod" do
                    %span.k                   %span.s2 &quot;${_mode}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_owner:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "chown" do
                    %span.k                   %span.s2 &quot;${_owner}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                copy
                %em> files
                to
              %p depreciated, please use copy_files with the 'to' specifier instead
            %td.code
              .highlight
                %pre
                  copy_files_to
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _file
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Path was not given as the first parameter.&quot;
                  %span.k else
                  %span.k                   %span.nb shift
                  %span.nb                   %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;No files were given in order to copy them into ${_path}.&quot;
                  %span.k fi
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;copy_files_to is depreciated, please use copy_files with the 'to' specifier instead&quot;
                  ensure_paths_exist
                  %span.s2 &quot;${_path}&quot;
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  = succeed "file_is_missing" do
                    %span.k if
                  %span.s2 &quot;${_file}&quot;
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot copy file ${_file} to ${_path} as the file does not exist.&quot;
                  %span.k else
                  = succeed "cp" do
                    %span.k                   %span.s2 &quot;${_file}&quot;
                  %span.s2 &quot;${_path}/${_file}&quot;
                  %span.k fi
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 copy_files
              %p Copys a given list of files into the named path.
              %h3 Input Parameters
              %p
                The first parameter is the path to copy the files into.
                Remaining parameters are the file name/path list.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p If successful, all named files are copied into the target path.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if no target path is given.
                Fails if no files are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ copy_files "$HOME/.bashrc" "$HOME/.bash_profile" \
                            to "$HOME/backup"
            %td.code
              .highlight
                %pre
                  copy_files
                  %span.o ()
                  %span.o {
                  = succeed "_source" do
                    %span.nb local
                  _target _file
                  %span.nv _force_flag
                  = succeed "0" do
                    %span.o =
                  %span.nv _files
                  %span.o =()
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${token}&quot;
                  in
                  to
                  %span.o )
                  %span.nv _target
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  from
                  %span.o )
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  \--force
                  %span.o )
                  %span.nv _force_flag
                  = succeed "1" do
                    %span.o =
                  ;;
                  
                  *
                  %span.o )
                  _files+
                  %span.o =(
                  %span.s2 &quot;${token}&quot;
                  %span.o )
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot copy files as no target path was given (eg. copy_files ... to {path}).&quot;
                  %span.k fi
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot copy files as no files were given to copy.&quot;
                  %span.k fi
                  = succeed "ensure_paths_exist" do
                    %span.k                   %span.s2 &quot;${_target}&quot;
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  = succeed "file_is_missing" do
                    %span.k if
                  %span.s2 &quot;${_file}&quot;
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot copy file ${_file} to ${_target} as the file does not exist.&quot;
                  %span.k else
                  %span.k if
                  %span.o ((
                  %span.nv _force_flag
                  %span.o ==
                  1
                  %span.o ))
                  %span.k then
                  = succeed "cp" do
                    %span.k                   \-f
                  %span.s2 &quot;${_file}&quot;
                  %span.s2 &quot;${_target}/${_file//*\/}&quot;
                  %span.k else
                  = succeed "cp" do
                    %span.k                   %span.s2 &quot;${_file}&quot;
                  %span.s2 &quot;${_target}/${_file//*\/}&quot;
                  %span.k fi
                  %span.k fi
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2
                copy
                %em> directories
                to
              %p Copys a given list of directories into the named path.
              %h3 Input Parameters
              %p
                The first parameter is the path to copy the directorys into.
                Remaining parameters are the directory name/path list.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p If successful, all named directories are copied into the target path.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if no target path is given.
                Fails if no directories are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ copy_directories_to "$HOME/backup/" "$HOME/bin" "$HOME/projects"
            %td.code
              .highlight
                %pre
                  copy_directories_to
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _directory
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Path was not given as the first parameter.&quot;
                  %span.k else
                  %span.k                   %span.nb shift
                  %span.nb                   %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _directories
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _directories
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;No directories were given in order to copy them into ${_path}.&quot;
                  %span.k fi
                  = succeed "ensure_paths_exist" do
                    %span.k                   %span.s2 &quot;${_path}&quot;
                  = succeed "_directory" do
                    %span.k for
                  in
                  %span.s2 &quot;${_directories[@]}&quot;
                  %span.k do
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${_directory}&quot;
                  %span.k then
                  = succeed "cp" do
                    %span.k                   \-Rf
                  %span.s2 &quot;${_directory}&quot;
                  %span.s2 &quot;${_path}/&quot;
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot copy directory ${_directory} to ${_path} as the directory '${_directory}' does not exist (in '$PWD').&quot;
                  %span.k fi
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 copy_directories to
              %p Copys a given list of directories into the named path.
              %h3 Input Parameters
              %p
                The first parameter is the path to copy the directorys into.
                Remaining parameters are the directory name/path list.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p If successful, all named directories are copied into the target path.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if no target path is given.
                Fails if no directories are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ copy_directories to "$HOME/backup/" "$HOME/bin" "$HOME/projects"
            %td.code
              .highlight
                %pre
                  copy_directories
                  %span.o ()
                  %span.o {
                  = succeed "_source" do
                    %span.nb local
                  _target _directory
                  %span.nv _force_flag
                  = succeed "0" do
                    %span.o =
                  %span.nv _directories
                  %span.o =()
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${token}&quot;
                  in
                  to
                  %span.o )
                  %span.nv _target
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  from
                  %span.o )
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  \--force
                  %span.o )
                  %span.nv _force_flag
                  = succeed "1" do
                    %span.o =
                  ;;
                  
                  *
                  %span.o )
                  _directories+
                  %span.o =(
                  %span.s2 &quot;${token}&quot;
                  %span.o )
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot copy directories as no target path was given (eg. copy_directories ... to {path}).&quot;
                  %span.k fi
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _directories
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot copy directories as no directories were given to copy.&quot;
                  %span.k fi
                  = succeed "ensure_paths_exist" do
                    %span.k                   %span.s2 &quot;${_target}&quot;
                  = succeed "_directory" do
                    %span.k for
                  in
                  %span.s2 &quot;${_directories[@]}&quot;
                  %span.k do
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${_directory}&quot;
                  %span.k then
                  = succeed "cp" do
                    %span.k                   \-Rf
                  %span.s2 &quot;${_directory}&quot;
                  %span.s2 &quot;${_target}/&quot;
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot copy directory ${_directory} to ${_target} as the directory '${_directory}' does not exist (in '$PWD').&quot;
                  %span.k fi
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 copy_directory
              %p
                Copys a directory from one location to another.
                (This is also used to rename a directory.)
              %h3 Input Parameters
              %p
                The first parameter is the source directory name
                The second parameter is the target directory name
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p If successful, a directory is renamed (copyd).
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if the source directory is not specified.
                Fails if the target directory is not specified.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ copy_directory "freetds-0.91rc"* to "freetds-0.91"
            %td.code
              .highlight
                %pre
                  copy_directory
                  %span.o ()
                  %span.o {
                  = succeed "_source" do
                    %span.nb local
                  _target
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${token}&quot;
                  in
                  to
                  %span.o )
                  %span.nv _target
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  from
                  %span.o )
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  *
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_source}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _source
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.nb shift
                  %span.nb                   %span.k elif
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _target
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.nb break
                  %span.nb                   %span.k fi
                  ;;
                  %span.k esac
                  %span.k done
                  = succeed "cp" do
                    %span.k                   \-Rf
                  %span.s2 &quot;${_source}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                move
                %em> files
                to
              %p Moves a given list of files into the named path.
              %h3 Input Parameters
              %p
                The first parameter is the path to move the files into.
                Remaining parameters are the file name/path list.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p If successful, all named files are copied into the target path.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if no target path is given.
                Fails if no files are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ move_files_to "$HOME/backup" "$HOME/.bashrc" "$HOME/.bash_profile"
            %td.code
              .highlight
                %pre
                  move_files_to
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _file
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Path was not given as the first parameter.&quot;
                  %span.k else
                  %span.k                   %span.nb shift
                  %span.nb                   %span.k fi
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;DEPRECIATED, use 'move_files ... to _path' instead&quot;
                  %span.nb local
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;No files given in order to chmod ${_permissions} them.&quot;
                  %span.k fi
                  = succeed "ensure_paths_exist" do
                    %span.k                   %span.s2 &quot;${_path}&quot;
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  = succeed "file_exists" do
                    %span.k if
                  %span.s2 &quot;${_file}&quot;
                  %span.k then
                  = succeed "mv" do
                    %span.k                   %span.s2 &quot;${_file}&quot;
                  %span.s2 &quot;${_path}/${_file}&quot;
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot move file ${_file} to ${_path} as the file does not exist.&quot;
                  %span.k fi
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 move_files
              %p Moves a given list of files into the named path.
              %h3 Input Parameters
              %p
                Parameters are file name/path for one or more files
                Target directory is specified as 'to {{path}}'
                Optional source directory is specified as 'from {{path}}'
                Optional force flag '--force' may be specified
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p If successful, all named files are copied into the target path.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if no target path is given.
                Fails if no files are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$
              %p Alternatively,
              %pre
                %code
                  :preserve
                    user$ move_files ".bashrc" ".bash_profile" from "$HOME" to "$HOME/backup"
            %td.code
              .highlight
                %pre
                  move_files
                  %span.o ()
                  %span.o {
                  = succeed "_source" do
                    %span.nb local
                  _target _file
                  %span.nv _force_flag
                  = succeed "0" do
                    %span.o =
                  %span.nv _files
                  %span.o =()
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${token}&quot;
                  in
                  to
                  %span.o )
                  %span.nv _target
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  from
                  %span.o )
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  \--force
                  %span.o )
                  %span.nv _force_flag
                  = succeed "1" do
                    %span.o =
                  ;;
                  
                  *
                  %span.o )
                  _files+
                  %span.o =(
                  %span.s2 &quot;${token}&quot;
                  %span.o )
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_source}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _file
                  %span.o =
                  %span.s2 &quot;${_source}/${_file}&quot;
                  %span.k fi
                  = succeed "file_exists" do
                    %span.k if
                  %span.s2 &quot;${_file}&quot;
                  %span.k then
                  %span.k if
                  %span.o ((
                  %span.nv _force_flag
                  %span.o ==
                  1
                  %span.o ))
                  %span.k then
                  = succeed "mv" do
                    %span.k                   \-f
                  %span.s2 &quot;${_file}&quot;
                  %span.s2 &quot;${_target}/${_file//*\/}&quot;
                  %span.k else
                  = succeed "mv" do
                    %span.k                   %span.s2 &quot;${_file}&quot;
                  %span.s2 &quot;${_target}/${_file//*\/}&quot;
                  %span.k fi
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot move file ${_file} to ${_path} as the file does not exist.&quot;
                  %span.k fi
                  %span.k done
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot move files to '${_target}' as the directory does not exist&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot move files as no files were given to move.&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot move files as no target path was given (eg. move_files ... to {path}).&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 chown_files
              %p Change ownership of a list of files.
              %h3 Input Parameters
              %p
                First parameter is the new owner[:group] of the files.
                Remaining parameters are the file names/paths.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no new owner[:group] was specified.
                Fails if no list of files was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ chown_files $USER "$HOME/.bashrc" "$HOME/.bash_profile"
            %td.code
              .highlight
                %pre
                  chown_files
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _identity
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _file
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_identity}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;user[:group] not given as the first parameter.&quot;
                  %span.k else
                  %span.k                   %span.nb shift
                  %span.nb                   %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;No paths given to chmod ${_permissions}.&quot;
                  %span.k fi
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  = succeed "file_exists" do
                    %span.k if
                  %span.s2 &quot;${_file}&quot;
                  %span.k then
                  = succeed "chown" do
                    %span.k                   \-R
                  %span.k ${
                  %span.nv _identity
                  %span.k }
                  %span.s2 &quot;${_file}&quot;
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot chown file ${_file} to ${_identity} as the file does not exist.&quot;
                  %span.k fi
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 chown_paths
              %p Change ownership of a list of paths.
              %h3 Input Parameters
              %p
                First parameter is the new owner[:group] of the paths.
                Remaining parameters are the path names/paths.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no new owner[:group] was specified.
                Fails if no list of paths was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ chown_paths $USER "$HOME" "/usr/local"
            %td.code
              .highlight
                %pre
                  chown_paths
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _identity
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _path
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_identity}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;user[:group] not given as the first parameter.&quot;
                  %span.k else
                  %span.k                   %span.nb shift
                  %span.nb                   %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _paths
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _paths
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;No paths given to chmod ${_permissions}.&quot;
                  %span.k fi
                  = succeed "_path" do
                    %span.k for
                  in
                  %span.s2 &quot;${_paths[@]}&quot;
                  %span.k do
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${_path}&quot;
                  %span.k then
                  = succeed "chown" do
                    %span.k                   %span.k ${
                  %span.nv _identity
                  %span.k }
                  %span.s2 &quot;${_path}&quot;
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot chown path ${_path} to ${_identity} as the directory does not exist.&quot;
                  %span.k fi
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2
                chown
                %em> paths
                recursively
              %p Change ownership of a list of paths, recursively.
              %h3 Input Parameters
              %p
                First parameter is the new owner[:group] of the paths.
                Remaining parameters are the path names/paths.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no new owner[:group] was specified.
                Fails if no list of paths was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ chown_paths_recursively $USER "$HOME" "/usr/local"
            %td.code
              .highlight
                %pre
                  chown_paths_recursively
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _identity
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _path
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_identity}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;user[:group] not given as the first parameter!!&quot;
                  %span.k else
                  %span.k                   %span.nb shift
                  %span.nb                   %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _paths
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _paths
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;No paths given to chmod ${_permissions}.&quot;
                  %span.k fi
                  = succeed "_path" do
                    %span.k for
                  in
                  %span.s2 &quot;${_paths[@]}&quot;
                  %span.k do
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${_path}&quot;
                  %span.k then
                  = succeed "chown" do
                    %span.k                   \-R
                  %span.k ${
                  %span.nv _identity
                  %span.k }
                  %span.s2 &quot;${_path}&quot;
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot recursively chown ${_path} to ${_identity} as the directory does not exist.&quot;
                  %span.k fi
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 chmod_files
              %p Change ownership of a list of files.
              %h3 Input Parameters
              %p
                First parameter is the new owner[:group] of the files.
                Remaining parameters are the file names/files.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no new owner[:group] was specified.
                Fails if no list of files was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ chmod_files $USER "$HOME" "/usr/local"
            %td.code
              .highlight
                %pre
                  chmod_files
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _permissions
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _file _message
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_permissions}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb local
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  = succeed "file_exists" do
                    %span.k if
                  %span.s2 &quot;${_file}&quot;
                  %span.k then
                  = succeed "chmod" do
                    %span.k                   %span.k ${
                  %span.nv _permissions
                  %span.k }
                  %span.s2 &quot;${_file}&quot;
                  %span.k else
                  %span.k                   %span.nv _message
                  %span.o =(
                  %span.s2 &quot;Cannot chmod file ${_file} to ${_permissions}&quot;
                  %span.s2 &quot; as the file does not exist.&quot;
                  %span.o )
                  error
                  %span.s2 &quot;${_message[*]}&quot;
                  %span.k fi
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;No files given to chmod ${_permissions}.&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Permissions not given as the first parameter!!&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 chmod_paths
              %p Change ownership of a list of paths.
              %h3 Input Parameters
              %p
                First parameter is the new owner[:group] of the paths.
                Remaining parameters are the path names/paths.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no new owner[:group] was specified.
                Fails if no list of paths was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ chmod_paths $USER "$HOME" "/usr/local"
            %td.code
              .highlight
                %pre
                  chmod_paths
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _permissions
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  _path _message
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_permissions}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb local
                  %span.nv _paths
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _paths
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_path" do
                    %span.k for
                  in
                  %span.s2 &quot;${_paths[@]}&quot;
                  %span.k do
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${_path}&quot;
                  %span.k then
                  = succeed "chmod" do
                    %span.k                   %span.k ${
                  %span.nv _permissions
                  %span.k }
                  %span.s2 &quot;${_path}&quot;
                  %span.k else
                  %span.k                   %span.nv _message
                  %span.o =(
                  %span.s2 &quot;Cannot chmod directory ${_path} to ${_permissions}&quot;
                  %span.s2 &quot; as the directory does not exist.&quot;
                  %span.o )
                  error
                  %span.s2 &quot;${_message[*]}&quot;
                  %span.k fi
                  %span.k done
                  %span.k else
                  %span.k                   %span.nv _message
                  %span.o =(
                  %span.s2 &quot;Cannot chmod_paths as no paths were given in &quot;
                  %span.s2 &quot;order to change permissions to ${_permissions}.&quot;
                  %span.o )
                  fail
                  %span.s2 &quot;${_message[*]}&quot;
                  %span.k fi
                  %span.k else
                  %span.k                   %span.nv _message
                  %span.o =(
                  %span.s2 &quot;Cannot chmod_paths as the permissions were &quot;
                  %span.s2 &quot;not given as the first parameter!!&quot;
                  %span.o )
                  fail
                  %span.s2 &quot;${_message[*]}&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                chmod
                %em> paths
                recursively
              %p Change ownership of a list of paths, recursively.
              %h3 Input Parameters
              %p
                First parameter is the new owner[:group] of the paths.
                Remaining parameters are the path names/paths.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no new owner[:group] was specified.
                Fails if no list of paths was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ chmod_paths_recursively $USER "$HOME" "/usr/local"
            %td.code
              .highlight
                %pre
                  chmod_paths_recursively
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _permissions
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _path _message
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_permissions}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb local
                  %span.nv _paths
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _paths
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_path" do
                    %span.k for
                  in
                  %span.s2 &quot;${_paths[@]}&quot;
                  %span.k do
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${_path}&quot;
                  %span.k then
                  = succeed "chmod" do
                    %span.k                   \-R
                  %span.k ${
                  %span.nv _permissions
                  %span.k }
                  %span.s2 &quot;${_path}&quot;
                  %span.k else
                  %span.k                   %span.nv _message
                  %span.o =(
                  %span.s2 &quot;Cannot chmod directory ${_path} to ${_permissions} &quot;
                  %span.s2 &quot;as the directory does not exist.&quot;
                  %span.o )
                  error
                  %span.s2 &quot;${_message[*]}&quot;
                  %span.k fi
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;No paths given to chmod ${_permissions}.&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Permissions not given as the first parameter!!&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 enter
              %p
                Changes the current working directory ($PWD) to the given directory with
                sanity checks.
              %h3 Input Parameters
              %p First parameter is the directory to change into.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                The current working directory (PWD) will become the given directory if
                successful.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no directory was given.
                Fails if the given directory does not exist.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ enter "/usr/local/src"
            %td.code
              .highlight
                %pre
                  enter
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  \!
                  %span.nb builtin cd
                  %span.s2 &quot;${_path}&quot;
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;There was an error ($?) while entering the directory '${_path}'.&quot;
                  %span.k fi
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot enter the directory '${_path}' as it does not exist.&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot enter a directory as no directory was given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 hash_file
              %p Set and get key/value pairs from a given has file.
              %h3 Input Parameters
              %p
                The first parameter is the file name/path for the hash file.
                The second parameter is the key name.
                The third (optional) parameter is the value to assign to the given key.
              %h3 Stream Outputs
              %p The value of the key retrieved is printed if no value parameter was given.
              %h3 Environmental effects
              %p
                If a value parameter was given the key=value pair is written to the named
                hash file.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no file name/path was provided.
                Fails if no key name was given.
                Fails if the file path does not exist.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ hash_file /usr/local/bdsm/extensions/core/config/defaults website_url
                    https://bdsm.beginrescueend.com/
            %td.code
              .highlight
                %pre
                  hash_file
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _message
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;File path/name not given.\n =&gt; Usage: $0 &lt;filename&gt; &lt;key&gt; [value]&quot;
                  %span.k else
                  %span.k                   %span.nb shift
                  %span.nb                   %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _key
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_key}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Key not given.\n =&gt; Usage: $0 &lt;filename&gt; &lt;key&gt; [value]&quot;
                  %span.k else
                  %span.k                   %span.nb shift
                  %span.nb                   %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _path
                  %span.o =
                  = succeed "dirname" do
                    %span.k $(
                  %span.s2 &quot;${_file}&quot;
                  %span.k )
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "ensure_files_exist" do
                    %span.k                   %span.s2 &quot;$_file&quot;
                  %span.k else
                  %span.k                   %span.nv _message
                  %span.o =(
                  %span.s2 &quot;Cannot access the database file '${_file}' &quot;
                  %span.s2 &quot;as the directory '${_file%\/*}' does not exist.&quot;
                  %span.o )
                  error
                  %span.s2 &quot;{$_message[*]}&quot;
                  %span.k fi
                  %span.k                   %span.nv value
                  %span.o =
                  %span.s2 &quot;$*&quot;
                  %span.k case
                  %span.s2 &quot;$value&quot;
                  in
                  = succeed "|delete" do
                    %span.nb unset
                  %span.o )
                  sed -i.tmp
                  %span.s2 &quot;s#^${_key}=.*\$##&quot;
                  %span.s2 &quot;${_file}&quot;
                  ;;
                  *
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${value}&quot;
                  %span.o ]]
                  %span.k then
                  %span.c # get
                  awk -F
                  %span.o =
                  %span.s1 '/^'
                  %span.s2 &quot;${_key}&quot;
                  %span.s1 '=/{print $2}'
                  %span.s2 &quot;$_file&quot;
                  %span.k else
                  %span.c # set
                  %span.k if
                  \! awk -F
                  %span.o =
                  %span.s2 &quot;/^'&quot;
                  %span.k ${
                  %span.nv _key
                  %span.k }
                  %span.s2 &quot;'=/{print $2}&quot;
                  %span.s2 &quot;${_file}&quot;
                  \&gt;/dev/null 2&gt;&amp;1
                  %span.k then
                  %span.k                   %span.nb echo
                  %span.s2 &quot;${_key}=$value&quot;
                  \&gt;&gt;
                  %span.s2 &quot;${_file}&quot;
                  %span.k else
                  %span.c # overwrite
                  sed -i.tmp
                  %span.s2 &quot;s#^${_key}=.*\$#${_key}=$value#&quot;
                  %span.s2 &quot;${_file}&quot;
                  %span.k fi
                  %span.k fi
                  ;;
                  %span.k esac
                  %span.o }
          %tr
            %td.docs
              %h2
                file
                %em> is
                executable
              %p Check if a file name/path is executable.
              %h3 Input Parameters
              %p First parameter is a file name/path.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the named file is executable.
                1 if the named file is not executable or does not exist.
              %h3 Failure Scenarios
              %p Fails if no file name/path was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ file_is_executable /bin/bash
                    user$ echo $?
                    0
                    
                    user$ file_is_executable /bin/asdfasdf
                    user$ echo $?
                    1
            %td.code
              .highlight
                %pre
                  file_is_executable
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-x
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check if a file is executable as no file path/name was given&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 file_exists
              %p Check if a file name/path exists.
              %h3 Input Parameters
              %p First parameter is a file name/path.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the named file exists.
                1 if the named file does not exist or does not exist.
              %h3 Failure Scenarios
              %p Fails if no file name/path was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ file_exists /bin/bash
                    user$ echo $?
                    0
                    
                    user$ file_exists /bin/asdfasdf
                    user$ echo $?
                    1
            %td.code
              .highlight
                %pre
                  file_exists
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-f
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check to see if a file exists as no file name/path was given&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                file
                %em> is
                nonempty
              %p Check if a file name/path is nonempty.
              %h3 Input Parameters
              %p First parameter is a file name/path.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the named file is nonempty.
                1 if the named file is empty or does not exist.
              %h3 Failure Scenarios
              %p Fails if no file name/path was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ file_is_nonempty /bin/bash
                    user$ echo $?
                    0
                    
                    user$ file_is_nonempty /bin/asdfasdf
                    user$ echo $?
                    1
            %td.code
              .highlight
                %pre
                  file_is_nonempty
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;When checking whether the file '${_file}' is nonempty, a directory was found in its place.&quot;
                  %span.k else
                  %span.k if
                  %span.o [[
                  \-s
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check if file is nonempty as no file path/name was given&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                file
                %em> is
                empty
              %p Check if a file name/path is empty.
              %h3 Input Parameters
              %p First parameter is a file name/path.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the named file is empty.
                1 if the named file is not empty or does not exist.
              %h3 Failure Scenarios
              %p Fails if no file name/path was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ file_is_empty /bin/bash
                    user$ echo $?
                    1
                    
                    user$ file_is_empty /bin/asdfasdf
                    user$ echo $?
                    0
            %td.code
              .highlight
                %pre
                  file_is_empty
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-f
                  %span.s2 &quot;${_file}&quot;
                  %span.o &amp;&amp;
                  \! -s
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check if a file is empty as no file path/name was given&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                file
                %em> is
                missing
              %p Check if a file name/path is missing.
              %h3 Input Parameters
              %p First parameter is a file name/path.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the named file is missing.
                1 if the named file is not missing or does not exist.
              %h3 Failure Scenarios
              %p Fails if no file name/path was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ file_is_missing /bin/bash
                    user$ echo $?
                    1
                    
                    user$ file_is_missing /bin/asdfasdf
                    user$ echo $?
                    0
            %td.code
              .highlight
                %pre
                  file_is_missing
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \! -f
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check if file is missing as no file path/name was given&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                file
                %em> is
                empty
                %em> or
                missing
              %p Check if a file name/path is empty or missing.
              %h3 Input Parameters
              %p First parameter is a file name/path.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the named file is empty or missing.
                1 if the named file exists or is nonempty.
              %h3 Failure Scenarios
              %p Fails if no file name/path was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ file_is_missing /bin/bash
                    user$ echo $?
                    1
                    
                    user$ file_is_missing /bin/asdfasdf
                    user$ echo $?
                    0
            %td.code
              .highlight
                %pre
                  file_is_empty_or_missing
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \! -f
                  %span.s2 &quot;${_file}&quot;
                  %span.o ||
                  \! -s
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check if file is empty or missing as no file path/name was given&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 file_contains()
              %p Checks if a named file contains a given string/unix regexp pattern.
              %h3 Input Parameters
              %p
                First parameter is the file name/path.
                Second parameter is the pattern to match.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the given file contains the given pattern.
                1 if the given file does not contain the given pattern.
              %h3 Failure Scenarios
              %p
                Fails if the file path/name was not given
                Fails if the pattern is not given.
                Fails if the file path/name given either does not exist or is not a file.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat "$HOME/test"
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    
                    modules filesystem
                    
                    if file_contains "$HOME/.bdsmrc" ".*w00t.*"
                    then
                      echo "w00t! "
                    else
                      echo "no w00t :("
                    fi
            %td.code
              .highlight
                %pre
                  file_contains
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _message
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb local
                  %span.nv _pattern
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_pattern}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-f
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "grep" do
                    %span.k if
                  %span.s2 &quot;${_pattern}&quot;
                  %span.s2 &quot;${_file}&quot;
                  \&gt;/dev/null 2&gt;&amp;1
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  %span.k                   %span.nv _message
                  %span.o =(
                  %span.s2 &quot;First parameter must be a file, '${_file}'&quot;
                  %span.s2 &quot; does not appear to be a file.&quot;
                  %span.o )
                  fail
                  %span.s2 &quot;${_message[*]}&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;String pattern for search was not given!&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;File path/name was not given!&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 symlink_exists
              %p Check if a symlink name/path exists.
              %h3 Input Parameters
              %p First parameter is a symlink name/path.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the named symlink exists.
                1 if the named symlink does not exist or does not exist.
              %h3 Failure Scenarios
              %p Fails if no symlink name/path was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ symlink_exists /usr/local/bin/bdsm
                    user$ echo $?
                    0
                    
                    user$ symlink_exists /bin/asdfasdf
                    user$ echo $?
                    1
            %td.code
              .highlight
                %pre
                  symlink_exists
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-L
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check if symlink exists as no path/name was given&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 directory_exists
              %p Check if a directory name/path exists.
              %h3 Input Parameters
              %p First parameter is a directory name/path.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the named directory exists.
                1 if the named directory does not exist or does not exist.
              %h3 Failure Scenarios
              %p Fails if no directory name/path was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ directory_exists /usr/local/bin/bdsm
                    user$ echo $?
                    0
                    
                    user$ directory_exists /bin/asdfasdf
                    user$ echo $?
                    1
            %td.code
              .highlight
                %pre
                  directory_exists
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _directory
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_directory}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;$_directory&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check if directory exists as no name/path was given&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 function_name
              %p Function Description
              %h3 Input Parameters
              %p Positional Parameter listing and descriptions.
              %h3 Stream Outputs
              %p What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
              %h3 Environmental effects
              %p What, if any, environmental side effects this function causes. 'None.' for none.
              %h3 Return Codes
              %p
                0 if ...
                1 if ...
              %h3 Failure Scenarios
              %p Fails if ...
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ {{ setup the scenario }}
                    user$ function_name {{ parameters }}
                    user$ {{ demonstrate the results}}
            %td.code
              .highlight
                %pre
                  directories_in
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "find" do
                    %span.k if
                  %span.s2 &quot;${_path}&quot;
                  \-mindepth 1 -maxdepth 1 -type d
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;'${_path}' is not a directory!&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Directory name/path was not given!&quot;
                  %span.k fi
                  %span.o }
                  directories_in_matching
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.nv _pattern
                  %span.o =
                  %span.s2 &quot;${2:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_pattern}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "find" do
                    %span.k if
                  %span.s2 &quot;${_path}&quot;
                  \-mindepth 1 -maxdepth 1 -type d
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;'${_path}' is not a directory!&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;'${_path}' is not a directory!&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Directory name/path was not given!&quot;
                  %span.k fi
                  %span.o }
                  directories_under
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "find" do
                    %span.k if
                  %span.s2 &quot;${_path}&quot;
                  \-mindepth 1 -type d
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;'${_path}' is not a directory!&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Directory name/path was not given!&quot;
                  %span.k fi
                  %span.o }
                  directories_under_matching
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb local
                  %span.nv _pattern
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_pattern}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "find" do
                    %span.k if
                  %span.s2 &quot;${_path}&quot;
                  \-mindepth 1 -iname
                  %span.s2 &quot;${_pattern}&quot;
                  \-type d
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;'${_path}' is not a directory!&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;'${_path}' is not a directory!&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Directory name/path was not given!&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 function_name
              %p Function Description
              %h3 Input Parameters
              %p Positional Parameter listing and descriptions.
              %h3 Stream Outputs
              %p What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
              %h3 Environmental effects
              %p What, if any, environmental side effects this function causes. 'None.' for none.
              %h3 Return Codes
              %p
                0 if ...
                1 if ...
              %h3 Failure Scenarios
              %p Fails if ...
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ {{ setup the scenario }}
                    user$ function_name {{ parameters }}
                    user$ {{ demonstrate the results}}
            %td.code
              .highlight
                %pre
                  files_in
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "find" do
                    %span.k if
                  %span.s2 &quot;${_path}&quot;
                  \-mindepth 1 -maxdepth 1 -type f
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;'${_path}' is not a directory!&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Directory name/path was not given!&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 function_name
              %p Function Description
              %h3 Input Parameters
              %p Positional Parameter listing and descriptions.
              %h3 Stream Outputs
              %p What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
              %h3 Environmental effects
              %p What, if any, environmental side effects this function causes. 'None.' for none.
              %h3 Return Codes
              %p
                0 if ...
                1 if ...
              %h3 Failure Scenarios
              %p Fails if ...
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ {{ setup the scenario }}
                    user$ function_name {{ parameters }}
                    user$ {{ demonstrate the results}}
            %td.code
              .highlight
                %pre
                  files_under
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "find" do
                    %span.k if
                  %span.s2 &quot;${_path}&quot;
                  \-mindepth 1 -type f
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;'${_path}' is not a directory!&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Directory name/path was not given!&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                files
                %em> in
                path_matching
              %p Find all files in given path matching a given name glob pattern.
              %h3 Input Parameters
              %p
                First parameter is the path to search in
                Second parameter is the pattern to match in
              %h3 Stream Outputs
              %p What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
              %h3 Environmental effects
              %p What, if any, environmental side effects this function causes. 'None.' for none.
              %h3 Return Codes
              %p
                0 if ...
                1 if ...
              %h3 Failure Scenarios
              %p Fails if ...
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ files_in_path_matching ...
            %td.code
              .highlight
                %pre
                  files_in_path_matching
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb                   %span.nv _pattern
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb                   %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_pattern}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "find" do
                    %span.k if
                  %span.s2 &quot;${_path}&quot;
                  \-mindepth 1 -iname
                  %span.s2 &quot;${_pattern}&quot;
                  \-type f
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot find files as a filename or pattern was not given.&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;'${_path}' is not a directory!&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Directory name/path was not given!&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 replace_content
              %p
                Replaces a given (sed compatable) pattern with given replacement text in a
                file.
              %h3 Input Parameters
              %p
                First parameter is the pattern
                [optional 'with']
                Second parameter is the replacement content
                [optional 'in']
                Third parameter is the file name/path
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                The pattern will be matched against the file name/path content and the
                replacement text will be put in place.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no pattern was given
                Fails if replacement content was not given
                Fails if filename was not given
                Fails if the file does not exist
              %h3 Usage Examples
              %h1 Replace contents in a file with a given (sed) regex pattern.
              %pre
                %code
                  :preserve
                    replace_content "^PREFIX =.*" with "${install_path}" in Makefile
            %td.code
              .highlight
                %pre
                  replace_content
                  %span.o ()
                  %span.o {
                  = succeed "_token" do
                    %span.nb local
                  _pattern _content _file _message
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv _token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${_token}&quot;
                  in
                  = succeed "with" do
                    %span.o (
                  %span.o )
                  %span.nv _content
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.nb shift
                  ;;
                  = succeed "in" do
                    %span.o (
                  %span.o )
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  = succeed "*" do
                    %span.o (
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_pattern}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _pattern
                  %span.o =
                  %span.s2 &quot;${_token}&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Unknown token '${_token}' passed as a parameter.'&quot;
                  %span.k fi
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_pattern:-}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_content:-}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file:-}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-f
                  %span.s2 &quot;${_file:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "sed" do
                    %span.k if
                  \-i -e
                  %span.s2 &quot;s#${_pattern//\#/\\#}#${_content//\#/\\#}#g&quot;
                  %span.s2 &quot;${_file}&quot;
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Can not replace file content as the file does not exist.&quot;
                  %span.k fi
                  %span.k else
                  %span.k                   %span.nv _message
                  %span.o =(
                  %span.s2 &quot;Can not file content as the filename was not given,&quot;
                  %span.s2 &quot; specify by 'in \&quot;/path/to/filename\&quot;'&quot;
                  %span.o )
                  fail
                  %span.s2 &quot;${_message[*]}&quot;
                  %span.k fi
                  %span.k else
                  %span.k                   %span.nv _message
                  %span.o =(
                  %span.s2 &quot;Cannot replace content as the replacement content was not given, &quot;
                  %span.s2 &quot;specify by 'with \&quot;replacement text\&quot;'.&quot;
                  %span.o )
                  fail
                  %span.s2 &quot;${_message[*]}&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot replace content as not even a pattern was given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                file
                %em> matches
                md5
              %p Checks to see if the given file matches the given md5 sum.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the file matches the md5sum
                1 if the file does not match the md5sum
                1 if the file is empty or missing
              %h3 Failure Scenarios
              %p
                Fails if no file name/path was given.
                Fails if no md5 string was given.
              %h3 Usage Examples
              %p Example Usage:
              %p
                user$ file
                %em> matches
                md5
              %h3 Notes
            %td.code
              .highlight
                %pre
                  file_matches_md5
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nv _md5
                  %span.o =
                  %span.s2 &quot;$2&quot;
                  _file_md5
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_md5}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-s
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _file_md5
                  %span.o =
                  %span.s2 &quot;$(file_md5 &quot;
                  %span.k ${
                  %span.nv _file
                  %span.k }
                  %span.s2 &quot;)&quot;
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;${_file_md5// *}&quot;
                  %span.o =
                  %span.s2 &quot;$_md5&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot determine if file matches md5 as no md5 was given.&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot determine if file matches md5 as no file was given.&quot;
                  %span.k fi
                  %span.o }
                  extract_archive
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _archive
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_archive}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k case
                  %span.s2 &quot;${_archive}&quot;
                  in
                  *.tar.gz|*.tgz
                  %span.o )
                  %span.c # gzip
                  %span.k if
                  \! tar zxf
                  %span.s2 &quot;${_archive}&quot;
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;There was an error while extracting the archive '${_archive}'&quot;
                  %span.k fi
                  ;;
                  *tar.xz
                  %span.o )
                  %span.c # LZMA
          %tr
            %td.docs
              %p TODO: if 'xz' command exists, use that, otherwise use tar J
            %td.code
              .highlight
                %pre
                  %span.k if
                  \! tar Jxf
                  %span.s2 &quot;${_archive}&quot;
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;There was an error while extracting the archive '${_archive}'&quot;
                  %span.k fi
                  ;;
                  *.tar.bz2
                  %span.o )
                  %span.c # bzip
                  %span.k if
                  \! tar jxf
                  %span.s2 &quot;${_archive}&quot;
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;There was an error while extracting the archive '${_archive}'&quot;
                  %span.k fi
                  ;;
                  *.zip
                  %span.o )
                  %span.k if
                  \! unzip
                  %span.s2 &quot;${_archive}&quot;
                  \-d
                  %span.s2 &quot;${_path:-}&quot;
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;There was an error while extracting the archive '${_archive}'&quot;
                  %span.k fi
                  ;;
                  *
                  %span.o )
                  error
                  %span.s2 &quot;Unknown archive format for ${_archive}&quot;
                  ;;
                  %span.k esac
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot extract an archive to target location as no archive was given.&quot;
                  %span.k fi
                  %span.o }
                  file_md5
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _command _md5
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "os_is_darwin" do
                    %span.k if
                  %span.k then
                  %span.k                   %span.nv _command
                  %span.o =
                  %span.s2 &quot;/sbin/md5 -q&quot;
                  %span.k else
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;md5sum&quot;
                  %span.k then
                  %span.k                   %span.nv _command
                  %span.o =
                  %span.s2 &quot;md5sum&quot;
                  = succeed "command_exists" do
                    %span.k elif
                  md5
                  %span.k then
                  %span.k                   %span.nv _command
                  %span.o =
                  %span.s2 &quot;md5&quot;
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Could not find a suitable md5 command in the path.&quot;
                  %span.k fi
                  %span.k fi
                  %span.k if
                  %span.nv _md5
                  %span.o =
                  %span.s2 &quot;$(${_command} &quot;
                  %span.nv $_file
                  %span.s2 &quot; 2&gt;/dev/null)&quot;
                  %span.k then
                  %span.k                   %span.nb printf
                  %span.s2 &quot;${_md5// *}&quot;
                  %span.k else
                  %span.c # Should this be error ?
                  warn
                  %span.s2 &quot;There was an unknown error computing the md5&quot;
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot calculate md5 of a file as no file name/path was given.&quot;
                  %span.k fi
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 show_help()
              %p
                Display help for the current extension based on settings declared in the help
                action.
              %h3 Input Parameters
              %p First parameter is the help section to display, default is all sections 'usage'.
              %h3 Stream Outputs
              %p Prints out formatted help sections to the calling environments STDOUT stream.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ show_help usage
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  show_help
                  %span.o ()
                  %span.o {
                  = succeed "_help_command" do
                    %span.nb local
                  _token
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  ;
                  %span.k do
                  %span.k                   %span.nv _token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  ;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${_token}&quot;
                  in
                  desc*|description
                  %span.o )
                  %span.nv _help_command
                  %span.o =
                  %span.s2 &quot;description&quot;
                  ;;
                  actions
                  %span.o )
                  %span.nv _help_command
                  %span.o =
                  %span.s2 &quot;actions&quot;
                  ;;
                  usage
                  %span.o )
                  %span.nv _help_command
                  %span.o =
                  %span.s2 &quot;usage&quot;
                  ;;
                  %span.k esac
                  %span.k done
                  %span.s2 &quot;${_help_command:-usage}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 description()
              %p Set the string that will be printed when the actions help section is output.
              %h3 Input Parameters
              %p First parameter is a string containing a description of the extension.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Fails if no description is given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ description "This extension handles X Y and Z."
            %td.code
              .highlight
                %pre
                  description
                  %span.o ()
                  %span.o {
                  %span.o [[
                  \-n
                  %span.s2 &quot;$*&quot;
                  %span.o ]]
                  %span.o ||
                  fail
                  %span.s2 &quot;Cannot add description to help as no help description was given.&quot;
                  help_descriptions+
                  %span.o =(
                  %span.s2 &quot;$*&quot;
                  %span.o )
                  %span.o }
          %tr
            %td.docs
              %h2 help_description()
              %p Outputs the collected help description.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Prints the help description output.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p None.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ description "This extension handles X Y and Z."
            %td.code
              .highlight
                %pre
                  help_description
                  %span.o ()
                  %span.o {
                  = succeed "_description" do
                    %span.nb local
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv help_descriptions
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "help_section" do
                    %span.k                   %span.s2 &quot;Description&quot;
                  = succeed "_description" do
                    %span.k for
                  in
                  %span.s2 &quot;${help_descriptions[@]}&quot;
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot;  %s\n&quot;
                  %span.s2 &quot;${_description}&quot;
                  %span.k done
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 actions()
              %p Set the string that will be printed when the actions help section is output.
              %h3 Input Parameters
              %p First parameter is a string of the action descriptions.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Fails if no actions are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ actions "install  - Installs the extension..."
            %td.code
              .highlight
                %pre
                  actions
                  %span.o ()
                  %span.o {
                  %span.o [[
                  \-n
                  %span.s2 &quot;$*&quot;
                  %span.o ]]
                  %span.o ||
                  fail
                  %span.s2 &quot;No help actions were given.&quot;
                  warn
                  %span.s2 &quot;help actions() is depreciated, use action() instead for each action.&quot;
                  %span.nv help_actions
                  %span.o =
                  %span.s2 &quot;$*&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 action()
              %p Adds an action definition for help output.
              %h3 Input Parameters
              %p
                First parameter is the name of the extension action
                Second parameter is the description of the extension action
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p The action description will be stored for use on help output.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if an action name is not given.
                Fails if a description is not provided.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ action "install"  "Installs the extension..."
            %td.code
              .highlight
                %pre
                  action
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _name
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.nb local
                  %span.nv _description
                  %span.o =
                  %span.s2 &quot;${2:-}&quot;
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_name}&quot;
                  %span.o &amp;&amp;
                  \-n
                  %span.s2 &quot;${_description}&quot;
                  %span.o ]]
                  %span.o ||
                  fail
                  %span.s2 &quot;An action and a description must be provided:\naction {name} {description}&quot;
                  help_action_names+
                  %span.o =(
                  %span.s2 &quot;${_name}&quot;
                  %span.o )
                  help_action_descriptions+
                  %span.o =(
                  %span.s2 &quot;${_description}&quot;
                  %span.o )
                  %span.o }
          %tr
            %td.docs
              %h2 note()
              %p Adds a note definition for help Notes section.
              %h3 Input Parameters
              %p
                First parameter is a string containing any note for the notes section of
                the current extension's help output.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ note "Help for this extension can be found in #beginrescueend on irc.freenode.net"
            %td.code
              .highlight
                %pre
                  note
                  %span.o ()
                  %span.o {
                  help_notes+
                  %span.o =(
                  %span.s2 &quot;$*&quot;
                  %span.o )
                  %span.o }
          %tr
            %td.docs
              %h2 dependencies()
              %p Specify content for the dependencies section of the help command.
              %h3 Input Parameters
              %p
                First parameter is a string containing any dependencies for the dependencies
                section of the current extension's help output.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ dependencies " * pcre"
            %td.code
              .highlight
                %pre
                  dependencies
                  %span.o ()
                  %span.o {
                  %span.nv help_dependencies
                  %span.o =
                  %span.s2 &quot;$*&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 resource()
              %p Add a resource for the Resources section of the help command.
              %h3 Input Parameters
              %p
                First parameter is a string containing any resources for the resources
                section of the current extension's help output.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ resource "website: ..."
            %td.code
              .highlight
                %pre
                  resource
                  %span.o ()
                  %span.o {
                  help_resources+
                  %span.o =(
                  %span.s2 &quot;$*&quot;
                  %span.o )
                  %span.o }
          %tr
            %td.docs
              %h2 help_actions()
              %p
                Outputs the help actions in a formatted manner.
                Outputs a message if there are no actions.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                Prints a formatted listing of the actions and their descriptions to the
                calling environments STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat $HOME/test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules help
                    
                    action "help" "Displays the help output for the ${extension} extension"
                    action "install" "Installs Z redis package"
                    action "uninstall" "Uninstalls Z redis package"
                    
                    help_actions
                    
                    user$ "$HOME/test"
                    help      - Displays the help output for the redis extension
                    install   - Installs Z redis package
                    uninstall - Uninstalls Z redis package
            %td.code
              .highlight
                %pre
                  help_actions
                  %span.o ()
                  %span.o {
                  = succeed "_largest" do
                    %span.nb local
                  _index
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv help_action_names
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nv _largest
                  %span.o =
                  %span.k $(
                  array_largest help_action_names
                  %span.k )
                  %span.c # Use the array DSL to grab largest
                  %span.nv _largest
                  %span.o =
                  %span.k $((
                  %span.k ${#
                  %span.nv _largest
                  %span.k }
                  %span.o +
                  %span.m 1
                  %span.k ))
                  help_section
                  %span.s2 &quot;Actions&quot;
                  %span.k for
                  %span.o ((
                  %span.nv _index
                  = succeed "0" do
                    %span.o =
                  ; _index &lt;
                  %span.k ${#
                  %span.nv help_action_names
                  %span.p [@]
                  %span.k }
                  ; _index++
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot;  %-$((_largest + 2))s - %s\n&quot;
                  %span.se \
                  %span.s2 &quot;${help_action_names[${_index}]}&quot;
                  %span.s2 &quot;${help_action_descriptions[${_index}]}&quot;
                  %span.k done
                  %span.k else
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;# No help has been defined for ${extension} actions .&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 help_notes()
              %p
                Outputs the help notes in a formatted manner.
                Outputs a message if there are no notes.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Prints a formatted listing of the notes to the calling environments STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat $HOME/test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules help
                    
                    note "Don't forget the milk! "
                    note "... and cookies... mmm...."
                    
                    help_notes
                    
                    user$ "$HOME/test"
                    * Don't forget the milk!
                    * ... and cookies... mmm....
            %td.code
              .highlight
                %pre
                  help_notes
                  %span.o ()
                  %span.o {
                  = succeed "_index" do
                    %span.nb local
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv help_notes
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "help_section" do
                    %span.k                   %span.s2 &quot;Notes&quot;
                  %span.k for
                  %span.o ((
                  %span.nv _index
                  = succeed "0" do
                    %span.o =
                  ; _index &lt;
                  %span.k ${#
                  %span.nv help_notes
                  %span.p [@]
                  %span.k }
                  ; _index++
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot;  * %s\n&quot;
                  %span.s2 &quot;${help_notes[${_index}]}&quot;
                  %span.k done
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 help_dependencies()
              %p Outputs the help dependencies in a formatted manner.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                Prints a formatted listing of the current extensions defined dependencies to
                the calling environments STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
            %td.code
              .highlight
                %pre
                  help_dependencies
                  %span.o ()
                  %span.o {
                  = succeed "_index" do
                    %span.nb local
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv help_dependencies
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "help_section" do
                    %span.k                   %span.s2 &quot;Dependencies&quot;
                  %span.k for
                  %span.o ((
                  %span.nv _index
                  = succeed "0" do
                    %span.o =
                  ; _index &lt;
                  %span.k ${#
                  %span.nv help_dependencies
                  %span.p [@]
                  %span.k }
                  ; _index++
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot; * %s\n&quot;
                  %span.s2 &quot;${help_dependencies[${_index}]}&quot;
                  %span.k done
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 help_resources()
              %p
                Outputs the help notes in a formatted manner.
                Outputs a message if there are no notes.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                Prints a formatted listing of the defined resources to the calling
                environments STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
            %td.code
              .highlight
                %pre
                  help_resources
                  %span.o ()
                  %span.o {
                  = succeed "_index" do
                    %span.nb local
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv help_resources
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "help_section" do
                    %span.k                   %span.s2 &quot;Resources&quot;
                  %span.k for
                  %span.o ((
                  %span.nv _index
                  = succeed "0" do
                    %span.o =
                  ; _index &lt;
                  %span.k ${#
                  %span.nv help_resources
                  %span.p [@]
                  %span.k }
                  ; _index++
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot; * %s\n&quot;
                  %span.s2 &quot;${help_resources[${_index}]}&quot;
                  %span.k done
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 help_section()
              %p Displays a help section header.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Prints the given string as a help section header.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ help_section Usage
            %td.code
              .highlight
                %pre
                  help_section
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;\n$*\n&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 help_usage()
              %p Display the CLI signature.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Prints the CLI command signature.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ help_usage
                    bdsm core {action} [arguments...]
            %td.code
              .highlight
                %pre
                  help_usage
                  %span.o ()
                  %span.o {
                  help_section
                  %span.s2 &quot;Usage&quot;
                  log
                  %span.s2 &quot;  bdsm ${extension} {action} [arguments...]&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 usage()
              %p Display the usage help output of the command. This displays all help sections.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Prints all help sections to the STDOUT of the calling environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ usage
            %td.code
              .highlight
                %pre
                  usage
                  %span.o ()
                  %span.o {
                  bdsm_version
                  
                  log
                  %span.s2 &quot;\nbdsm ${bdsm_version} https://bdsm.beginrescueend.com/ by Wayne E. Seguin (wayneeseguin@gmail.com)&quot;
                  %span.nv sections
                  = succeed "usage" do
                    %span.o =(
                  description actions notes dependencies resources
                  %span.o )
                  = succeed "section" do
                    %span.k for
                  in
                  %span.s2 &quot;${sections[@]}&quot;
                  %span.k do
                  %span.s2 &quot;help_${section}&quot;
                  %span.k done
                  %span.k case
                  %span.s2 &quot;${extension}&quot;
                  in
                  ext|extension|extend
                  %span.o )
                  help_section
                  %span.s2 &quot;Installed Extensions&quot;
                  %span.nb printf
                  %span.s2 &quot;  &quot;
                  extensions_installed
                  %span.nb echo
                  = succeed "help_section" do
                    %span.nb                   %span.s2 &quot;Available Extensions&quot;
                  %span.nb printf
                  %span.s2 &quot;  &quot;
                  extensions_available
                  %span.nb echo
                  ;;
                  %span.k esac
                  %span.k                   %span.nb echo
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2
                shell
                %em> is
                interactive()
              %p Test if the current shell is an interactive shell.
              %p Usage Examples:
              %pre
                %code
                  :preserve
                    if shell_is_interactive
                    then
                      ${PAGER} somefile
                    else
                      cat -v somefile
                    fi
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  shell_is_interactive
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o [[
                  \-t 0
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
                  = succeed "shell_is_interactive" do
                    %span.k if
                  %span.k then
                  %span.k                   %span.nb true
                  %span.c # Interactive functions will be loaded here, only if shell is interactive.
                  %span.k fi
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 log()
              %p Log arguments to the calling environments STDOUT.
              %h3 Input Parameters
              %p Strings to be logged.
              %h3 Stream Outputs
              %p
                Prints arguments passed in to the calling environments STDOUT with a newline
                character appended.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no arguments are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ log "Hello there! "
                    Hello there!
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  log
                  %span.o ()
                  %span.o {
                  = succeed "_token" do
                    %span.nb local
                  _file _message
                  %span.nv _append_flag
                  = succeed "0" do
                    %span.o =
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv _token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${_token}&quot;
                  in
                  = succeed "append|--append" do
                    %span.o (
                  %span.o )
                  %span.nv _append_flag
                  = succeed "1" do
                    %span.o =
                  ;;
                  = succeed "to" do
                    %span.o (
                  %span.o )
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  = succeed "*" do
                    %span.o (
                  %span.o )
                  %span.nv _message
                  %span.o =
                  %span.s2 &quot;${_token}&quot;
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_message:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot log a message as no message was given.&quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o ((
                  %span.nv _append_flag
                  %span.o ==
                  1
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nb printf
                  %span.s2 &quot;${_message}\n&quot;
                  \&gt;&gt;
                  %span.s2 &quot;${_file}&quot;
                  %span.k else
                  %span.k                   %span.nb printf
                  %span.s2 &quot;${_message}\n&quot;
                  \&gt;
                  %span.s2 &quot;${_file}&quot;
                  %span.k fi
                  %span.k else
                  %span.k                   %span.nb printf
                  %span.s2 &quot;${_message}\n&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 info()
              %p Log arguments to the calling environments STDOUT preceeded by 'INFO .
              %h3 Input Parameters
              %p Strings to be logged.
              %h3 Stream Outputs
              %p
                Prints arguments passed in to the calling environments STDOUT with a newline
                character appended and 'INFO ' prepended.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no arguments are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ info "Hello there! "
                    INFO Hello there!
            %td.code
              .highlight
                %pre
                  info
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;INFO: $*&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 warn()
              %p Log arguments to the calling environments STDOUT preceeded by 'WARNING .
              %h3 Input Parameters
              %p Strings to be logged.
              %h3 Stream Outputs
              %p
                Prints arguments passed in to the calling environments STDOUT with a newline
                character appended and 'WARNING ' prepended.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no arguments are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ info "Bad Monkeys are Typing! "
                    WARNING: Bad Monkeys are Typing!
            %td.code
              .highlight
                %pre
                  warn
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;WARNING: $*&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 note()
              %p Log arguments to the calling environments STDOUT preceeded by 'NOTE .
              %h3 Input Parameters
              %p Strings to be logged.
              %h3 Stream Outputs
              %p
                Prints arguments passed in to the calling environments STDOUT with a newline
                character appended and 'NOTE ' prepended.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no arguments are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ info "You are not Smurfette! "
                    NOTE You are not Smurfette!
            %td.code
              .highlight
                %pre
                  note
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;NOTE: $*&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 debug()
              %p Log arguments to the calling environments STDOUT preceeded by 'DEBUG: .
              %h3 Input Parameters
              %p Strings to be logged.
              %h3 Stream Outputs
              %p
                Prints arguments passed in to the calling environments STDOUT with a newline
                character appended and 'DEBUG: ' prepended.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no arguments are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ debug "Hello there! "
                    DEBUG: Hello there!
            %td.code
              .highlight
                %pre
                  debug
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o ((
                  %span.k ${
                  %span.nv debug_flag
                  %span.p :=0
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;DEBUG: $*&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 error()
              %p
                Log arguments to the calling environments STDERR preceeded by 'ERROR '.
                Exits with status code 1.
              %h3 Input Parameters
              %p Strings to be logged.
              %h3 Stream Outputs
              %p
                Prints arguments passed in to the calling environments STDOUT with a newline
                character appended and 'ERROR ' prepended.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 1 for failure.
              %h3 Failure Scenarios
              %p Fails if no arguments are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ error "Hello there! "
                    ERROR Hello there!
                    *poof* shell closed...
            %td.code
              .highlight
                %pre
                  error
                  %span.o ()
                  %span.o {
                  %span.nb set
                  +o xtrace
                  log
                  %span.s2 &quot;\nERROR: $*&quot;
                  \&gt;&amp;2
                  disable_backtrace
                  = succeed "1" do
                    %span.nb exit
                  %span.o }
          %tr
            %td.docs
              %h2 succeed()
              %p Log arguments to the calling environments STDOUT. Exits with status code 0.
              %h3 Input Parameters
              %p Strings to be logged.
              %h3 Stream Outputs
              %p
                Prints arguments passed in to the calling environments STDOUT with a newline
                character appended.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no arguments are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ succeed "Hello there! "
                    Hello there!
                    *poof* shell closed...
            %td.code
              .highlight
                %pre
                  succeed
                  %span.o ()
                  %span.o {
                  %span.nb set
                  +o xtrace
                  log
                  %span.s2 &quot;$*&quot;
                  = succeed "0" do
                    %span.nb exit
                  %span.o }
          %tr
            %td.docs
              %h2 fail()
              %p
                Log arguments to the calling environments STDERR preceeded by 'ERROR '.
                Exits with status code 1.
              %h3 Input Parameters
              %p Strings to be logged.
              %h3 Stream Outputs
              %p
                Prints arguments passed in to the calling environments STDOUT with a newline
                character appended and 'ERROR ' prepended.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 1 for failure.
              %h3 Failure Scenarios
              %p Fails if no arguments are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ error "Hello there! "
                    ERROR Hello there!
                    *poof* shell closed...
            %td.code
              .highlight
                %pre
                  fail
                  %span.o ()
                  %span.o {
                  %span.nv trace_flag
                  = succeed "0" do
                    %span.o =
                  backtrace
                  %span.s2 &quot;$*&quot;
                  = succeed "1" do
                    %span.nb exit
                  %span.o }
          %tr
            %td.docs
              %h2 verbose()
              %p
                Log arguments to the calling environments STDERR preceeded by 'ERROR '.
                Exits with status code 1.
              %h3 Input Parameters
              %p Strings to be logged.
              %h3 Stream Outputs
              %p
                Prints arguments passed in to the calling environments STDOUT with a newline
                character appended and 'ERROR ' prepended.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 1 for verboseure.
              %h3 verboseure Scenarios
              %p verboses if no arguments are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ verbose "w00t! "
                    user$ verbose_flag=1
                    user$ verbose "w00t! "
                    w00t!
            %td.code
              .highlight
                %pre
                  verbose
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o ((
                  %span.k ${
                  %span.nv verbose_flag
                  %span.p :=0
                  %span.k }
                  %span.o ==
                  1
                  %span.o ))
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;$*&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 logrotate()
              %p Strategically rotate a logfile minimizing data loss.
              %p This function uses a copy, tail and truncate strategy.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    root# logrotate /var/log/my_logfile.log
            %td.code
              .highlight
                %pre
                  logrotate
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot rotate a log file as no log file was given.&quot;
                  %span.k fi
                  = succeed "set_timestamp" do
                    %span.k                   verbose
                  %span.s2 &quot;Tailing the file in a background process into a tail logfile.&quot;
                  %span.o (
                  tail -n 0 -f
                  %span.s2 &quot;${_file}&quot;
                  \&gt;
                  %span.k ${
                  %span.nv file
                  = succeed "." do
                    %span.k }
                  = succeed ".log" do
                    %span.nv $$
                  = succeed "&amp;amp;" do
                    %span.o )
                  %span.nb local
                  %span.nv _tail_pid
                  %span.o =
                  %span.nv $!
                  verbose
                  %span.s2 &quot;Copying the file's contentes into a new timestamped file.&quot;
                  cp
                  %span.s2 &quot;${_file}&quot;
                  %span.s2 &quot;${_file}.${timestamp}&quot;
                  verbose
                  %span.s2 &quot;Truncating the file.&quot;
                  cp /dev/null
                  %span.k ${
                  %span.nv _file
                  %span.k }
                  verbose
                  %span.s2 &quot;Signaling the tail background process to stop.&quot;
                  %span.nb kill
                  \-QUIT
                  %span.k ${
                  %span.nv _tail_pid
                  %span.k }
                  verbose
                  %span.s2 &quot;Appending the tail logfile to the new timestamped logfile.&quot;
                  cat
                  %span.s2 &quot;${file}.$$.log&quot;
                  \&gt;&gt;
                  %span.s2 &quot;${file}.${timestamp}&quot;
                  verbose
                  %span.s2 &quot;Compressing the timestamped file (gzip)&quot;
                  gzip -f -9
                  %span.s2 &quot;${file}.${timestamp}&quot;
                  verbose
                  %span.s2 &quot;Removing the tail logfile&quot;
                  rm
                  %span.s2 &quot;${file}.$$.log&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 log_streams()
              %p
                Log streams to three files:
                \- standard out
                \- standard in
                \- combined (what the user typically sees)
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    root# log_streams "make install" prefix make
                    cat make.out.log
                    root#
                    ...
              %p Alternatively,
              %pre
                %code
                  :preserve
                    root# log_streams "make install" \
                          out /path/to/out.log \
                          err /path/to/err.log \
                          mix /path/to/mix.log # both out &amp; err as they occurred.
                    root# cat /path/to/mix.log
                    ...
            %td.code
              .highlight
                %pre
                  log_streams
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _command
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _prefix _err _out _mix
          %tr
            %td.docs
              %p TODO: allow specification of path, name prefix
            %td.code
              .highlight
                %pre
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv _token
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${token}&quot;
                  in
                  prefix
                  %span.o )
                  %span.nv _prefix
                  %span.o =
                  %span.s2 &quot;${1}.&quot;
                  ;;
                  err
                  %span.o )
                  %span.nv _stderr
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  out
                  %span.o )
                  %span.nv _stdout
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  mix
                  %span.o )
                  %span.nv _stdmix
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  *
                  %span.o )
                  %span.nv _command
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  %span.k esac
                  %span.k done
                  \:
                  %span.se \
                  %span.s2 &quot;${_stdout=&quot;
                  %span.k ${
                  %span.nv 2
                  %span.k :-
                  %span.nv stdout
                  %span.p .log
                  %span.k }
                  %span.s2 &quot;}&quot;
                  %span.se \
                  %span.s2 &quot;${_stderr=&quot;
                  %span.k ${
                  %span.nv 3
                  %span.k :-
                  %span.nv stderr
                  %span.p .log
                  %span.k }
                  %span.s2 &quot;}&quot;
                  %span.se \
                  %span.s2 &quot;${_stdmix=&quot;
                  %span.k ${
                  %span.nv 4
                  %span.k :-
                  %span.nv stdmix
                  %span.p .log
                  %span.k }
                  %span.s2 &quot;}&quot;
                  %span.o {
                  %span.o {
                  %span.k ${
                  %span.nv _command
                  %span.k }
                  2&gt;&amp;1 1&gt;&amp;3 | tee
                  %span.s2 &quot;${_stderr}&quot;
                  %span.o }
                  3&gt;&amp;1 1&gt;&amp;2 | tee
                  %span.s2 &quot;${_stdout}&quot;
                  %span.o }
                  \&gt;
                  %span.s2 &quot;${_stdmix}&quot;
                  2&gt;&amp;1
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 modules()
              %p Loads named BDSM modules into the calling environment.
              %h3 Input Parameters
              %p Positional Parameter listing and descriptions.
              %h3 Stream Outputs
              %p None, unless loading the module causes output to a stream.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no module names were given as parameters.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ modules array system
                    user$ modules_loaded
                    logging trace filesystem array system
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  modules
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o ((
                  trace_flag &lt; 2
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nb set
                  +o xtrace
                  %span.k fi
                  %span.k                   = succeed "_module" do
                    %span.nb local
                  _bdsm _extension _path _file
                  %span.nv _modules
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _modules
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;No modules specified to load.&quot;
                  %span.k fi
                  = succeed "_module" do
                    %span.k for
                  in
                  %span.s2 &quot;${_modules[@]}&quot;
                  %span.k do
                  = succeed "module_is_loaded" do
                    %span.k if
                  %span.s2 &quot;${_module}&quot;
                  %span.k then
                  %span.k continue
                  %span.c # The module has already been loaded, continue to the next one.
                  %span.k else
                  %span.k                   %span.nv _bdsm
                  %span.o =
                  %span.s2 &quot;${modules_path}/bash/${_module}&quot;
                  %span.nv _extension
                  %span.o =
                  %span.s2 &quot;${extension_modules_path}/bash/${_module}&quot;
                  = succeed "_path" do
                    %span.k for
                  in
                  %span.s2 &quot;${_bdsm}&quot;
                  %span.s2 &quot;${_extension}&quot;
                  %span.k do
                  = succeed "_file" do
                    %span.k for
                  in dsl initialize
                  %span.k do
                  %span.k if
                  %span.o [[
                  \-s
                  %span.s2 &quot;${_path}/${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb source
                  %span.s2 &quot;${_path}/${_file}&quot;
                  %span.k fi
                  %span.k done
                  %span.k done
                  = succeed "modules+" do
                    %span.k                   %span.o =(
                  %span.s2 &quot;${_module}&quot;
                  %span.o )
                  %span.k fi
                  %span.k done
                  %span.k if
                  %span.o ((
                  trace_flag &gt; 0
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nb set
                  \-o xtrace
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 module_load()
              %p Function Description
              %h3 Input Parameters
              %p Positional Parameter listing and descriptions.
              %h3 Stream Outputs
              %p None, unless loading the module causes output to a stream.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no extension module files names have been given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ ls ${extension_modules_path}/bash/
                    cli dsl initialize zebra
                    
                    user$ cat ${extension_modules_path}/bash/zebra
                    #!/usr/bin/env bash
                    echo "Zebra!!! "
                    
                    user$ module_load zebra # This will load zebra into the current context
                    Zebra!!!
            %td.code
              .highlight
                %pre
                  module_load
                  %span.o ()
                  %span.o {
                  = succeed "_file" do
                    %span.nb local
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot load a module as no module was given.&quot;
                  %span.k fi
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  = succeed "source_files" do
                    %span.k                   %span.s2 &quot;${extension_modules_path:-&quot;
                  %span.nv $modules_path
                  %span.s2 &quot;}/bash/${_file}&quot;
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2
                module
                %em> is
                loaded()
              %p Checks to see whether or not the named module has been loaded or not.
              %h3 Input Parameters
              %p First parameter is a module name.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p
                0 if the module has already been loaded
                1 if the module has not already been loaded
              %h3 Failure Scenarios
              %p Fails if no module name was given as the first parameter.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ module_is_loaded package
                    user$ echo $?
                    1
                    user$ modules package
                    user$ module_is_loaded package
                    0
            %td.code
              .highlight
                %pre
                  module_is_loaded
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _name
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_name}&quot;
                  %span.o ]]
                  %span.o ||
                  fail
                  %span.s2 &quot;Cannot determine if a module is loaded as no module was given.&quot;
                  %span.k case
                  %span.s2 &quot; ${modules[@]} &quot;
                  in
                  = succeed "*" do
                    %span.o (
                  = succeed ":space:" do
                    %span.o [[
                  %span.o ]]
                  %span.k ${
                  %span.nv _name
                  %span.k }
                  = succeed ":space:" do
                    %span.o [[
                  = succeed "*" do
                    %span.o ]]
                  %span.o )
                  = succeed "0" do
                    %span.k return
                  ;;
                  = succeed "*" do
                    %span.o (
                  %span.o )
                  = succeed "1" do
                    %span.k return
                  ;;
                  %span.k esac
                  %span.o }
          %tr
            %td.docs
              %h2 modules_loaded()
              %p Outputs a list of all modules that have been loaded.
              %h3 Input Parameters
              %p Positional Parameter listing and descriptions.
              %h3 Stream Outputs
              %p
                Prints a space separated list of all loaded modules to the STDOUT stream of
                the calling environment.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ modules_loaded
                    logging trace filesystem
            %td.code
              .highlight
                %pre
                  modules_loaded
                  %span.o ()
                  %span.o {
                  %span.nb printf
                  %span.s2 &quot;${modules[@]}\n&quot;
                  %span.o }
          %tr
            %td.docs
              %p Print out a list of all installed modules.
            %td.code
              .highlight
                %pre
                  modules_installed
                  %span.o ()
                  %span.o {
                  = succeed "_module" do
                    %span.nb local
                  %span.nb local
                  %span.nv _module_type
                  %span.o =
                  = succeed "bash" do
                    %span.s2 &quot;${1:-&quot;
                  %span.s2 &quot;}&quot;
                  %span.nb local
                  %span.nv _modules
                  %span.o =(
                  = succeed "find" do
                    %span.k $(
                  %span.s2 &quot;${modules_path}/${_module_type}&quot;
                  \-mindepth 1 -maxdepth 1 -type d | sed -e
                  %span.s1 's#.*/##g'
                  \-e
                  %span.s1 '/\..*/d'
                  %span.k )
                  %span.o )
                  = succeed "_module" do
                    %span.k for
                  in
                  %span.k ${
                  %span.nv _modules
                  %span.p [@]
                  %span.k }
                  ;
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot;%s\n&quot;
                  %span.s2 &quot;${_module}&quot;
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 module_dsl()
              %p Print out a list of all dsl for the given module.
              %h3 Input Parameters
              %p First parameter is the module name to print out the dsl for.
              %h3 Stream Outputs
              %p
                The named module's DSL function listing will is printed to the calling
                environments STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no module name was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ module_dsl defaults
                    read_default()
            %td.code
              .highlight
                %pre
                  module_dsl
                  %span.o ()
                  %span.o {
                  = succeed "_function" do
                    %span.nb local
                  _dsl
                  %span.nv _modules
                  %span.o =
                  %span.s2 &quot;${@:-}&quot;
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _modules
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot print the DSL for module(s) as no module names were given.&quot;
                  %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${modules_path}/bash/${_module}&quot;
                  %span.nv _dsl
                  %span.o =(
                  = succeed "find" do
                    %span.k $(
                  %span.s2 &quot;${_path}&quot;
                  \-mindepth 1 -maxdepth 1 -name dsl -type f -print0 | xargs -0 grep
                  %span.s1 '^[a-z_]*()$'
                  2&gt;/dev/null
                  %span.o ||
                  %span.nb true
                  %span.k )
                  %span.o )
                  = succeed "_function" do
                    %span.k for
                  in
                  %span.s2 &quot;${_dsl[@]}&quot;
                  %span.k do
                  %span.k                   %span.nv _function
                  %span.o =
                  %span.s2 &quot;${_function##*modules\/bash\/}&quot;
                  %span.nb printf
                  %span.s2 &quot;%s\n&quot;
                  %span.s2 &quot;${_function//*:}&quot;
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 modules_list()
              %p Lists dsl for all modules.
              %h3 Input Parameters
              %p First parameter is the module name to print out the dsl for.
              %h3 Stream Outputs
              %p
                DSL function listing for each module is printed to the STDOUT of the calling
                environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ modules_list
                    array
                    
                      array_is_nonempty()
                      array_length()
                      array_last_element()
                      array_first_element()
                      array_push()
                      array_append()
                      array_shift()
                      array_unshift()
                      array_join()
                    ... longish output ...
            %td.code
              .highlight
                %pre
                  modules_list
                  %span.o ()
                  %span.o {
                  = succeed "_module" do
                    %span.nb local
                  _modules _function _dsl
                  = succeed "language" do
                    %span.k for
                  in bash ruby
                  %span.k do
                  %span.k                   %span.nv _modules
                  %span.o =(
                  = succeed "modules_installed" do
                    %span.k $(
                  %span.k ${
                  %span.nv language
                  %span.k })
                  %span.o )
                  = succeed "_module" do
                    %span.k for
                  in
                  %span.s2 &quot;${_modules[@]}&quot;
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot;\n%s\n\n&quot;
                  %span.s2 &quot;${_module}&quot;
                  %span.nv _dsl
                  %span.o =(
                  = succeed "module_dsl" do
                    %span.k $(
                  %span.s2 &quot;${_module}&quot;
                  %span.k )
                  %span.o )
                  = succeed "_function" do
                    %span.k for
                  in
                  %span.s2 &quot;${_dsl[@]}&quot;
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot;%s\n&quot;
                  %span.s2 &quot;  ${_function}&quot;
                  %span.k done
                  %span.k done
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 modules_docs()
              %p Output the module DSL documentation for a given module name.
              %h3 Input Parameters
              %p First parameter is the module name to print out the dsl documentation for.
              %h3 Stream Outputs
              %p DSL documentation for every function of the named module.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no module name is given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ module_docs defaults
                    
                    # read_default
                    
                    Reads default values from an extension's config/defaults file.
                    
                    ### Input Parameters
                    
                    First parameter is the defaults file key to read (key=value).
                    Second parameter is the variable name to store the retrieved value in.
                    Remaining parameters are parsed out as token, value and prefix
                      into|as &lt;variable name&gt;
                      prefix &lt;name&gt;
                      &lt;variable&gt; # If no specifier.
                    
                    ### Stream Outputs
                    
                    None.
                    
                    ### Environmental effects
                    
                    A variable will be set to the value, if the value is nonempty. If no variable
                    name is specified the variable will be assigned the same name as the key.
                    
                    ### Return Codes
                    
                    0 for success.
                    
                    ### Failure Scenarios
                    
                    Fails if no arguments are passed in, at least need to specify a key.
                    
                    ### Usage Examples
                    
                        user$ read_default "version" prefix "package" # extension is nginx for example
                        user$ echo $package_version
                        1.0.0
            %td.code
              .highlight
                %pre
                  module_docs
                  %span.o ()
                  %span.o {
                  = succeed "_function" do
                    %span.nb local
                  _dsl _module content_flag table_flag
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${token}&quot;
                  in
                  \--content
                  %span.o )
                  %span.nv content_flag
                  = succeed "1" do
                    %span.o =
                  ;;
                  \--table
                  %span.o )
                  %span.nv table_flag
                  = succeed "1" do
                    %span.o =
                  ;;
                  *
                  %span.o )
                  %span.nv _module
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_module}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${core_development_path}/modules/bash/${_module}&quot;
                  %span.k if
                  %span.o ((
                  %span.nv content_flag
                  %span.o ==
                  1
                  %span.o ))
                  %span.k then
                  = succeed "shocco" do
                    %span.k                   %span.s2 &quot;${_path}/dsl&quot;
                  | awk
                  %span.s1 '/&lt;body&gt;/{p=1;next;} /\/body&gt;/{p=0;next;} {if (p == 1) print ; } '
                  %span.k elif
                  %span.o ((
                  %span.nv table_flag
                  %span.o ==
                  1
                  %span.o ))
                  %span.k then
                  = succeed "shocco" do
                    %span.k                   %span.s2 &quot;${_path}/dsl&quot;
                  | awk
                  %span.s1 '/&lt;table/{p=1;} {if (p == 1) print ; } /\/table&gt;/{p=0;} '
                  %span.k else
                  = succeed "shocco" do
                    %span.k                   %span.s2 &quot;${_path}/dsl&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot glean documentation for a module as no module name was given&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 modules_docgen()
              %p Lists dsl for all modules.
              %h3 Input Parameters
              %p First parameter is the module name to print out the dsl for.
              %h3 Stream Outputs
              %p
                DSL function listing for each module is printed to the STDOUT of the calling
                environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ modules_list
                    array
                    
                      array_is_nonempty()
                      array_length()
                      array_last_element()
                      array_first_element()
                      array_push()
                      array_append()
                      array_shift()
                      array_unshift()
                      array_join()
                    ... longish output ...
            %td.code
              .highlight
                %pre
                  modules_docgen
                  %span.o ()
                  %span.o {
          %tr
            %td.docs
              %p
                TODO: Replace with,
                for file in modules/bash/
                %em> /dsl ; do (name=${file%%\/dsl}; shocco $file > html/${name//
                \\/}.html)&amp; done ; wait
            %td.code
              .highlight
                %pre
                  %span.nb> local
                  _module _modules _function _dsl
                  %span.nb local
                  %span.nv _prefix
                  %span.o =
                  %span.s2 &quot;${core_development_path}/html&quot;
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${site_development_path}&quot;
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${core_development_path}&quot;
                  %span.k then
                  %span.k                   %span.nv _modules
                  %span.o =(
                  %span.k $(
                  find
                  %span.s2 &quot;${core_development_path}/modules/bash&quot;
                  \-mindepth 1 -maxdepth 1
                  %span.se \
                  \-type d | sed -e
                  %span.s1 's#.*/##g'
                  \-e
                  %span.s1 '/\..*/d'
                  %span.k )
                  %span.o )
                  = succeed "_module" do
                    %span.k for
                  in
                  %span.s2 &quot;${_modules[@]}&quot;
                  %span.k do
                  %span.c #(
                  ensure_paths_exist
                  %span.s2 &quot;${_prefix}/${_module}&quot;
                  %span.nv _base
                  %span.o =
                  %span.s2 &quot;${_prefix}/${_module}/${_module}&quot;
                  log
                  %span.s2 &quot;Generating ${_base}.html&quot;
                  module_docs
                  %span.s2 &quot;${_module}&quot;
                  \&gt;
                  %span.s2 &quot;${_base}.html&quot;
                  html2haml
                  %span.s2 &quot;${_base}.html&quot;
                  %span.se \
                  \&gt;&gt;
                  %span.s2 &quot;${site_development_path}/content/modules/bash/${name}/dsl.haml&quot;
                  %span.c #)&amp;
                  %span.k done
                  %span.k                   %span.nb wait
                  = succeed "log" do
                    %span.nb                   %span.s2 &quot;Modules documentation content has been generated in ${_prefix}.&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Set core_development_path in ~/.bdsmrc in order to run docgen.&quot;
                  %span.k fi
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${site_development_path}&quot;
                  %span.k then
          %tr
            %td.docs
              %p Copy the generated files into the proper site content dir.
            %td.code
              .highlight
                %pre
                  %span.nv files
                  %span.o =(
                  = succeed "find" do
                    %span.k $(
                  %span.s2 &quot;${_prefix}&quot;
                  \-mindepth 1 -iname
                  %span.s1 '*.haml'
                  %span.k )
                  %span.o )
                  = succeed "file" do
                    %span.k for
                  in
                  %span.s2 &quot;${files[@]}&quot;
                  %span.k do
                  %span.o (
                  %span.nv name
                  %span.o =
                  %span.k ${
                  %span.nv file
                  %span.p ##*\/
                  %span.k }
                  %span.nv name
                  %span.o =
                  %span.k ${
                  %span.nv name
                  %span.p %.haml
                  %span.k }
                  ensure_paths_exist
                  %span.s2 &quot;${site_development_path}/content/modules/bash/${name}&quot;
                  log
                  %span.s2 &quot;Building ${name} dsl from generated docs.&quot;
                  cat &gt;
                  %span.s2 &quot;${site_development_path}/content/modules/bash/${name}/dsl.haml&quot;
                  %span.s &lt;&lt;Header
                  %span.s .breadcrumbs
                  %span.s %a{ :href =&gt; &quot;/&quot; }
                  %span.s Documentation
                  %span.s &amp;nbsp;&gt;&amp;nbsp;
                  %span.s %a{ :href =&gt; &quot;/modules/&quot; }
                  %span.s Modules
                  %span.s &amp;nbsp;&gt;&amp;nbsp;
                  %span.s %a{ :href =&gt; &quot;/modules/bash/&quot; }
                  %span.s Bash
                  %span.s &amp;nbsp;&gt;&amp;nbsp;
                  %span.s %a{ :href =&gt; &quot;/modules/bash/${name}/&quot; }
                  %span.s ${name}
                  %span.s &amp;nbsp;&gt;&amp;nbsp;
                  %span.s %a{ :href =&gt; &quot;/modules/bash/${name}/dsl/&quot; }
                  %span.s DSL API :: ${name}
                  %span.s %hr
                  %span.s %h1
                  %span.s Module ${name}
                  %span.s Header
                  cat
                  %span.nv $file
                  \&gt;&gt;
                  %span.s2 &quot;${site_development_path}/content/modules/bash/${name}/dsl.haml&quot;
                  = succeed "&amp;amp;" do
                    %span.o )
                  %span.k done
                  %span.k                   %span.nb wait
                  = succeed "log" do
                    %span.nb                   %span.s2 &quot;Module documentation has been generated from the source code path ${core_development_path} into the site development path ${site_development_path}&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Set site_development_path in ~/.bdsmrc in order to run docgen.&quot;
                  %span.k fi
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 package_error
              %p
                Presents the user with a package related error message including the tail
                of an optional log file.
              %h3 Input Parameters
              %p
                String to be logged, an optional log file containing more details and
                an optional number of lines of the file to show (defaults to 25)
              %h3 Stream Outputs
              %p
                Prints arguments passed in to the calling environments STDOUT with a newline
                character appended and 'ERROR ' prepended.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 1 for failure.
              %h3 Failure Scenarios
              %p Fails if no arguments are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ package_error "Hello there! " configure.log 5
                    ERROR Hello there!
                    
                    
                    Tail of configure.log:
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  %span.c #			checking for inflate in -lz... no
                  %span.c #			configure: error: zlib library not found
                  %span.c #			If you have zlib already installed, see config.log for details on the
                  %span.c #			failure.  It is possible the compiler isn't looking in the proper directory.
                  %span.c #			Use --without-zlib to disable zlib support.
          %tr
            %td.docs
              %pre
                %code
                  :preserve
                    *poof* shell closed...
            %td.code
              .highlight
                %pre
                  package_error
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _message
                  %span.o =
                  %span.nv $1
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_message}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot print a package error as no message was provided.&quot;
                  %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _log
                  %span.o =
                  %span.nv $2
                  %span.k if
                  %span.o [[
                  \-n
                  %span.k ${
                  %span.nv _log
                  %span.k }
                  %span.o ]]
                  %span.o &amp;&amp;
                  file_exists
                  %span.k ${
                  %span.nv _log
                  %span.k }
                  %span.k then
                  %span.c # Append tail of error log to the error message.
                  %span.nb local
                  %span.nv _num_lines
                  %span.o =
                  %span.k ${
                  %span.nv 3
                  %span.k :-
                  %span.nv 25
                  %span.k }
                  %span.c # Default the number of lines to 25
                  %span.nv _message
                  %span.o =
                  %span.s2 &quot;${_message}\n\nTail of ${_log}:\n$( tail -n ${_num_lines} ${_log} )&quot;
                  %span.k fi
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;${_message}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 package_definition
              %p Enables module developers to easily set package variables in name, value pairs.
              %h3 Input Parameters
              %p
                Parameters must come in pairs, variable name first (without the 'package'
                prefix), value second.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                For each name/value pair, a variable package_${name} is created with the given
                value.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if extension developer accidentailly separates key/value with an = :)
                Fails if a key is given without a matching value.
              %h3 Usage Examples
              %p Example Usage:
              %p
                user$ package_definition \
                name "bash" \
                version "4.2" \
                url "ftp.gnu.org/gnu/bash/"
              %h3 Notes
              %p
                For readability it is recommended to split the line into "key value" lines by
                ending the line with a singele backslash '\' character with no space afterwards.
            %td.code
              .highlight
                %pre
                  package_definition
                  %span.o ()
                  %span.o {
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  ;
                  %span.k do
                  %span.k                   %span.nv key
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  ;
                  %span.nb shift
                  %span.nb                   %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${1:-}&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  %span.k                   %span.nv value
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  ;
                  %span.nb shift
                  %span.nb                   %span.k else
                  %span.k if
                  %span.nb echo
                  %span.s2 &quot;$key&quot;
                  | grep
                  %span.s1 '='
                  ;
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Invalid key '${key}'\n =&gt; Guess: Most likely the '=' is supposed to be a ' '.&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Value not specified for key '${key}'\n =&gt; They tend to come in pairs :)&quot;
                  %span.k fi
                  %span.k fi
                  %span.k case
                  %span.s2 &quot;$key&quot;
                  in
                  name
                  %span.o )
                  %span.nv package_name
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  version
                  %span.o )
                  %span.nv package_version
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  file
                  %span.o )
                  %span.nv package_file
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  dir
                  %span.o )
                  %span.nv package_dir
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  url
                  %span.o )
                  %span.nv package_url
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  base_url
                  %span.o )
                  %span.nv package_base_url
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  docs_url
                  %span.o )
                  %span.nv package_docs_url
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  patches_url
                  %span.o )
                  %span.nv package_patches_url
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  md5_url
                  %span.o )
                  %span.nv package_md5_url
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  active_path
                  %span.o )
                  %span.nv active_path
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  bin_path
                  %span.o )
                  %span.nv bin_path
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  packages_path
                  %span.o )
                  %span.nv packages_path
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  source_path
                  %span.o )
                  %span.nv source_path
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  target_path
                  %span.o )
                  %span.nv target_path
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  archive_format
                  %span.o )
                  %span.nv archive_format
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
          %tr
            %td.docs
              %p TODO: Simplify into
            %td.code
              .highlight
                %pre
                  %span.c #(+([[[:alnum:]]|])_path|name|version|url|md5_url)
          %tr
            %td.docs
              %p
                eval "${key}=${value}"
                ;;
            %td.code
              .highlight
                %pre
                  *
                  %span.o )
                  fail
                  %span.s2 &quot;Unknown key '${key}' (value: ${value})&quot;
                  ;;
                  %span.k esac
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 package_install
              %p
                Performs all package installation steps:
                * download
                * extract
                * patch
                * confiure
                * build
                * install
                * postinstall
                * activation
                * service setup, if service module is loaded
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Steps performed are logged to STDOUT of the calling environment.
              %h3 Environmental effects
              %p Package installation artifacts are created in the system and source directories.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Fails if any of the constituant components fail.
              %h3 Usage Examples
              %p Example Usage:
              %p
                user$ package_definition \
                name "bash" \
                version "4.2" \
                url "ftp.gnu.org/gnu/bash/"
              %p user$ package_install
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_install
                  %span.o ()
                  %span.o {
                  variables_must_be_nonempty package_name package_version archive_format
                  %span.nb true
                  %span.s2 &quot;${package_dir:=&quot;
                  %span.k ${
                  %span.nv package_name
                  = succeed "-" do
                    %span.k }
                  %span.k ${
                  %span.nv package_version
                  %span.k }
                  %span.s2 &quot;}&quot;
                  ensure_paths_exist
                  %span.s2 &quot;${source_path}&quot;
                  enter
                  %span.s2 &quot;${source_path}&quot;
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_download&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_download&quot;
                  %span.k else
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Downloading ${package_name} ${package_version}&quot;
                  package_fetch
                  %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_preextract&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_preextract&quot;
                  %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_extract&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_extract&quot;
                  %span.k else
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Extracting ${package_name} ${package_version}&quot;
                  package_extract
                  %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_postextract&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_postextract&quot;
                  %span.k fi
                  = succeed "enter" do
                    %span.k                   %span.s2 &quot;${package_dir}&quot;
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_patch&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_patch&quot;
                  %span.k else
                  = succeed "package_patch" do
                    %span.k                   %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_preconfigure&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_preconfigure&quot;
                  %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_configure&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_configure&quot;
                  %span.k else
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Configuring ${package_name} ${package_version}&quot;
                  package_configure
                  %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_postconfigure&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_postconfigure&quot;
                  %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_build&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_build&quot;
                  %span.k else
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Building ${package_name} ${package_version}&quot;
                  package_build
                  %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_preinstall&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_preinstall&quot;
                  %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_install&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_install&quot;
                  %span.k else
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Installing ${package_name} ${package_version}&quot;
                  package_make_install
                  
                  log
                  %span.s2 &quot;Installed ${package_name} ${package_version}.&quot;
                  %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_postinstall&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_postinstall&quot;
                  %span.k fi
                  = succeed "package_activate_if_first" do
                    %span.k                   %span.s2 &quot;${package_name}&quot;
                  %span.s2 &quot;${package_version}&quot;
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_postactivate&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_postactivate&quot;
                  %span.k fi
                  = succeed "package_setup" do
                    %span.k                   = succeed "module_is_loaded" do
                    %span.k if
                  %span.s2 &quot;service&quot;
                  %span.k then
                  = succeed "service_setup" do
                    %span.k                   %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                package
                %em> fetch
                md5
              %p Fetches the package's md5 sum from the md5_url, if given.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p The 'package_md5' variable is set with the downloaded md5 sum.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Fails if any of the constituant components fail.
              %h3 Usage Examples
              %p Example Usage:
              %p
                user$ package
                %em> fetch
                md5
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_fetch_md5
                  %span.o ()
                  %span.o {
                  variables_must_be_nonempty package_name package_version archive_format
                  = succeed "download_url" do
                    %span.nb local
                  \:
                  %span.se \
                  %span.s2 &quot;${package_file:=&quot;
                  %span.k ${
                  %span.nv package_name
                  = succeed "-" do
                    %span.k }
                  %span.k ${
                  %span.nv package_version
                  = succeed "." do
                    %span.k }
                  %span.k ${
                  %span.nv archive_format
                  %span.k }
                  %span.s2 &quot;}&quot;
                  %span.se \
                  %span.s2 &quot;${packge_md5_url:=&quot;
                  %span.k ${
                  %span.nv package_base_url
                  = succeed "/" do
                    %span.k }
                  %span.k ${
                  %span.nv package_file
                  = succeed ".md5" do
                    %span.k }
                  %span.s2 &quot;}&quot;
                  %span.se \
                  %span.s2 &quot;${package_md5:=$( hash_file &quot;
                  %span.k ${
                  %span.nv extension_config_path
                  = succeed "/md5" do
                    %span.k }
                  %span.s2 &quot; &quot;
                  %span.k ${
                  %span.nv package_file
                  %span.k }
                  %span.s2 &quot; )}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${package_md5}&quot;
                  %span.o &amp;&amp;
                  \-n
                  %span.s2 &quot;${package_md5_url}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "curl" do
                    %span.k                   \-L
                  %span.s2 &quot;${packge_md5_url}&quot;
                  \-o
                  %span.s2 &quot;${package_file}.md5&quot;
                  2&gt;/dev/null
                  %span.o ||
                  error
                  %span.s2 &quot;Fetching md5 from '${package_md5_url}' failed.&quot;
                  %span.nv package_md5
                  %span.o =
                  = succeed "cat" do
                    %span.k $(
                  %span.s2 &quot;${package_file}.md5&quot;
                  %span.k )
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 package_fetch
              %p Fetches the package's archive file.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p curl output goes to STDERR of the calling environment.
              %h3 Environmental effects
              %p The package archive file will be placed on the filesystem.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_fetch
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_fetch
                  %span.o ()
                  %span.o {
                  variables_must_be_nonempty package_name package_version archive_format
                  
                  \:
                  %span.se \
                  %span.s2 &quot;${package_file:=&quot;
                  %span.k ${
                  %span.nv package_name
                  = succeed "-" do
                    %span.k }
                  %span.k ${
                  %span.nv package_version
                  = succeed "." do
                    %span.k }
                  %span.k ${
                  %span.nv archive_format
                  %span.k }
                  %span.s2 &quot;}&quot;
                  %span.se \
                  %span.s2 &quot;${package_url:=&quot;
                  %span.k ${
                  %span.nv package_base_url
                  = succeed "/" do
                    %span.k }
                  %span.k ${
                  %span.nv package_file
                  %span.k }
                  %span.s2 &quot;}&quot;
                  package_fetch_md5
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  package_md5
                  %span.k then
                  = succeed "file_matches_md5" do
                    %span.k                   %span.s2 &quot;${package_file}&quot;
                  %span.s2 &quot;${package_md5}&quot;
                  %span.o ||
                  %span.o {
                  log
                  %span.s2 &quot;${package_file} does not match md5 ${package_md5}, removing and downloading.&quot;
                  remove_files
                  %span.s2 &quot;${package_file}&quot;
                  curl -L
                  %span.s2 &quot;${package_url}&quot;
                  \-o
                  %span.s2 &quot;${package_file}&quot;
                  %span.o ||
                  error
                  %span.s2 &quot;Downloading ${package_name} from '${package_url}' to '${package_file}' failed &quot;
                  %span.o }
                  %span.k else
                  = succeed "curl" do
                    %span.k                   \-L
                  %span.s2 &quot;${package_url}&quot;
                  \-o
                  %span.s2 &quot;${package_file}&quot;
                  %span.o ||
                  error
                  %span.s2 &quot;Downloading ${package_name} from '${package_url}' to '${package_file}' failed &quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 package_extract
              %p Extracts the package archive into the package source directory.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p The 'package_md5' variable is set with the downloaded md5 sum.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Errors halting program if any extraction fails or if the archive format is
                unknown.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_extract
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_extract
                  %span.o ()
                  %span.o {
                  extract_archive
                  %span.s2 &quot;${package_file}&quot;
                  %span.s2 &quot;${source_path}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 package_configure
              %p Configures the package source (eg. ./configure ...).
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Makefile will be generated for a standard package extension.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if configuration fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_configure
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_configure
                  %span.o ()
                  %span.o {
                  = succeed "_command" do
                    %span.nb local
                  %span.k if
                  %span.o [[
                  \-n
                  %span.k ${
                  %span.nv configure_command
                  %span.k :-}
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _command
                  %span.o =
                  %span.s2 &quot;${configure_command}&quot;
                  %span.k else
                  %span.k                   %span.nb export
                  %span.nv PREFIX
                  %span.o =
                  %span.s2 &quot;${install_base_path}/${package_version}&quot;
                  %span.nv _command
                  %span.o =
                  = succeed "--prefix" do
                    %span.s2 &quot;./configure ${configure_flags[@]:-&quot;
                  %span.o =
                  %span.k ${
                  %span.nv install_path
                  %span.k :-
                  %span.nv $packages_path
                  %span.k }
                  %span.s2 &quot;}&quot;
                  file_is_executable
                  %span.s2 &quot;configure&quot;
                  %span.o ||
                  = succeed "0" do
                    %span.k return
                  %span.k fi
                  %span.k if
                  %span.k ${
                  %span.nv _command
                  %span.k }
                  \&gt; configure.log 2&gt;&amp;1
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Configuration of ${package_name} ${package_version} successful.&quot;
                  %span.k else
                  = succeed "package_error" do
                    %span.k                   %span.s2 &quot;Configuration of ${package_name} ${package_version} failed&quot;
                  %span.s2 &quot;configure.log&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 package_build
              %p builds the package source (eg. make)
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Makefile will be generated for a standard package extension.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if building fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_build
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_build
                  %span.o ()
                  %span.o {
                  = succeed "_command" do
                    %span.nb local
                  %span.k if
                  %span.o [[
                  \-n
                  %span.k ${
                  %span.nv make_command
                  %span.k :-}
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _command
                  %span.o =
                  %span.s2 &quot;${make_command}&quot;
                  %span.k else
                  %span.k                   %span.nv _command
                  %span.o =
                  = succeed "-j" do
                    %span.s2 &quot;make ${make_flags[@]:-&quot;
                  = succeed "os_cpu_count" do
                    %span.k $(
                  %span.k )
                  %span.s2 &quot;}&quot;
                  %span.k fi
                  %span.k if
                  %span.nb eval
                  %span.s2 &quot;${_command}&quot;
                  \&gt; make.log 2&gt;&amp;1
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "package_error" do
                    %span.k                   %span.s2 &quot;Compilation of ${package_name} ${package_version} failed! &quot;
                  %span.s2 &quot;make.log&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                package
                %em> make
                install
              %p make install  the package source (eg. make)
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Installation files will be installed to the install_path.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if make install fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p
                user$ package
                %em> make
                install
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_make_install
                  %span.o ()
                  %span.o {
                  = succeed "_command" do
                    %span.nb local
                  %span.k if
                  %span.o [[
                  \-n
                  %span.k ${
                  %span.nv make_install_command
                  %span.k :-}
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _command
                  %span.o =
                  %span.s2 &quot;${make_install_command}&quot;
                  %span.k else
                  %span.k                   %span.nv _command
                  %span.o =
                  %span.s2 &quot;make ${make_install_flags[@]:-install}&quot;
                  %span.k fi
                  %span.k if
                  %span.k ${
                  %span.nv _command
                  %span.k }
                  \&gt; make.install.log 2&gt;&amp;1
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "package_error" do
                    %span.k                   %span.s2 &quot;Installation of ${package_name} ${package_version} failed! &quot;
                  %span.s2 &quot;make.install.log&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 package_activate
              %p activates the package
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Symlink will be created to the active version in the package install path.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if activateing fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_activate
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_activate
                  %span.o ()
                  %span.o {
          %tr
            %td.docs
              %p TODO: Switch package activation to
            %td.code
              .highlight
                %pre
                  %span.nb local
                  %span.nv _package
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.nv _version
                  %span.o =
                  %span.s2 &quot;${2:-}&quot;
                  variables_must_be_nonempty _package _version
                  = succeed "symlink_exists" do
                    %span.k if
                  %span.s2 &quot;${packages_path}/${_package}/active&quot;
                  %span.k then
                  = succeed "package_deactivate" do
                    %span.k                   %span.s2 &quot;${_package}&quot;
                  %span.k fi
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${install_path}&quot;
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Activating ${_package} ${_version}&quot;
                  = succeed "command_exists" do
                    %span.k if
                  rsync
                  %span.k then
                  = succeed "rsync" do
                    %span.k                   \-a
                  %span.s2 &quot;${install_path}/&quot;
                  %span.s2 &quot;${active_path}/&quot;
                  %span.k else
                  = succeed "cp" do
                    %span.k                   \-Rf
                  %span.s2 &quot;${install_path}/&quot;
                  %span.s2 &quot;${active_path}&quot;
                  %span.k fi
                  = succeed "link" do
                    %span.k                   \--force
                  %span.s2 &quot;${packages_path}/${_package}/${_version}&quot;
                  %span.se \
                  to
                  %span.s2 &quot;${packages_path}/${_package}/active&quot;
                  %span.k else
                  = succeed "warn" do
                    %span.k                   %span.s2 &quot;Skipping activation of ${_package} ${_version} &quot;
                  %span.se \
                  %span.s2 &quot;as '${install_path}' does not exist.&quot;
                  %span.k fi
                  = succeed "package_setup" do
                    %span.k                   %span.s2 &quot;${_package}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 package_setup
              %p Sets up the package
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p
                ldconfig, profile.d and service (init.d / conf.d) files will be put in place
                on the system.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if setup fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_setup
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_setup
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _package
                  %span.o =
                  %span.s2 &quot;${1:-${package_name}}&quot;
                  package_ldconfig
                  %span.s2 &quot;${_package}&quot;
                  package_profile_d
                  %span.s2 &quot;${_package}&quot;
                  = succeed "module_is_loaded" do
                    %span.k if
                  %span.s2 &quot;service&quot;
                  %span.k then
                  = succeed "service_setup" do
                    %span.k                   %span.s2 &quot;${_package}&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 package_deactivate
              %p deactivates the package
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Active symlinks will be removed from the filesystem.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if deactivating fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_deactivate
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_deactivate
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _package
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _file _files
                  
                  variables_must_be_nonempty _package
                  
                  log
                  %span.s2 &quot;Deactivating ${_package}&quot;
                  %span.o (
                  enter
                  %span.s2 &quot;${install_path}&quot;
                  %span.nv directories
                  %span.o =(
                  = succeed "find" do
                    %span.k $(
                  \. -type d
                  %span.k )
                  %span.o )
                  %span.nv files
                  %span.o =(
                  = succeed "find" do
                    %span.k $(
                  \. -type f
                  %span.k )
                  %span.o )
                  = succeed "file" do
                    %span.k for
                  in
                  %span.s2 &quot;${files[@]}&quot;
                  %span.k do
                  = succeed "rm" do
                    %span.k                   \-f
                  %span.s2 &quot;${active_path}/${file#.\/}&quot;
                  %span.k done
                  %span.o )
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;/etc/ld.so.profile.d/${_package}.conf&quot;
                  %span.s2 &quot;/etc/profile.d/${_package}.sh&quot;
                  %span.s2 &quot;${packages_path}/${_package}/active&quot;
                  %span.o )
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 $&quot;${_files[@]}&quot;
                  %span.k do
                  = succeed "file_exists" do
                    %span.k if
                  %span.s2 &quot;${_file}&quot;
                  %span.k then
                  = succeed "remove_files" do
                    %span.k                   %span.s2 &quot;${_file}&quot;
                  %span.k fi
                  %span.k done
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;${_package} deactivated&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                package
                %em> activate
                if_first
              %p
                Activates the package version , if another package version has not yet been
                activated.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p
                Active symlinks will be added to the filesystem if it is the first version
                installed.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if deactivating fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p
                user$ package
                %em> activate
                if_first
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_activate_if_first
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _package
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.nv _version
                  %span.o =
                  %span.s2 &quot;${2:-}&quot;
                  variables_must_be_nonempty _package _version
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${install_path}&quot;
                  %span.k then
                  = succeed "symlink_exists" do
                    %span.k                   %span.s2 &quot;${packages_path}/${_package}/active&quot;
                  %span.o ||
                  package_activate
                  %span.s2 &quot;${_package}&quot;
                  %span.s2 &quot;${_version}&quot;
                  %span.k else
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;'${install_path}' not found, skipping activation.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 package_ldconfig
              %p Sets up system level ldconfigs for the package libraries.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Adjusts ldconfig configuration and runs ldconfig (on linux).
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if deactivating fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_ldconfig
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_ldconfig
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _package
                  %span.o =
                  %span.s2 &quot;${1:-${package_name}}&quot;
                  _path _files
                  
                  variables_must_be_nonempty _package
                  
                  directory_exists
                  %span.s2 &quot;${packages_path}/${_package}/active/lib&quot;
                  %span.o ||
                  = succeed "0" do
                    %span.k return
                  %span.c # no lib/ directory for activated package, no need to update ldconfig
          %tr
            %td.docs
              %p TODO: Figure out if solaris and freebsd have an analog to this?
            %td.code
              .highlight
                %pre
                  %span.k> if
                  user_is_root
                  %span.k then
                  = succeed "os_is_linux" do
                    %span.k if
                  %span.k then
                  = succeed "ensure_paths_exist" do
                    %span.k                   %span.s2 &quot;/etc/ld.so.conf.d&quot;
                  %span.k if
                  \! file_exists
                  %span.s2 &quot;/etc/ld.so.conf.d/bdsm.conf&quot;
                  %span.k then
                  %span.k                   %span.nb printf
                  %span.s2 &quot;%s\n&quot;
                  %span.s2 &quot;${active_path}/lib&quot;
                  \&gt;
                  %span.s2 &quot;/etc/ld.so.conf.d/bdsm.conf&quot;
                  chmod_files 0644
                  %span.s2 &quot;/etc/ld.so.conf.d/bdsm.conf&quot;
                  %span.k fi
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Updating ldconfig for ${_package}&quot;
                  ldconfig
                  = succeed "os_is_darwin" do
                    %span.k elif
                  %span.k then
                  %span.c # Cluster Fuck.
                  %span.nb true
          %tr
            %td.docs
              %p
                This should be handled by the profile.d?
                %em> files=($(find "${packages
                path}/${
                %em>
                  package}/active" -mindepth 1 -maxdepth 1 -type d))
                  (( ${#
                files[@]} > 0 )) &amp;&amp; copy
                %em> files to "${packages
                path}" "${_files[@]}"
            %td.code
              .highlight
                %pre
                  %span.k fi
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                package
                %em> profile
                d
              %p Sets up system level profile_d configuration for the package
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Updates profile_d configuration for the given package
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if profile_d setup fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p
                user$ package
                %em> profile
                d
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_profile_d
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _package
                  %span.o =
                  %span.s2 &quot;${1:-${package_name}}&quot;
                  variables_must_be_nonempty _package
                  = succeed "template_exists" do
                    %span.k if
                  %span.s2 &quot;profile.d.template&quot;
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Updating shell profile for ${_package}&quot;
                  ensure_paths_exist
                  %span.s2 &quot;${profile_d_path}&quot;
                  ensure_files_exist
                  %span.s2 &quot;${profile_path}&quot;
                  install_template
                  %span.s2 &quot;profile.d&quot;
                  to
                  %span.s2 &quot;${profile_d_path}/${_package}.sh&quot;
                  mode 0755
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 package_uninstall
              %p Uninstalls the package
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Uninstalls the package install effects from the system.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if uninstall fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_uninstall
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_uninstall
                  %span.o ()
                  %span.o {
                  variables_must_be_nonempty package_name package_version archive_format
                  = succeed "package_is_active" do
                    %span.k if
                  %span.s2 &quot;${package_name}&quot;
                  %span.s2 &quot;${package_version}&quot;
                  %span.k then
                  %span.c # Deactivate the package if active.
                  package_deactivate
                  %span.s2 &quot;${package_name}&quot;
                  %span.k fi
                  = succeed "remove_paths" do
                    %span.k                   %span.s2 &quot;${install_path}&quot;
                  = succeed "module_is_loaded" do
                    %span.k if
                  service
                  %span.k then
                  %span.c # Remove any service reminants.
                  service_uninstall
                  %span.k fi
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;${package_name} ${package_version} has been uninstalled.&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 package_patch
              %p Applies any patches found for the current package.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Updates the source code directory for the package with any patches found.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if patching fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_patch
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_patch
                  %span.o ()
                  %span.o {
                  = succeed "_patches" do
                    %span.nb local
                  _patch
                  %span.k if
                  \! directory_exists
                  %span.s2 &quot;${extension_patches_path}&quot;
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k fi
          %tr
            %td.docs
              %p
                TODO: Three level hierarchy based on patches/{OS}/{version},
                root level as 'global' always installed.
            %td.code
              .highlight
                %pre
                  :preserve
                    
                    
          %tr
            %td.docs
              %p TODO: Test each dir for existence and skip if missing
            %td.code
              .highlight
                %pre
                  %span.nv _patches
                  %span.o =(
                  = succeed "find" do
                    %span.k $(
                  %span.s2 &quot;${extension_patches_path}&quot;
                  \-mindepth 1 -maxdepth 1 -iname
                  %span.s1 '*.patch'
                  \-type f
                  %span.k )
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _patches
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k fi
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Applying patches for ${package_name} ${package_version}&quot;
                  package_apply_patches
                  %span.s2 &quot;${_patches[@]}&quot;
                  %span.k if
                  \! directory_exists
                  %span.s2 &quot;${extension_patches_path}/$(os_type)&quot;
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k fi
                  %span.k                   %span.nv _patches
                  %span.o =(
                  = succeed "find" do
                    %span.k $(
                  %span.s2 &quot;${extension_patches_path}/$(os_type)&quot;
                  \-mindepth 1 -maxdepth 1 -iname
                  %span.s1 '*.patch'
                  \-type f
                  %span.k )
                  %span.o )
                  package_apply_patches
                  %span.s2 &quot;${_patches[@]}&quot;
                  %span.k if
                  \! directory_exists
                  %span.s2 &quot;${extension_patches_path}/$(os_type)/${package_version}&quot;
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k fi
                  %span.k                   %span.nv _patches
                  %span.o =(
                  = succeed "find" do
                    %span.k $(
                  %span.s2 &quot;${extension_patches_path}/$(os_type)/${package_version}&quot;
                  \-mindepth 1 -maxdepth 1 -iname
                  %span.s1 '*.patch'
                  \-type f
                  %span.k )
                  %span.o )
                  package_apply_patches
                  %span.s2 &quot;${_patches[@]}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                package
                %em> apply
                patches
              %p Applies patches found
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Applies any patches found for the current package.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if apply_patches fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p
                user$ package
                %em> apply
                patches
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_apply_patches
                  %span.o ()
                  %span.o {
                  = succeed "_patch" do
                    %span.nb local
                  %span.nv _patches
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _patches
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot apply patches as no patches were given.&quot;
                  %span.k fi
                  = succeed "_patch" do
                    %span.k for
                  in
                  %span.s2 &quot;${_patches[@]}&quot;
                  %span.k do
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;TODO: patch application is NIY&quot;
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 package_usage
              %p Sets up system level usage configuration for the package
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Updates usage configuration for the given package
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if usage setup fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_usage
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_usage
                  %span.o ()
                  %span.o {
                  %span.nb printf
                  %span.s2 &quot;
                  %span.s2 Usage:
                  %span.s2 $0 [options]
                  %span.s2 options:
                  %span.s2 --prefix   - specify prefix path
                  %span.s2 --src)     - specify source directory
                  %span.s2 --data)    - specify data directory
                  %span.s2 --user)    - specify user to install as
                  %span.s2 --version) - specify version to install
                  %span.s2 --licence) - view licence
                  %span.s2 --help)    - view this usage information
                  %span.s2 &quot;
                  = succeed "0" do
                    %span.k return
                  %span.o }
          %tr
            %td.docs
              %h2 package_cli
              %p Parses package CLI arguments
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Updates cli configuration for the given package
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if cli setup fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_cli
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_cli
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _ignored_args
                  %span.o =()
                  %span.nv number_of_args
                  %span.o =
                  %span.k ${#
                  %span.nv extension_args
                  %span.p [@]
                  %span.k }
                  %span.k for
                  %span.o ((
                  %span.nv index
                  = succeed "0" do
                    %span.o =
                  ; index &lt;
                  %span.nv $number_of_args
                  ; index++
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;${extension_args[$index]}&quot;
                  %span.k case
                  %span.s2 &quot;$token&quot;
                  in
                  \--prefix
                  %span.o )
                  %span.nv packages_path
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--src
                  %span.o )
                  %span.nv src_path
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--data
                  %span.o )
                  %span.nv data_path
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--user
                  %span.o )
                  %span.nv package_user
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--version
                  %span.o )
                  %span.nv package_version
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--base_url
                  %span.o )
                  %span.nv package_base_url
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--file
                  %span.o )
                  %span.nv package_file
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--directory
                  %span.o )
                  %span.nv package_directory
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--archive_format
                  %span.o )
                  %span.nv archive_format
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--activate|activate
                  %span.o )
          %tr
            %td.docs
              %p TODO: Throw error if parameter is not specified.
            %td.code
              .highlight
                %pre
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv extension_args
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "package_activate" do
                    %span.k                   %span.s2 &quot;${extension}&quot;
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot activate ${extension}, no version was given.&quot;
                  %span.k fi
                  ;;
                  \--deactivate|deactivate
                  %span.o )
                  package_deactivate
                  %span.s2 &quot;${extension}&quot;
                  ;;
                  \--md5
                  %span.o )
                  %span.nv package_md5
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--licence
                  %span.o )
                  extension_license
                  = succeed "0" do
                    %span.nb exit
                  ;;
                  \--help
                  %span.o )
                  package_usage
                  = succeed "0" do
                    %span.nb exit
                  ;;
                  \--trace
                  %span.o )
                  %span.nb set
                  \-o xtrace
                  ;;
                  *
                  %span.o )
                  _ignored_args+
                  %span.o =(
                  %span.s2 &quot;${token}&quot;
                  %span.o )
                  ;;
                  %span.k esac
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _ignored_args
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nv extension_args
                  %span.o =(
                  %span.s2 &quot;${_ignored_args[@]}&quot;
                  %span.o )
                  %span.k fi
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 package_active
              %p Parses package active arguments
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Updates active configuration for the given package
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if active setup fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_active
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_is_active
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _name
                  %span.o =
                  %span.s2 &quot;${1:-${package_name}}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_name}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Can not query if a package is active as no package name was given or name is empty.&quot;
                  %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${packages_path}/${_name}&quot;
                  %span.k if
                  %span.o [[
                  \-L
                  %span.s2 &quot;${_path}/active&quot;
                  %span.o &amp;&amp;
                  \-d
                  = succeed "readlink" do
                    %span.k $(
                  %span.s2 &quot;${_path}/active&quot;
                  %span.k )
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 package_must be
              %p Parses package must be arguments
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Updates must be configuration for the given package
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if must be setup fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_must be
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_must_be_active
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _name
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_name}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Can not ensure that package is active as no package name was given or name is empty.&quot;
                  %span.k fi
                  = succeed "package_is_active" do
                    %span.k if
                  %span.s2 &quot;${_name}&quot;
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Install/activate the node package extension before installing ${_name}.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                packages
                %em> must
                be_active
              %p
                Parses package must
                %em> be
                active arguments
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p
                Updates must
                %em> be
                active configuration for the given package
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Errors halting program if must
                %em> be
                active setup fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p
                user$ packages
                %em> must
                be_active
              %h3 Notes
            %td.code
              .highlight
                %pre
                  packages_must_be_active
                  %span.o ()
                  %span.o {
                  = succeed "_package" do
                    %span.nb local
                  %span.nv _packages
                  %span.o =
                  %span.s2 &quot;$@&quot;
                  %span.k if
                  %span.o ((
                  %span.s2 &quot;${#@}&quot;
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Can not ensure that packages are active as no packages were given.&quot;
                  %span.k fi
                  = succeed "_package" do
                    %span.k for
                  in
                  %span.s2 &quot;${_packages[@]}&quot;
                  %span.k do
                  = succeed "package_must_be_active" do
                    %span.k                   %span.s2 &quot;${_package}&quot;
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 package_docs
              %p
                Opens package documentation website either in the web browser (if able) or via
                curl through PAGER (defaulting to less).
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None if can open web browser or website docs in PAGER otherwise.
              %h3 Environmental effects
              %p Web browser will open with documentation url if able.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Error if package
                %em> docs
                url has not been set.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_docs
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_docs
                  %span.o ()
                  %span.o {
          %tr
            %td.docs
              %p TODO: move this logic into a core dsl function.
            %td.code
              .highlight
                %pre
                  %span.k> if
                  os_is_darwin
                  %span.k then
                  = succeed "open" do
                    %span.k                   %span.nv $package_docs_url
                  = succeed "command_exists" do
                    %span.k elif
                  xdg-open
                  %span.k then
                  = succeed "xdg-open" do
                    %span.k                   %span.nv $package_docs_url
                  = succeed "command_exists" do
                    %span.k elif
                  lynx
                  %span.k then
                  = succeed "lynx" do
                    %span.k                   %span.nv $package_docs_url
                  = succeed "command_exists" do
                    %span.k elif
                  links
                  %span.k then
                  = succeed "links" do
                    %span.k                   %span.nv $package_docs_url
                  %span.k else
                  = succeed "curl" do
                    %span.k                   \-s -L
                  %span.nv $package_docs_url
                  \-o /tmp/
                  %span.k ${
                  %span.nv package_name
                  = succeed "-" do
                    %span.k }
                  %span.k ${
                  %span.nv package_version
                  = succeed ".docs" do
                    %span.k }
                  %span.k ${
                  %span.nv EDITOR
                  %span.k :-
                  %span.p /bin/less
                  %span.k }
                  \/tmp/
                  %span.k ${
                  %span.nv package_name
                  = succeed "-" do
                    %span.k }
                  %span.k ${
                  %span.nv package_version
                  = succeed ".docs" do
                    %span.k }
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 package_website
              %p
                Opens package documentation website either in the web browser (if able) or via
                curl through PAGER (defaulting to less).
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None if can open web browser or website website in PAGER otherwise.
              %h3 Environmental effects
              %p Web browser will open with documentation url if able.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Error if package
                %em> website
                url has not been set.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_website
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_website
                  %span.o ()
                  %span.o {
          %tr
            %td.docs
              %p TODO: move this logic into a core dsl function.
            %td.code
              .highlight
                %pre
                  %span.k> if
                  os_is_darwin
                  %span.k then
                  = succeed "open" do
                    %span.k                   %span.nv $package_website_url
                  = succeed "command_exists" do
                    %span.k elif
                  xdg-open
                  %span.k then
                  = succeed "xdg-open" do
                    %span.k                   %span.nv $package_website_url
                  = succeed "command_exists" do
                    %span.k elif
                  lynx
                  %span.k then
                  = succeed "lynx" do
                    %span.k                   %span.nv $package_website_url
                  = succeed "command_exists" do
                    %span.k elif
                  links
                  %span.k then
                  = succeed "links" do
                    %span.k                   %span.nv $package_website_url
                  %span.k else
                  = succeed "curl" do
                    %span.k                   \-s -L
                  %span.nv $package_website_url
                  \-o /tmp/
                  %span.k ${
                  %span.nv package_name
                  = succeed "-" do
                    %span.k }
                  %span.k ${
                  %span.nv package_version
                  = succeed ".website" do
                    %span.k }
                  %span.k ${
                  %span.nv EDITOR
                  %span.k :-
                  %span.p /bin/less
                  %span.k }
                  \/tmp/
                  %span.k ${
                  %span.nv package_name
                  = succeed "-" do
                    %span.k }
                  %span.k ${
                  %span.nv package_version
                  = succeed ".website" do
                    %span.k }
                  %span.k fi
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 lockfile_lock()
              %p
                If the current process is the first to write to the lockfile then the process
                continues processing past the line calling lockfile_lock "{file path/name}"
              %p
                Otherwise lockfile_lock causes the process to exit with a message and status
                code 0.
              %p If the lock is obtained then lockfile_lock ensures that
              %p Usage Examples:
              %p
                lockfile
                %em> lock /var/run/my
                script.pid
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  lockfile_lock
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _lockfile
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_lockfile}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot lock onto a lockfile as no lockfile was specified as the first parameter.&quot;
                  %span.k fi
          %tr
            %td.docs
              %p The first instance that successfully writes it's pid to the lockfile 'wins'
            %td.code
              .highlight
                %pre
                  %span.nb printf
                  %span.s2 &quot;$$&quot;
                  \&gt;&gt;
                  %span.s2 &quot;${_lockfile}&quot;
                  %span.nb read
                  \-r _pid &lt;
                  %span.s2 &quot;${_lockfile}&quot;
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;${_pid}&quot;
                  %span.o ==
                  %span.s2 &quot;$$&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "on_exit" do
                    %span.k                   %span.s2 &quot;rm -f ${_lockfile}&quot;
          %tr
            %td.docs
              %p Ensure the lockfile is released on exit while preserving existing EXIT traps.
            %td.code
              .highlight
                %pre
                  %span.nb trap
                  = succeed "s#" do
                    %span.s2 &quot;rm -f ${_lockfile};$(trap | awk '/EXIT/' | sed -e &quot;
                  %span.s1 ' EXIT##&quot; -e &quot;s#.*'
                  %span.c ##&quot;)&quot; EXIT
                  = succeed "0" do
                    %span.k return
                  %span.c # The lock has been obtained! Proceed with nefarious things!
                  %span.k else
                  %span.c # Question: Should this be an error exit code or ?
                  succeed
                  %span.s2 &quot;Another process already owns the lockfile, exiting.&quot;
                  %span.k fi
                  %span.o }
                  on_exit
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _commands
                  %span.o =
                  %span.s2 &quot;$*&quot;
                  %span.nb local
                  %span.nv _on_exit_code
                  %span.o =
                  = succeed "s#" do
                    %span.s2 &quot;$(trap | awk '/EXIT/' | sed -e &quot;
                  %span.s1 ' EXIT##&quot; -e &quot;s#.*'
                  %span.c ##&quot;)&quot;
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;${_on_exit_code}&quot;
                  \!
                  %span.o =
                  *on_exit*
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb trap
                  %span.s2 &quot;on_exit_commands;${_on_exit_code}&quot;
                  EXIT
                  %span.k fi
                  = succeed "on_exit_commands+" do
                    %span.k                   %span.o =(
                  %span.s2 &quot;${_commands}&quot;
                  %span.o )
                  %span.o }
                  on_exit_commands
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _result
                  %span.o =
                  %span.s2 &quot;$?&quot;
                  %span.c # Preserve actual exit code.
                  = succeed "_command" do
                    %span.nb local
                  = succeed "_command" do
                    %span.k for
                  in
                  %span.s2 &quot;${on_exit_commands[@]}&quot;
                  %span.k do
                  %span.k if
                  \!
                  %span.nb eval
                  %span.s2 &quot;${_command}&quot;
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;On Exit Command Failed: ${_command}&quot;
                  %span.k fi
                  %span.k done
                  %span.k return
                  %span.s2 &quot;${_result}&quot;
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 project_initialize()
              %p Initializes paths and environment for the logical concept of a 'project'.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                Environmental variable settings, such as {shared,release}_path, environment,
                etc...
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ project_initialize
                    user$ echo $environment
                    production
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  project_initialize
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${project_path}&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  \:
                  %span.se \
                  %span.s2 &quot;${shared_path:=${project_path}/shared}&quot;
                  %span.se \
                  %span.s2 &quot;${release_path:=${project_path}/current}&quot;
                  %span.se \
                  = succeed "production" do
                    %span.s2 &quot;${environment:=&quot;
                  %span.s2 &quot;}&quot;
                  \:
                  %span.se \
                  %span.s2 &quot;${vcs:=$(vcs &quot;
                  %span.k ${
                  %span.nv shared_path
                  = succeed "/" do
                    %span.k }
                  %span.k ${
                  %span.nv project
                  %span.k }
                  %span.s2 &quot;)}&quot;
                  %span.nv log_path
                  %span.o =
                  %span.s2 &quot;$shared_path/log&quot;
                  %span.c # Override default BDSM log path.
                  %span.nv extension_log_path
                  %span.o =
                  %span.s2 &quot;${log_path}&quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${project}&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  %span.k                   %span.nv database_name
                  %span.o =
                  %span.s2 &quot;${database_name:-&quot;
                  %span.k ${
                  %span.nv project
                  = succeed "_" do
                    %span.k }
                  %span.k ${
                  %span.nv environment
                  %span.k }
                  %span.s2 &quot;}&quot;
                  source_files
                  %span.s2 &quot;.${project}rc&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 vcs()
              %p Detect and set the vcs, if any, for the current project.
              %h3 Input Parameters
              %p First parameter must be the path to a repository for determining the VCS.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                The environment variable 'vcs' will be set to the VCS detected, or 'git' by
                default.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no repository path is given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ vcs /home/appuser/shared/appuser
                    user$ echo $vcs
                    git
            %td.code
              .highlight
                %pre
                  vcs
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.o ||
                  fail
                  %span.s2 &quot;Repository path must be given in order to detect the VCS used.&quot;
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}/.git&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  %span.k                   %span.nv vcs
                  %span.o =
                  %span.s2 &quot;git&quot;
                  %span.k elif
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}/.svn&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  %span.k                   %span.nv vcs
                  %span.o =
                  %span.s2 &quot;svn&quot;
                  %span.k elif
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}/.hg&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  %span.k                   %span.nv vcs
                  %span.o =
                  %span.s2 &quot;hg&quot;
          %tr
            %td.docs
              %p
                TODO:
                elif [[ ... ]] ; then
                vcs="fossil"
            %td.code
              .highlight
                %pre
                  %span.k else
                  %span.k                   %span.nv vcs
                  %span.o =
                  %span.s2 &quot;git&quot;
                  %span.c # default
                  %span.k fi
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 rvm_install()
              %p Install the latest release version of RVM.
              %h3 Input Parameters
              %p First parameter is an optional version number of RVM to install.
              %h3 Stream Outputs
              %p
                Output from rvm-installer will be printed to the enclosing environment's
                STDOUT as well as curl output.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ rvm_install
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  rvm_install
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _version
                  %span.o =
                  %span.k ${
                  %span.nv 1
                  %span.k :-
                  %span.nv latest
                  %span.k }
                  %span.nv _result
                  = succeed "0" do
                    %span.o =
                  %span.nb local
                  %span.nv url
                  %span.o =
                  %span.s2 &quot;https://rvm.beginrescueend.com/install/rvm&quot;
                  %span.o (
                  %span.nb set
                  \-o errexit
                  curl -s
                  %span.s2 &quot;$url&quot;
                  \-o rvm-installer
                  ensure_files_are_executable
                  %span.s2 &quot;rvm-installer&quot;
                  \./rvm-installer --version
                  %span.k ${
                  %span.nv _version
                  %span.k }
                  remove_files
                  %span.s2 &quot;rvm-installer&quot;
                  %span.o )
                  %span.o ||
                  %span.nv _result
                  %span.o =
                  %span.nv $?
                  %span.k return
                  %span.nv $_result
                  %span.o }
          %tr
            %td.docs
              %h2 install_gem()
              %p installs the named gem(s) with --no-rdoc --no-ri flags
              %h3 Input Parameters
              %p One or more gem names
              %h3 Stream Outputs
              %p
                The output of the gem install command will be printed to the calling
                environments streams.
              %h3 Environmental effects
              %p Ruby gem(s) will be installed on the system, potentially enabling new commands.
              %h3 Return Codes
              %p
                0 if gem install was successful
                1 if gem install was not successful
              %h3 Failure Scenarios
              %p Fails if ...
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ {{ setup the scenario }}
                    user$ function_name {{ parameters }}
                    user$ {{ demonstrate the results}}
            %td.code
              .highlight
                %pre
                  install_gem
                  %span.o ()
                  %span.o {
                  = succeed "gem" do
                    %span.k if
                  install --no-rdoc --no-ri -q
                  %span.s2 &quot;$*&quot;
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 install_gems()
              %p Installs listed gems using the install_gem function.
              %h3 Input Parameters
              %p One or more rubygems names
              %h3 Stream Outputs
              %p
                Output from underlying gem install will be printed to the calling environments
                streams.
              %h3 Environmental effects
              %p One or more new commands may become available.
              %h3 Return Codes
              %p
                0 if all gem installs were successful
                n where n is the number of unsuccessful gem installs otherwise.
              %h3 Failure Scenarios
              %p Fails if no gems were given to install.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ install_gems rake rack
            %td.code
              .highlight
                %pre
                  install_gems
                  %span.o ()
                  %span.o {
                  = succeed "_gem" do
                    %span.nb local
                  %span.nv _gems
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.nv _result
                  = succeed "0" do
                    %span.o =
                  %span.o ((
                  %span.k ${#
                  %span.nv _gems
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.o ||
                  fail
                  %span.s2 &quot;Cannot install gems as no gem names were given!&quot;
                  = succeed "_gem" do
                    %span.k for
                  in
                  %span.s2 &quot;${_gems[@]}&quot;
                  %span.k do
                  = succeed "install_gem" do
                    %span.k                   %span.k ${
                  %span.nv _gem
                  %span.k }
                  %span.o ||
                  %span.o ((
                  _result++
                  %span.o ))
                  %span.k done
                  %span.k return
                  %span.nv $_result
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h1 General Services functions.
              %h2 services_list()
              %p
                List installed services. These are extensions that have loaded the service
                module.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                A list of available services to install are printed to STDOUT of
                the calling environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                NIY
                No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ services_avilable
                    Available service listing has not yet been implemented.
                    This feature has not yet been implemented.
              %h1 General Services functions.
              %h2 services_list()
              %p
                List installed services. These are extensions that have loaded the service
                module.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                A list of available services to install are printed to STDOUT of
                the calling environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                NIY
                No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ services_avilable
                    Available service listing has not yet been implemented.
                    This feature has not yet been implemented.
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  services_avilable
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;Available service listing has not yet been implemented.&quot;
                  NIY
                  services_installed
                  %span.o }
          %tr
            %td.docs
              %h2 services_installed()
              %p
                List installed services. These are extensions that have loaded the service
                module.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                A list of installed extensions that load the service module are printed
                to the STDOUT of the calling environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                NIY
                No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ services_installed
                    nginx unicorn redis postgresql
            %td.code
              .highlight
                %pre
                  services_installed
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;Installed services has not yet been implemented.&quot;
                  NIY
                  %span.o }
          %tr
            %td.docs
              %h2 services_available()
              %p List available services. These are extensions that load the service module.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                A list of available extensions that load the service module are printed to
                STDOUT of the calling environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                NIY
                No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ services_available
                    nginx redis postgresql mongodb ...
            %td.code
              .highlight
                %pre
                  services_available
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;Installed services has not yet been implemented.&quot;
                  NIY
                  %span.o }
          %tr
            %td.docs
              %h1 Single Service functions.
              %h2 service_setup()
              %p Service setup and configuration.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                Creates a system service user with the same name as the service.
                Sets up the service init_d file from template, if it exists.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_setup
                    ...
            %td.code
              .highlight
                %pre
                  service_setup
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;#creating paths for ${service} ${package_version}...&quot;
                  ensure_paths_exist
                  %span.s2 &quot;${service_paths[@]}&quot;
                  %span.s2 &quot;${install_path}&quot;
                  chown_paths_recursively
                  %span.s2 &quot;${service_user}:${service_user}&quot;
                  %span.s2 &quot;${service_paths[@]}&quot;
                  chown_paths_recursively
                  %span.s2 &quot;${service_user}:${service_user}&quot;
                  %span.se \
                  %span.s2 &quot;${service_root_paths[@]}&quot;
                  = succeed "user_is_root" do
                    %span.k if
                  %span.k then
          %tr
            %td.docs
              %p TODO: create an 'user_exists' function and use it here.
            %td.code
              .highlight
                %pre
                  user_create_if_missing
                  %span.s2 &quot;${service_user}&quot;
                  %span.se \
                  with group
                  %span.s2 &quot;${service_user}&quot;
                  2&gt;/dev/null
                  
                  ensure_paths_exist
                  %span.s2 &quot;${service_root_paths[@]}&quot;
                  chown_paths_recursively
                  %span.s2 &quot;${service_user}:${service_user}&quot;
                  %span.se \
                  %span.s2 &quot;${service_root_paths[@]}&quot;
                  %span.k fi
                  = succeed "service_install_init_d" do
                    %span.k                   %span.s2 &quot;${service}&quot;
                  %span.o }
          %tr
            %td.docs
              %h1 Single Service functions.
              %h2 service_uninstall()
              %p Service uninstall and configuration.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                Creates a system service user with the same name as the service.
                Sets up the service init_d file from template, if it exists.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_uninstall
                    ...
            %td.code
              .highlight
                %pre
                  service_uninstall
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;TODO: service_uninstall is NIY&quot;
          %tr
            %td.docs
              %ol
                %li Remove init scripts
                %li Unload OS service hooks
                %li
                  Deactivate database path.
            %td.code
              .highlight
                %pre
                  %span.o }
          %tr
            %td.docs
              %h2 service_start()
              %p Starts the given service using init scripts.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Whatever stream output comes from the called init script.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if extension was not set.
                Fails if the init script is missing or not executable.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ extension=redis
                    user$ service_start
                    ...
            %td.code
              .highlight
                %pre
                  service_start
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${service}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;In order to start a service the 'service' variable must be set.&quot;
                  %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${service}_start&quot;
                  %span.k then
                  %span.s2 &quot;${service}_start&quot;
                  %span.k else
                  = succeed "file_is_executable" do
                    %span.k if
                  %span.s2 &quot;${init_scripts_path}/${service}&quot;
                  %span.k then
                  = succeed "service_init_start" do
                    %span.k                   %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;${init_scripts_path}/${service} is missing or not executable.&quot;
                  %span.k fi
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 service_stop()
              %p stops the given service using init scripts.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Whatever stream output comes from the called init script.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if service was not set.
                Fails if the init script is missing or not executable.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_stop
                    ...
            %td.code
              .highlight
                %pre
                  service_stop
                  %span.o ()
                  %span.o {
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${service}_stop&quot;
                  %span.k then
                  %span.s2 &quot;${service}_stop&quot;
                  %span.k else
                  = succeed "file_is_executable" do
                    %span.k if
                  %span.s2 &quot;${init_scripts_path}/${service}&quot;
                  %span.k then
                  = succeed "service_init_stop" do
                    %span.k                   %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;${init_scripts_path}/${service} is missing or not executable.&quot;
                  %span.k fi
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 service_reload()
              %p reloads the given service using init scripts.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Whatever stream output comes from the called init script.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if service was not set.
                Fails if the init script is missing or not executable.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_reload
                    ...
            %td.code
              .highlight
                %pre
                  service_reload
                  %span.o ()
                  %span.o {
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${service}_reload&quot;
                  %span.k then
                  %span.s2 &quot;${service}_reload&quot;
                  %span.k else
                  = succeed "file_is_executable" do
                    %span.k if
                  %span.s2 &quot;${init_scripts_path}/${service}&quot;
                  %span.k then
                  = succeed "service_init_reload" do
                    %span.k                   %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;${init_scripts_path}/${service} is missing or not executable.&quot;
                  %span.k fi
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 service_restart()
              %p restarts the given service using init scripts.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Whatever stream output comes from the called init script.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if service was not set.
                Fails if the init script is missing or not executable.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_restart
                    ...
            %td.code
              .highlight
                %pre
                  service_restart
                  %span.o ()
                  %span.o {
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${service}_restart&quot;
                  %span.k then
                  %span.s2 &quot;${service}_restart&quot;
                  %span.k else
                  = succeed "file_is_executable" do
                    %span.k if
                  %span.s2 &quot;${init_scripts_path}/${service}&quot;
                  %span.k then
                  = succeed "service_init_stop" do
                    %span.k                   service_init_start
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;${init_scripts_path}/${service} is missing or not executable.&quot;
                  %span.k fi
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 service_status()
              %p statuss the given service using init scripts.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Whatever stream output comes from the called init script.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if service was not set.
                Fails if the init script is missing or not executable.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_status
                    ...
            %td.code
              .highlight
                %pre
                  service_status
                  %span.o ()
                  %span.o {
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${service}_status&quot;
                  %span.k then
                  %span.s2 &quot;${service}_status&quot;
                  %span.k else
                  = succeed "file_is_executable" do
                    %span.k if
                  %span.s2 &quot;${init_scripts_path}/${service}&quot;
                  %span.k then
                  = succeed "service_init_status" do
                    %span.k                   %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;${init_scripts_path}/${service} is missing or not executable.&quot;
                  %span.k fi
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 service_logtail()
              %p logtails the given service using init scripts.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Whatever stream output comes from the called init script.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if service was not set.
                Fails if the init script is missing or not executable.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_logtail
                    ...
            %td.code
              .highlight
                %pre
                  service_logtail
                  %span.o ()
                  %span.o {
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${service}_logtail&quot;
                  %span.k then
                  %span.s2 &quot;${service}_logtail&quot;
                  %span.k else
                  = succeed "file_is_executable" do
                    %span.k if
                  %span.s2 &quot;${init_scripts_path}/${service}&quot;
                  %span.k then
                  = succeed "service_init_logtail" do
                    %span.k                   %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;${init_scripts_path}/${service} is missing or not executable.&quot;
                  %span.k fi
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 service_info()
              %p infos the given service using init scripts.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Whatever stream output comes from the called init script.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if service was not set.
                Fails if the init script is missing or not executable.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_info
                    ...
            %td.code
              .highlight
                %pre
                  service_info
                  %span.o ()
                  %span.o {
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${service}_info&quot;
                  %span.k then
                  %span.s2 &quot;${service}_info&quot;
                  %span.k else
                  = succeed "file_is_executable" do
                    %span.k if
                  %span.s2 &quot;${init_scripts_path}/${service}&quot;
                  %span.k then
                  = succeed "service_init_info" do
                    %span.k                   %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;${init_scripts_path}/${service} is missing or not executable.&quot;
                  %span.k fi
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 service_configcheck()
              %p configchecks the given service using init scripts.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Whatever stream output comes from the called init script.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if service was not set.
                Fails if the init script is missing or not executable.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_configcheck
                    ...
            %td.code
              .highlight
                %pre
                  service_configcheck
                  %span.o ()
                  %span.o {
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${service}_configcheck&quot;
                  %span.k then
                  %span.s2 &quot;${service}_configcheck&quot;
                  %span.k else
                  = succeed "file_is_executable" do
                    %span.k                   %span.s2 &quot;${init_scripts_path}/${service}&quot;
                  %span.o ||
                  fail
                  %span.s2 &quot;${init_scripts_path}/${service} is missing or not executable.&quot;
                  %span.s2 &quot;${init_scripts_path}/${service}&quot;
                  configcheck
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 service_usage()
              %p usages the given service using init scripts.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Whatever stream output comes from the called init script.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if service was not set.
                Fails if the init script is missing or not executable.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_usage
                    ...
            %td.code
              .highlight
                %pre
                  service_usage
                  %span.o ()
                  %span.o {
          %tr
            %td.docs
              %p TODO: Update this for service specific items.
            %td.code
              .highlight
                %pre
                  %span.nb printf
                  %span.s2 &quot;
                  %span.s2 Usage:
                  %span.s2 $0 [options]
                  %span.s2 Options:
                  %span.s2 --prefix   - specify prefix path
                  %span.s2 --src)     - specify source directory
                  %span.s2 --data)    - specify data directory
                  %span.s2 --user)    - specify user to install as
                  %span.s2 --version) - specify version to install
                  %span.s2 --licence) - view licence
                  %span.s2 --help)    - view this usage information
                  %span.s2 &quot;
                  = succeed "0" do
                    %span.k return
                  %span.o }
          %tr
            %td.docs
              %h2 service_cli()
              %p clis the given service using init scripts.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Whatever stream output comes from the called init script.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if service was not set.
                Fails if the init script is missing or not executable.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_cli
                    ...
            %td.code
              .highlight
                %pre
                  service_cli
                  %span.o ()
                  %span.o {
          %tr
            %td.docs
              %p TODO: Update this for service specific items.
            %td.code
              .highlight
                %pre
                  %span.nb local
                  %span.nv _ignored_args
                  %span.o =()
                  %span.nv number_of_args
                  %span.o =
                  %span.k ${#
                  %span.nv extension_args
                  %span.p [@]
                  %span.k }
                  %span.k for
                  %span.o ((
                  %span.nv index
                  = succeed "0" do
                    %span.o =
                  ; index &lt;
                  %span.nv $number_of_args
                  ; index++
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;${extension_args[$index]}&quot;
                  %span.k case
                  %span.s2 &quot;$token&quot;
                  in
                  \--prefix
                  %span.o )
                  %span.nv prefix_path
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--src
                  %span.o )
                  %span.nv src_path
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--data
                  %span.o )
                  %span.nv data_path
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--user
                  %span.o )
                  %span.nv service_user
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--version
                  %span.o )
                  %span.nv service_version
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--base_url
                  %span.o )
                  %span.nv service_base_url
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--file
                  %span.o )
                  %span.nv service_file
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--directory
                  %span.o )
                  %span.nv service_directory
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--archive_format
                  %span.o )
                  %span.nv archive_format
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--activate|activate
                  %span.o )
          %tr
            %td.docs
              %p TODO: Throw error if parameter is not specified.
            %td.code
              .highlight
                %pre
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv extension_args
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "service_activate" do
                    %span.k                   %span.s2 &quot;${service}&quot;
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot activate ${service}, no version was given.&quot;
                  %span.k fi
                  ;;
                  \--deactivate|deactivate
                  %span.o )
                  service_deactivate
                  %span.s2 &quot;${service}&quot;
                  ;;
                  \--md5
                  %span.o )
                  %span.nv service_md5
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--help
                  %span.o )
                  service_usage
                  = succeed "0" do
                    %span.nb exit
                  ;;
                  \--trace
                  %span.o )
                  %span.nb set
                  \-o xtrace
                  ;;
                  *
                  %span.o )
                  _ignored_args+
                  %span.o =(
                  %span.s2 &quot;${token}&quot;
                  %span.o )
                  ;;
                  %span.k esac
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _ignored_args
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nv extension_args
                  %span.o =(
                  %span.s2 &quot;${_ignored_args[@]}&quot;
                  %span.o )
                  %span.k fi
                  %span.k done
                  = succeed "service_init_path" do
                    %span.k                   %span.o }
          %tr
            %td.docs
              %h2 service_pid()
              %p
                List installed services. These are extensions that have loaded the service
                module.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                A list of extensions that load the service module are printed to STDOUT of
                the calling environment.
              %h3 Environmental effects
              %p Sets the variable 'service_pid' to contain the pid of the process or 0.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p None currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    root# service=redis
                    root# service_pid
                    root# echo $service_pid
                    0
            %td.code
              .highlight
                %pre
                  service_pid
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  = succeed "/var/run" do
                    %span.s2 &quot;${run_path:=&quot;
                  %span.s2 &quot;}/${service}&quot;
                  %span.nb local
                  %span.nv _pid
                  = succeed "0" do
                    %span.o =
                  ensure_paths_exist
                  %span.s2 &quot;${_path}&quot;
                  = succeed "file_is_nonempty" do
                    %span.k if
                  %span.s2 &quot;${_path}/${service}.pid&quot;
                  %span.k then
                  %span.k                   %span.nb read
                  \-r _pid &lt;
                  %span.s2 &quot;${_path}/${service}.pid&quot;
                  = succeed "os_is_linux" do
                    %span.k if
                  %span.k then
                  %span.c # Sanity check.
                  %span.k if
                  \! directory_exists
                  %span.s2 &quot;/proc/${pid}&quot;
                  %span.k then
                  %span.k                   %span.nv _pid
                  = succeed "0" do
                    %span.o =
                  rm -f
                  %span.s2 &quot;${_path}/${service}.pid&quot;
                  %span.k fi
                  %span.k fi
                  %span.k fi
                  %span.k                   %span.nv service_pid
                  %span.o =
                  %span.k ${
                  %span.nv _pid
                  %span.k }
                  = succeed "0" do
                    %span.k return
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> load
                conf_d()
              %p
                Load the /etc/conf.d/{service}.conf configuration file into the calling
                environment.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None, unless the configuration file contains any print statements.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_load_conf_d
            %td.code
              .highlight
                %pre
                  service_load_conf_d
                  %span.o ()
                  %span.o {
                  source_files
                  %span.s2 &quot;${confd_path}/${service}.conf&quot;
                  %span.o }
          %tr
            %td.docs
              %h1 Service init functions.
              %h2
                service
                %em> install
                init_d()
              %p Installs the BDSM service module init.d script for the current extension.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging messages informing the end user of what is occurring.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service_install_init_d
            %td.code
              .highlight
                %pre
                  service_install_init_d
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _service
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.nv _version
                  %span.o =
                  %span.s2 &quot;${2:-${package_version}}&quot;
                  variables_must_be_nonempty _service
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${init_scripts_path}&quot;
                  %span.k then
                  = succeed "user_is_root" do
                    %span.k if
                  %span.k then
                  = succeed "ensure_paths_exist" do
                    %span.k                   %span.s2 &quot;/etc/conf.d&quot;
                  %span.s2 &quot;${init_scripts_path}&quot;
                  log
                  %span.s2 &quot;Installing init scripts for ${_service}&quot;
          %tr
            %td.docs
              %p TODO: Install the service init script...
            %td.code
              .highlight
                %pre
                  %span.k> if
                  template_exists
                  %span.s2 &quot;${_service}&quot;
                  %span.k then
                  = succeed "install_template" do
                    %span.k                   %span.s2 &quot;${_service}&quot;
                  to
                  %span.s2 &quot;${init_scripts_path}/${_service}&quot;
                  %span.se \
                  mode 0755
                  %span.k else
          %tr
            %td.docs
              %p Use core srv init.d template
            %td.code
              .highlight
                %pre
                  install_template
                  %span.s2 &quot;init.d&quot;
                  %span.se \
                  from
                  %span.s2 &quot;${extensions_path}/srv/templates&quot;
                  %span.se \
                  to
                  %span.s2 &quot;${init_scripts_path}/${_service}&quot;
                  mode 0755
                  
                  seed_template
                  %span.s2 &quot;${init_scripts_path}/${_service}&quot;
                  %span.se \
                  modules_path
                  %span.s2 &quot;${modules_path}&quot;
                  %span.se \
                  service
                  %span.s2 &quot;${service}&quot;
                  %span.se \
                  service_user
                  %span.s2 &quot;${service_user}&quot;
                  %span.k fi
                  = succeed "service_activate" do
                    %span.k                   %span.s2 &quot;${service}&quot;
                  %span.s2 &quot;${package_version}&quot;
          %tr
            %td.docs
              %p
                TODO: Replace this with install
                %em> template + seed
                template
            %td.code
              .highlight
                %pre
                  log
                  %span.s2 &quot;%s\n&quot;
                  %span.s2 &quot;[ -d \&quot;${prefix_path}/${_service}/active/bin\&quot; ] &amp;&amp; &quot;
                  %span.se \
                  to
                  %span.s2 &quot;/etc/profile.d/${_service}.sh&quot;
                  log
                  %span.s2 &quot;%s\n&quot;
                  %span.s2 &quot;PATH=\&quot;\$PATH:${prefix_path}/${_service}/active/bin\&quot; ; export PATH; &quot;
                  %span.se \
                  append to
                  %span.s2 &quot;/etc/profile.d/${_service}.sh&quot;
                  chmod_files 0755
                  %span.s2 &quot;/etc/profile.d/${_service}.sh&quot;
                  %span.k fi
                  %span.k else
                  = succeed "0" do
                    %span.k return
                  %span.c # No bin/ dir, no need for it to be in the path.
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> init
                path()
              %p Sets the PATH explicitely for purposes of the current service extension.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p Alters the PATH variable.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service_init_path
            %td.code
              .highlight
                %pre
                  service_init_path
                  %span.o ()
                  %span.o {
                  %span.nv PATH
                  %span.o =
                  %span.s2 &quot;${prefix_path}/bin:/bin:/usr/bin:/usr/local/bin:/sbin:/usr/sbin:/usr/local/sbin:${PATH}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> init
                start()
              %p This is the generalized service init start function.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging telling the end user what is happening.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service_init_start
            %td.code
              .highlight
                %pre
                  service_init_start
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;Starting ${service}...&quot;
                  service_init_path
                  %span.nb local
                  %span.nv _result
                  = succeed "0" do
                    %span.o =
                  %span.nv _command
                  %span.o =(
                  %span.s2 &quot;${service_binary}&quot;
                  %span.o )
                  = succeed "array_is_nonempty" do
                    %span.k if
                  service_start_flags
                  %span.k then
                  = succeed "_command+" do
                    %span.k                   %span.o =(
                  %span.s2 &quot;${service_start_flags[@]}&quot;
                  %span.o )
                  %span.k fi
                  = succeed "array_is_nonempty" do
                    %span.k if
                  service_flags
                  %span.k then
                  = succeed "_command+" do
                    %span.k                   %span.o =(
                  %span.s2 &quot;${service_flags[@]}&quot;
                  %span.o )
                  %span.k fi
                  %span.k if
                  %span.o ((
                  %span.nv service_run_as_root_flag
                  %span.o ==
                  1
                  %span.o ))
                  %span.k then
                  %span.k if
                  %span.k ${
                  %span.nv _command
                  %span.p [*]
                  %span.k }
                  %span.k then
                  %span.k                   %span.nb true
                  %span.nb                   %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;${service} failed to start.&quot;
                  %span.k fi
                  %span.k else
                  %span.k if
                  \! user_run_as
                  %span.s2 &quot;${service_user}&quot;
                  %span.s2 &quot;${_command[*]}&quot;
                  %span.k then
                  %span.k                   %span.nb true
                  %span.nb                   %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;${service} failed to start.&quot;
                  %span.k fi
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> init
                stop()
              %p This is the generalized service init stop function.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging telling the end user what is happening.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service_init_stop
            %td.code
              .highlight
                %pre
                  service_init_stop
                  %span.o ()
                  %span.o {
                  service_init_path
                  %span.k if
                  %span.o ((
                  service_pid &gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Stopping ${service}...&quot;
                  %span.k if
                  %span.nb kill
                  \-QUIT
                  %span.s2 &quot;${service_pid}&quot;
                  %span.k then
                  = succeed "rm" do
                    %span.k                   \-f
                  %span.s2 &quot;$service_pid_file&quot;
                  %span.k else
                  %span.k return
                  %span.nv $?
                  %span.k fi
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Service pid has not been set or is zero.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> init
                status()
              %p This is the generalized service init status function.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging telling the end user what is happening.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service_init_status
            %td.code
              .highlight
                %pre
                  service_init_status
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;statusing ${service}...&quot;
                  service_init_path
                  %span.nb local
                  %span.nv _command
                  %span.o =(
                  %span.s2 &quot;${service_binary}&quot;
                  %span.o )
                  = succeed "array_is_nonempty" do
                    %span.k if
                  service_status_flags
                  %span.k then
                  = succeed "_command+" do
                    %span.k                   %span.o =(
                  %span.s2 &quot;${service_status_flags[@]}&quot;
                  %span.o )
                  %span.k fi
                  = succeed "array_is_nonempty" do
                    %span.k if
                  service_flags
                  %span.k then
                  = succeed "_command+" do
                    %span.k                   %span.o =(
                  %span.s2 &quot;${service_flags[@]}&quot;
                  %span.o )
                  %span.k fi
                  = succeed "user_run_as" do
                    %span.k if
                  %span.s2 &quot;${service_user}&quot;
                  %span.s2 &quot;${_command[*]}&quot;
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "touch" do
                    %span.k                   %span.s2 &quot;$service_pid_file&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> init
                reload()
              %p This is the generalized service init reload function.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging telling the end user what is happening.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service_init_reload
            %td.code
              .highlight
                %pre
                  service_init_reload
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;reloading ${service}...&quot;
                  service_init_path
                  %span.nb local
                  %span.nv _command
                  %span.o =(
                  %span.s2 &quot;${service_binary}&quot;
                  %span.o )
                  = succeed "array_is_nonempty" do
                    %span.k if
                  service_reload_flags
                  %span.k then
                  = succeed "_command+" do
                    %span.k                   %span.o =(
                  %span.s2 &quot;${service_reload_flags[@]}&quot;
                  %span.o )
                  %span.k fi
                  = succeed "array_is_nonempty" do
                    %span.k if
                  service_flags
                  %span.k then
                  = succeed "_command+" do
                    %span.k                   %span.o =(
                  %span.s2 &quot;${service_flags[@]}&quot;
                  %span.o )
                  %span.k fi
                  = succeed "user_run_as" do
                    %span.k if
                  %span.s2 &quot;${service_user}&quot;
                  %span.s2 &quot;${_command[*]}&quot;
                  %span.k then
                  = succeed "touch" do
                    %span.k                   %span.s2 &quot;$service_pid_file&quot;
                  %span.k else
                  %span.k return
                  %span.nv $?
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> init
                usage()
              %p This is the generalized service init usage function.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging telling the end user what is happening.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service_init_usage
            %td.code
              .highlight
                %pre
                  service_init_usage
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;Usage:\n\n  $0 {start|stop|restart|status|info|logtail}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> init
                logtail()
              %p This is the generalized service init logtail function.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging telling the end user what is happening.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service_init_logtail
            %td.code
              .highlight
                %pre
                  service_init_logtail
                  %span.o ()
                  %span.o {
          %tr
            %td.docs
              %p TODO: Adjust this to allow for parameter passing.
            %td.code
              .highlight
                %pre
                  %span.nb> exec
                  tail -n 10
                  %span.s2 &quot;${service_log_file}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> init
                info()
              %p This is the generalized service init info function.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Outputs information about the service (version, etc...).
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service_init_info
            %td.code
              .highlight
                %pre
                  service_init_info
                  %span.o ()
                  %span.o {
                  NIY
                  %span.s2 &quot;service_init_info has not yet been implemented for the service module.&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> conf
                d()
              %p Installs the conf.d template for the service, if it exists.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging updates to inform the user what is happening.
              %h3 Environmental effects
              %p
                Once completed a conf.d file should be in place.
                For example /etc/conf.d/redis.conf for the redis service.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_conf_d
            %td.code
              .highlight
                %pre
                  service_conf_d
                  %span.o ()
                  %span.o {
          %tr
            %td.docs
              %p TODO: Install a default conf.d template if extension does not define one.
            %td.code
              .highlight
                %pre
                  %span.k> if
                  template_exists
                  %span.s2 &quot;conf.d&quot;
                  %span.k then
                  = succeed "install_template" do
                    %span.k                   %span.s2 &quot;conf.d.template&quot;
                  to
                  %span.s2 &quot;/etc/conf.d/${service}.conf&quot;
                  %span.se \
                  mode 0644 owner
                  %span.s2 &quot;${service_user}:${service_user}&quot;
                  = succeed "template_exists" do
                    %span.k if
                  %span.s2 &quot;/etc/conf.d/${service}.conf&quot;
                  %span.k then
                  = succeed "seed_template" do
                    %span.k                   %span.s2 &quot;/etc/conf.d/${service}.conf&quot;
                  %span.se \
                  prefix_path
                  %span.s2 &quot;${prefix_path}&quot;
                  %span.se \
                  init_scripts_path
                  %span.s2 &quot;${init_scripts_path}&quot;
                  %span.se \
                  modules_path
                  %span.s2 &quot;${modules_path}&quot;
                  %span.se \
                  data_path
                  %span.s2 &quot;${data_path}&quot;
                  %span.se \
                  confd_path
                  %span.s2 &quot;${confd_path}&quot;
                  %span.se \
                  extension
                  %span.s2 &quot;${service}&quot;
                  %span.se \
                  service
                  %span.s2 &quot;${service}&quot;
                  %span.k fi
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> init
                start()
              %p This is the generalized service init start function.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging telling the end user what is happening.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service_init_action start
            %td.code
              .highlight
                %pre
                  service_init_action
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _action
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  service_load_conf_d
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${service}_${action}&quot;
                  %span.k then
                  %span.s2 &quot;${service}_${action}&quot;
                  %span.k else
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;${service_actions[*]}&quot;
                  %span.o =
                  *
                  %span.o> [[
                  \:space:
                  %span.o ]]
                  %span.k ${
                  %span.nv action
                  %span.k }
                  = succeed ":space:" do
                    %span.o [[
                  = succeed "*" do
                    %span.o ]]
                  %span.o ]]
                  %span.k then
                  = succeed "service_init_" do
                    %span.k                   %span.k ${
                  %span.nv action
                  %span.k }
                  %span.k else
                  = succeed "service_init_usage" do
                    %span.k                   %span.k fi
                  %span.k fi
                  %span.k return
                  %span.nv $?
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> init
                d()
              %p The main logic for generalized service init.d scripts.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging updates to inform the user what is happening.
              %h3 Environmental effects
              %p May alter the runstate of the service extension.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_init_d
            %td.code
              .highlight
                %pre
                  service_init_d
                  %span.o ()
                  %span.o {
                  enable_backtrace
                  %span.c # Enable backtrace on script error.
                  service_load_conf_d
                  %span.c # Load the configuration file.
          %tr
            %td.docs
              %p Sanity checks go here.
            %td.code
              .highlight
                %pre
                  %span.k> if
                  file_is_executable
                  %span.s2 &quot;${service_binary}&quot;
                  %span.k then
                  = succeed "service_pid" do
                    %span.k                   service_cli
                  %span.c # Parse the script arguments and take action accordingly.
                  service_init_action
                  %span.s2 &quot;${service_action}&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Could not find ${service_binary} or ${service_binary} is not executable.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 service_deactivate()
              %p Deactivates the named service or
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging updates to inform the user what is happening.
              %h3 Environmental effects
              %p Changes the current or named service's init script to be nonexecutable.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_deactivate
            %td.code
              .highlight
                %pre
                  service_deactivate
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _service
                  %span.o =
                  %span.s2 &quot;${1:-&quot;
                  %span.k ${
                  %span.nv service
                  %span.k }
                  %span.s2 &quot;}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_service}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;a service name must be set or passed in in order to deactivate a service.&quot;
                  %span.k fi
                  = succeed "file_exists" do
                    %span.k if
                  %span.s2 &quot;${init_scripts_path}/${_service}&quot;
                  %span.k then
                  = succeed "chmod_files" do
                    %span.k                   0644
                  %span.s2 &quot;${init_scripts_path}/${_service}&quot;
                  = succeed "user_is_root" do
                    %span.k if
                  %span.k then
                  %span.c # Add service to system startup
                  = succeed "command_exists" do
                    %span.k if
                  rc-update
                  %span.k then
                  = succeed "rc-update" do
                    %span.k                   add
                  %span.k ${
                  %span.nv service
                  %span.k }
                  default
                  = succeed "command_exists" do
                    %span.k elif
                  chkconfig
                  %span.k then
                  = succeed "chkconfig" do
                    %span.k                   %span.k ${
                  %span.nv service
                  %span.k }
                  on
                  %span.c #elif command_exists svc
                  %span.c #then
          %tr
            %td.docs
              %p svc ${service} on # TODO: daemontools start on boot
            %td.code
              .highlight
                %pre
                  %span.k else
                  %span.c # Fall back on rc.local to start redis at system startup.
                  %span.k if
                  \! file_contains
                  %span.s2 &quot;/etc/rc.local&quot;
                  %span.s2 &quot;${service} start&quot;
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;${init_scripts_path}/${service} start&quot;
                  %span.se \
                  append to /etc/rc.local
                  %span.k fi
                  %span.k fi
                  %span.k fi
                  %span.k fi
          %tr
            %td.docs
              %p TDOO: hook into system's paths.
            %td.code
              .highlight
                %pre
                  %span.o }
          %tr
            %td.docs
              %h2 service_activate()
              %p Activates the named service or
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging updates to inform the user what is happening.
              %h3 Environmental effects
              %p Changes the current or named service's init script to be nonexecutable.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_deactivate
            %td.code
              .highlight
                %pre
                  service_activate
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _service
                  %span.o =
                  %span.s2 &quot;${1:-&quot;
                  %span.k ${
                  %span.nv service
                  %span.k }
                  %span.s2 &quot;}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_service}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;the service name must be set or passed in in order to activate a service.&quot;
                  %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _version
                  %span.o =
                  %span.s2 &quot;${2:-${package_version}}&quot;
                  variables_must_be_nonempty _service _version
                  = succeed "symlink_exists" do
                    %span.k if
                  %span.s2 &quot;${service_db_path}/active&quot;
                  %span.k then
                  = succeed "service_deactivate" do
                    %span.k                   %span.s2 &quot;${_service}&quot;
                  %span.k fi
                  %span.k if
                  \! directory_exists
                  %span.s2 &quot;${service_db_path}/${_version}&quot;
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Skipping activation of ${_service} ${_version} as '${install_path}' does not exist.&quot;
                  %span.k fi
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Activating service ${_service} version ${_version}&quot;
                  link --force
                  %span.s2 &quot;${service_db_path}/${_version}&quot;
                  to
                  %span.s2 &quot;${service_db_path}/active&quot;
                  = succeed "file_exists" do
                    %span.k if
                  %span.s2 &quot;${init_scripts_path}/${service}&quot;
                  %span.k then
                  = succeed "chmod_files" do
                    %span.k                   0755
                  %span.s2 &quot;${init_scripts_path}/${service}&quot;
                  = succeed "os_is_linux" do
                    %span.k if
                  %span.k then
                  = succeed "user_is_root" do
                    %span.k if
                  %span.k then
                  %span.c # Add service to system startup
                  = succeed "command_exists" do
                    %span.k if
                  rc-update
                  %span.k then
                  = succeed "rc-update" do
                    %span.k                   remove
                  %span.k ${
                  %span.nv service
                  %span.k }
                  default
                  = succeed "command_exists" do
                    %span.k elif
                  chkconfig
                  %span.k then
                  = succeed "chkconfig" do
                    %span.k                   %span.k ${
                  %span.nv service
                  %span.k }
                  off
                  %span.c #elif command_exists svc
                  %span.c #then
          %tr
            %td.docs
              %p
                svc ${service} off
                TODO: daemontools remove start on boot
            %td.code
              .highlight
                %pre
                  %span.k else
                  %span.c # Fall back on rc.local to start redis at system startup.
                  %span.k if
                  \! file_contains
                  %span.s2 &quot;/etc/rc.local&quot;
                  %span.s2 &quot;${service} start&quot;
                  %span.k then
                  = succeed "sed" do
                    %span.k                   \-i -e
                  %span.s2 &quot;d#${init_scripts_path}/${service} start#&quot;
                  \/etc/rc.local
                  %span.k fi
                  %span.k fi
                  %span.k fi
                  = succeed "os_is_darwin" do
                    %span.k elif
                  %span.k then
                  %span.k                   %span.nb true
                  %span.c # TODO: launchctl
                  %span.k else
                  %span.c # ::shrug::
                  %span.k if
                  \! file_contains
                  %span.s2 &quot;/etc/rc.local&quot;
                  %span.s2 &quot;${service} start&quot;
                  %span.k then
                  = succeed "sed" do
                    %span.k                   \-i -e
                  %span.s2 &quot;d#${init_scripts_path}/${service} start#&quot;
                  \/etc/rc.local
                  %span.k fi
                  %span.k fi
                  %span.k fi
                  %span.o }
                  service_status
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;${service}:&quot;
                  %span.k if
                  %span.o [[
                  \-s
                  %span.s2 &quot;${service_pid_file}&quot;
                  %span.o ]]
                  %span.o &amp;&amp;
                  %span.o ((
                  = succeed "head" do
                    %span.k $(
                  \-1
                  %span.k ${
                  %span.nv service_pid_file
                  %span.k })
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nb local
                  %span.nv pid
                  %span.o =
                  = succeed "head" do
                    %span.k $(
                  \-1
                  %span.k ${
                  %span.nv service_pid_file
                  %span.k })
                  %span.nb local
                  %span.nv ps
                  %span.o =
                  = succeed "ps" do
                    %span.k $(
                  \-p
                  %span.k ${
                  %span.nv pid
                  %span.k }
                  \-ostate,sgi_rss,vsize | tail -1
                  %span.k )
                  log
                  %span.s2 &quot;  status: running&quot;
                  log
                  %span.s2 &quot;  version: ${service_version}&quot;
                  log
                  %span.s2 &quot;  process: &quot;
                  log
                  %span.s2 &quot;    pid: ${pid}&quot;
                  = succeed "os_is_linux" do
                    %span.k if
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;    parent_pid: $(awk  '/^PPid:/{print $2}' /proc/${pid}/status)&quot;
                  log
                  %span.s2 &quot;    state: $(printf &quot;
                  %span.nv $ps
                  %span.s2 &quot; | awk '{print $1}')&quot;
                  log
                  %span.s2 &quot;    rss: $(printf &quot;
                  %span.nv $ps
                  %span.s2 &quot; | awk '{print $2}')&quot;
                  log
                  %span.s2 &quot;    vsz: $(printf &quot;
                  %span.nv $ps
                  %span.s2 &quot; | awk '{print $3}')&quot;
                  %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  lsof
                  %span.k then
                  %span.k                   %span.nb local
                  %span.nv cwd
                  %span.o =
                  %span.nv binary
                  %span.o =
                  %span.nv libraries
                  %span.o =()
                  %span.nv tcp_ports
                  %span.o =()
                  %span.nv udp_ports
                  %span.o =()
                  %span.nv sockets
                  %span.o =()
                  %span.nv logs
                  %span.o =()
                  string
                  %span.k while
                  %span.nb read
                  \-r line
                  %span.k do
                  %span.k case
                  %span.s2 &quot;$line&quot;
                  in
                  = succeed "*" do
                    %span.o (
                  = succeed ":space:" do
                    %span.o [[
                  = succeed "cwd" do
                    %span.o ]]
                  = succeed ":space:" do
                    %span.o [[
                  = succeed "*" do
                    %span.o ]]
                  %span.o )
                  %span.nv cwd
                  %span.o =
                  %span.s2 &quot;${line##* }&quot;
                  ;;
                  = succeed "*" do
                    %span.o (
                  = succeed ":space:" do
                    %span.o [[
                  = succeed "txt" do
                    %span.o ]]
                  = succeed ":space:" do
                    %span.o [[
                  = succeed "*" do
                    %span.o ]]
                  %span.o )
                  %span.nv binary
                  %span.o =
                  %span.s2 &quot;${line##* }&quot;
                  ;;
                  = succeed "*/lib/*" do
                    %span.o (
                  %span.o )
                  %span.nv string
                  %span.o =
                  %span.s2 &quot;${line%% (*}&quot;
                  libraries+
                  %span.o =(
                  %span.s2 &quot;${string##* }&quot;
                  %span.o )
                  ;;
                  = succeed "*.log*" do
                    %span.o (
                  %span.o )
                  logs+
                  %span.o =(
                  %span.s2 &quot;${line##* }&quot;
                  %span.o )
                  ;;
                  = succeed "*.sock*" do
                    %span.o (
                  %span.o )
                  sockets+
                  %span.o =(
                  %span.s2 &quot;${line##* }&quot;
                  %span.o )
                  ;;
                  = succeed "*TCP*" do
                    %span.o (
                  %span.o )
                  %span.nv string
                  %span.o =
                  %span.s2 &quot;${line%% (*}&quot;
                  tcp_ports+
                  %span.o =(
                  %span.s2 &quot;${string##* }&quot;
                  %span.o )
                  ;;
                  = succeed "*" do
                    %span.o (
                  %span.o )
                  %span.nb true
                  %span.c # ignore
                  ;;
                  %span.k esac
                  %span.k done
                  \&lt; &lt;
                  %span.o> (
                  lsof -U -p
                  %span.k ${
                  %span.nv pid
                  %span.k }
                  %span.o )
                  log
                  %span.s2 &quot;    cwd: ${cwd}&quot;
                  log
                  %span.s2 &quot;    binary: ${binary}&quot;
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv logs
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;    logs:&quot;
                  array_sort_asc logs
                  array_unique logs
                  = succeed "log" do
                    %span.k for
                  in
                  %span.s2 &quot;${logs[@]}&quot;
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot;      - %s\n&quot;
                  %span.s2 &quot;${log}&quot;
                  %span.k done
                  %span.k fi
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv libraries
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;    libraries:&quot;
                  array_sort_asc libraries
                  array_unique libraries
                  = succeed "library" do
                    %span.k for
                  in
                  %span.s2 &quot;${libraries[@]}&quot;
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot;      - %s\n&quot;
                  %span.s2 &quot;${library}&quot;
                  %span.k done
                  %span.k fi
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv tcp_ports
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;    tcp_ports:&quot;
                  array_sort_asc tcp_ports
                  array_unique tcp_ports
                  = succeed "tcp_port" do
                    %span.k for
                  in
                  %span.s2 &quot;${tcp_ports[@]}&quot;
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot;      - %s\n&quot;
                  %span.s2 &quot;${tcp_port}&quot;
                  %span.k done
                  %span.k fi
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv sockets
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;    sockets:&quot;
                  array_sort_asc sockets
                  array_unique sockets
                  = succeed "socket" do
                    %span.k for
                  in
                  %span.s2 &quot;${sockets[@]}&quot;
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot;      - %s\n&quot;
                  %span.s2 &quot;${socket}&quot;
                  %span.k done
                  %span.k fi
                  %span.k fi
                  %span.k else
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;  status: not running&quot;
                  %span.k fi
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2
                init
                %em> scripts
                path()
              %p Returns the system init scripts path (eg. /etc/init.d /etc/rc.d)
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p The system init scripts path is printed to the calling environments STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Fails the OS is not of a (yet) recognized type.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user@archlinux$ init_scripts_path
                    /etc/rc.d
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  init_scripts_path
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o ((
                  %span.nv UID
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  %span.k case
                  %span.s2 &quot;$MACHTYPE&quot;
                  in
                  *darwin*
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;/etc/init.d&quot;
                  %span.c # Service module will create and use this.
                  ;;
                  
                  *linux-gnu*|*
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;/etc/init.d&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb printf
                  %span.s2 &quot;/etc/init.d&quot;
                  %span.k elif
                  %span.o [[
                  \-d
                  %span.s2 &quot;/etc/rc.d&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb printf
                  %span.s2 &quot;/etc/rc.d&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Unknown init scripts directory (/etc/init.d or /etc/rc.d not found).&quot;
                  %span.k fi
                  ;;
                  %span.k esac
                  %span.k else
                  %span.k                   %span.nb printf
                  %span.s2 &quot;$HOME/.init.d&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 confd_path()
              %p Return the system conf.d path.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Prints the conf.d path for the current system and user.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    root# confd_path
                    /etc/conf.d
            %td.code
              .highlight
                %pre
                  confd_path
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o ((
                  %span.nv UID
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nb printf
                  %span.s2 &quot;/etc/conf.d&quot;
                  %span.k else
                  %span.k                   %span.nb printf
                  %span.s2 &quot;$HOME/.conf.d&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                os
                %em> is
                linux()
              %p Tests if the operating system the process is running on is Linux.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the operating system is linux
                1 if the operating system is not linux
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    root@archlinux# os_is_linux
                    root@archlinux# echo $?
                    0
            %td.code
              .highlight
                %pre
                  os_is_linux
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;$MACHTYPE&quot;
                  %span.o =
                  *linux*
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                os
                %em> is
                darwin()
              %p Tests if the operating system the process is running on is darwin.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the operating system is darwin
                1 if the operating system is not darwin
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user@OSX# os_is_darwin
                    user@OSX# echo $?
                    0
            %td.code
              .highlight
                %pre
                  os_is_darwin
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;$MACHTYPE&quot;
                  %span.o =
                  *darwin*
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                os
                %em> is
                bsd()
              %p Tests if the operating system the process is running on is bsd.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the operating system is bsd
                1 if the operating system is not bsd
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    root@bsd# os_is_bsd
                    root@bsd# echo $?
                    0
            %td.code
              .highlight
                %pre
                  os_is_bsd
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;$MACHTYPE&quot;
                  %span.o =
                  *bsd*
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                os
                %em> is
                solaris()
              %p Tests if the operating system the process is running on is solaris.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the operating system is linux
                1 if the operating system is not linux
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    root@linux# os_is_linux
                    root@linux# echo $?
                    0
            %td.code
              .highlight
                %pre
                  os_is_solaris
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;$MACHTYPE&quot;
                  %span.o =
                  *solaris*
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                os
                %em> is
                aix()
              %p Tests if the operating system the process is running on is aix.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the operating system is aix
                1 if the operating system is not aix
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    root@aix# os_is_aix
                    root@aix# echo $?
                    0
            %td.code
              .highlight
                %pre
                  os_is_aix
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;$MACHTYPE&quot;
                  %span.o =
                  *aix*
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 os_type()
              %p Prints out the operating system category / type.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Prints the OS category/type to the calling environments STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    root@archlinux# os_type
                    linux
                    
                    user@osx# os_type
                    darwin
            %td.code
              .highlight
                %pre
                  os_type
                  %span.o ()
                  %span.o {
                  %span.k case
                  %span.s2 &quot;$MACHTYPE&quot;
                  in
                  = succeed "*linux*" do
                    %span.o (
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;linux&quot;
                  ;;
                  = succeed "*darwin*" do
                    %span.o (
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;darwin&quot;
                  ;;
                  = succeed "*bsd*" do
                    %span.o (
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;bsd&quot;
                  ;;
                  = succeed "*solaris*" do
                    %span.o (
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;solaris&quot;
                  ;;
                  = succeed "*aix*" do
                    %span.o (
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;aix&quot;
                  ;;
                  = succeed "*" do
                    %span.o (
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;$MACHTYPE&quot;
                  ;;
                  %span.k esac
                  %span.o }
          %tr
            %td.docs
              %h2
                os
                %em> arch
                type()
              %p Prints out the OS Arch type.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                Prints out the architecture type string of the system that is running the
                current process.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ os_arch_type
                    x86_64
            %td.code
              .highlight
                %pre
                  os_arch_type
                  %span.o ()
                  %span.o {
                  %span.k case
                  %span.s2 &quot;${MACHTYPE//-*}&quot;
                  in
                  = succeed "i386|i686|i86pc" do
                    %span.o (
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;i386&quot;
                  ;;
                  = succeed "*x86_64*" do
                    %span.o (
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;x86_64&quot;
                  ;;
                  = succeed "*ppc*" do
                    %span.o (
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;ppc&quot;
                  ;;
                  %span.k esac
                  %span.o }
          %tr
            %td.docs
              %h2 os_arch()
              %p Prints out the full OS machine type string.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Print the OS machine type string to STDOUT of the calling environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user@OSX# os_arch
                    i386-apple-darwin10.7.0
            %td.code
              .highlight
                %pre
                  os_arch
                  %span.o ()
                  %span.o {
                  %span.nb printf
                  %span.s1 '%s'
                  %span.s2 &quot;${MACHTYPE//-*}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                os
                %em> arch
                capable()
              %p Tests if the operating system the process is running on is Linux.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the operating system is linux
                1 if the operating system is not linux
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user@OSX$ os_arch_capable
                    x86_64
            %td.code
              .highlight
                %pre
                  os_arch_capable
                  %span.o ()
                  %span.o {
                  = succeed "os_is_darwin" do
                    %span.k if
                  %span.k then
                  %span.k                   = succeed "_string" do
                    %span.nb local
                  %span.nb read
                  \-r _string &lt; &lt;
                  %span.o> (
                  sysctl hw.cpu64bit_capable
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${
                  %span.nv _string
                  %span.p //*
                  %span.k }
                  %span.o ==
                  1
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;x86_64&quot;
                  %span.k else
                  = succeed "os_arch_type" do
                    %span.k                   %span.c # Either i386 or ppc
                  %span.k fi
                  %span.k else
                  = succeed "os_arch_type" do
                    %span.k                   %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                os
                %em> cpu
                count()
              %p Print the number of cpu cores on the current system to STDOUT
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p An integer representing the number of CPU cores or 1 if unknown.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ os_cpu_count
                    24
            %td.code
              .highlight
                %pre
                  os_cpu_count
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _count
                  = succeed "1" do
                    %span.o =
                  %span.c # Defaulting to 1.
                  = succeed "os_is_darwin" do
                    %span.k if
                  %span.k then
                  %span.k                   %span.nb read
                  \-r _count &lt; &lt;
                  %span.o> (
                  sysctl hw.ncpu
                  %span.o )
                  %span.nv _count
                  %span.o =
                  %span.s2 &quot;${_count//* }&quot;
                  = succeed "os_is_linux" do
                    %span.k elif
                  %span.k then
                  %span.k                   %span.nv _count
                  %span.o =
                  = succeed "awk" do
                    %span.k $(
                  %span.s1 '/^processor/{count++} END{print count}'
                  \/proc/cpuinfo 2&gt;&amp;1
                  %span.k )
                  %span.k fi
                  %span.k                   %span.nb printf
                  %span.s1 '%d'
                  %span.k ${
                  %span.nv _count
                  %span.k }
                  %span.o }
          %tr
            %td.docs
              %h2 os_version()
              %p Prints the OS version to STDOUT and sets the 'os_version' variable
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p The OS (Kernel) Version is printed to STDOUT.
              %h3 Environmental effects
              %p
                After running this function the os version is stored in the 'os_version'
                variable.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user@archlinux$ os_version
                    2.6.38
                    
                    user@osx$ os_version
                    10.7.0
            %td.code
              .highlight
                %pre
                  os_version
                  %span.o ()
                  %span.o {
                  %span.nb read
                  \-r os_version &lt; &lt;
                  %span.o> (
                  uname -r
                  %span.o )
                  %span.nv os_version
                  %span.o =
                  %span.k ${
                  %span.nv os_version
                  %span.p //-*
                  %span.k }
                  %span.nb printf
                  %span.s1 '%s'
                  %span.s2 &quot;${os_version}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                os
                %em> version
                major()
              %p
                Prints the OS major version to STDOUT and sets the 'os
                %em> version
                major' variable
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p The OS Major Version is printed to STDOUT.
              %h3 Environmental effects
              %p
                After running this function the os major version is stored in the
                'os
                %em> version
                major' variable.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user@archlinux$ os_version
                    2.6.38
                    
                    user@osx$ os_version_major
                    2
            %td.code
              .highlight
                %pre
                  os_version_major
                  %span.o ()
                  %span.o {
                  %span.nv os_version_major
                  %span.o =
                  = succeed "os_version" do
                    %span.k $(
                  %span.k )
                  %span.nv os_version_major
                  %span.o =
                  %span.s2 &quot;${os_version_major//\.*}&quot;
                  %span.nb printf
                  %span.s2 &quot;${os_version_major}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                os
                %em> version
                minor()
              %p
                Prints the OS minor version to STDOUT and sets the 'os
                %em> version
                minor' variable
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p The OS minor Version is printed to STDOUT.
              %h3 Environmental effects
              %p
                After running this function the os minor version is stored in the
                'os
                %em> version
                minor' variable.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user@archlinux$ os_version
                    2.6.38
                    
                    user@osx$ os_version_minor
                    6
            %td.code
              .highlight
                %pre
                  os_version_minor
                  %span.o ()
                  %span.o {
                  %span.nv os_version_minor
                  %span.o =
                  = succeed "os_version" do
                    %span.k $(
                  %span.k )
                  %span.nv os_version_minor
                  %span.o =
                  %span.s2 &quot;${os_version_minor#*\.}&quot;
                  %span.nv os_version_minor
                  %span.o =
                  %span.s2 &quot;${os_version_minor%\.*}&quot;
                  %span.nb printf
                  %span.s2 &quot;${os_version_minor}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                os
                %em> version
                patch()
              %p
                Prints the OS patch version to STDOUT and sets the 'os
                %em> version
                patch' variable
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p The OS patch Version is printed to STDOUT.
              %h3 Environmental effects
              %p
                After running this function the os patch version is stored in the
                'os
                %em> version
                patch' variable.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user@archlinux$ os_version
                    2.6.38
                    
                    user@osx$ os_version_patch
                    38
            %td.code
              .highlight
                %pre
                  os_version_patch
                  %span.o ()
                  %span.o {
                  %span.nv os_version_patch
                  %span.o =
                  = succeed "os_version" do
                    %span.k $(
                  %span.k )
                  %span.nv os_version_patch
                  %span.o =
                  %span.s2 &quot;${os_version_patch//*\.}&quot;
                  %span.nb printf
                  %span.s2 &quot;${os_version_patch}&quot;
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 template_exists()
              %p
                Checks if a named template file exists in the extension
                %em> templates
                path
              %h3 Input Parameters
              %p First parameter must be the name of a template file, eg. a string.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p
                0 if the named template file exists and is nonempty.
                1 if the named template file does not exist or is empty.
              %h3 Failure Scenarios
              %p Fails if no template name is given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ {{ setup the scenario }}
                    user$ function_name {{ parameters }}
                    user$ {{ demonstrate the results}}
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  template_exists
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${1:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check if a template exists as no template name was given.&quot;
                  %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _template
                  %span.o =
                  %span.s2 &quot;${extension_templates_path}/${1}.template&quot;
                  %span.k if
                  %span.o [[
                  \-s
                  %span.s2 &quot;${_template}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 install_template()
              %p Installs a named template to a given location.
              %h3 Input Parameters
              %p
                The first parameter should be the template name.
                Remaining parameters specify the target, mode and owner:
                owner "&lt;
                %user
                  >[:&lt;
                  %group
                    >]"
                    mode 0755
                    to "/path/to/new/file"
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p
                0 if successful
                1 otherwise
              %h3 Failure Scenarios
              %p
                Fails if no template name was given.
                Fails if the template name given is a directory.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ install_template "nginx.conf" \
                          to "${nginx_path}/nginx.conf" \
                          mode 0644 owner "${nginx_user}"
            %td.code
              .highlight
                %pre
                  install_template
                  %span.o ()
                  %span.o {
                  = succeed "_template" do
                    %span.nb local
                  _name _target
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;${extension_templates_path}&quot;
                  %span.nv _mode
                  = succeed "0644" do
                    %span.o =
                  %span.nv _owner
                  %span.o =
                  %span.nv $USER
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  ;
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  ;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${token}&quot;
                  in
                  to
                  %span.o )
                  %span.nv _target
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  ;
                  %span.nb shift
                  ;;
                  
                  mode
                  %span.o )
                  %span.nv _mode
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  ;
                  %span.nb shift
                  ;;
                  
                  owner
                  %span.o )
                  %span.nv _owner
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  ;
                  %span.nb shift
                  ;;
                  
                  from
                  %span.o )
                  %span.c # TODO: finish this part.
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  ;
                  %span.nb shift
                  ;;
                  
                  *
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_name}&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  %span.k                   %span.nv _name
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.k elif
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  %span.k                   %span.nv _target
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.nb break
                  %span.c # When we have a target we are done.
          %tr
            %td.docs
              %p
                An alternative idea would be to allow an array of multiple targets
                to symlink to...
            %td.code
              .highlight
                %pre
                  %span.k fi
                  ;;
                  %span.k esac
                  %span.k done
                  = succeed "file_exists" do
                    %span.k if
                  %span.s2 &quot;${_name}&quot;
                  %span.k then
                  %span.k                   %span.nv _template
                  %span.o =
                  %span.s2 &quot;${_name}&quot;
                  = succeed "file_exists" do
                    %span.k elif
                  %span.s2 &quot;${_source}/${_name}&quot;
                  %span.k then
                  %span.k                   %span.nv _template
                  %span.o =
                  %span.s2 &quot;${_source}/${_name}&quot;
                  %span.k else
                  %span.k                   %span.nv _template
                  %span.o =
                  %span.s2 &quot;${_source}/${_name}.template&quot;
                  %span.k fi
                  = succeed "ensure_paths_exist" do
                    %span.k                   %span.s2 &quot;$(dirname &quot;
                  %span.k ${
                  %span.nv _target
                  %span.k }
                  %span.s2 &quot;)&quot;
                  %span.k if
                  %span.o [[
                  \-f
                  %span.s2 &quot;${_template}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_target}/${_name}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot install the template '${_template}' to ${_target}/${_name} &quot;
                  %span.se \
                  %span.s2 &quot; as it is a directory&quot;
                  %span.k else
                  = succeed "cp" do
                    %span.k                   \-f
                  %span.s2 &quot;${_template}&quot;
                  %span.s2 &quot;${_target}/${_name}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_mode:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "chmod" do
                    %span.k                   %span.s2 &quot;${_mode}&quot;
                  %span.s2 &quot;${_target}/${_name}&quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_owner:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "chown" do
                    %span.k                   %span.s2 &quot;${_owner}&quot;
                  %span.s2 &quot;${_target}/${_name}&quot;
                  %span.k fi
                  %span.k fi
                  %span.k else
                  = succeed "cp" do
                    %span.k                   \-f
                  %span.s2 &quot;${_template}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_mode:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "chmod" do
                    %span.k                   %span.s2 &quot;${_mode}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_owner:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "chown" do
                    %span.k                   %span.s2 &quot;${_owner}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k fi
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot install template as the template file '${_template}' is missing.'&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 seed_template()
              %p Seed a template file replacing all given keys with given values.
              %h3 Input Parameters
              %p
                First parameter must be the template filename to seed.
                Remaining parameters must come in pairs, the first of each pair specifies
                the key to search and replace in the template file and the second is the
                value to replace {{$key}} with.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no template filename is given.
                Fails if the template given does not exist.
                Fails if no key/value pairs are given.
                Fails if for every key there is no associated value.
                Fails if the intermediate template file does not exist...
              %h3 Usage Examples
              %p
                user$ seed
                %em>
                  template "/etc/conf.d/${extension}.conf" \
                  prefix
                path "${prefix
                %em>
                  path}" \
                  init
                scripts
                %em> path "${init
                scripts
                %em>
                  path}" \
                  modules
                path "${modules
                %em>
                  path}" \
                  data
                path "${data
                %em>
                  path}" \
                  confd
                path "${confd_path}" \
                extension "${extension}"
            %td.code
              .highlight
                %pre
                  seed_template
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _template
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_template}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb local
                  %span.nv _args
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.nv _strings
                  %span.o =()
                  %span.k if
                  %span.o [[
                  \-f
                  %span.s2 &quot;${_template}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _args
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot seed template '${_template}' as no replacement keys were&quot;
                  %span.se \
                  %span.s2 &quot;specified&quot;
                  %span.k else
                  %span.k if
                  %span.o ((
                  %span.o (
                  %span.k ${#
                  %span.nv _args
                  %span.p [@]
                  %span.k }
                  \% 2
                  %span.o )
                  %span.o ==
                  1
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Every replacement key must have a replacement value.&quot;
                  %span.k fi
                  %span.k fi
                  = succeed "warn" do
                    %span.k                   %span.s2 &quot;Template Seeding (replacing defaults) has not yet fully implemented.&quot;
          %tr
            %td.docs
              %p Aggregate the replacement strings.
            %td.code
              .highlight
                %pre
                  %span.k for
                  %span.o ((
                  %span.nv index
                  = succeed "0" do
                    %span.o =
                  ; index &lt;
                  %span.k ${#
                  %span.nv _args
                  %span.p [@]
                  %span.k }
                  ; index++
                  %span.o ))
                  %span.k do
                  = succeed "_strings+" do
                    %span.k                   %span.o =(
                  %span.s2 &quot; -e 's#${_args[${index}]}#${_args[$((++index))]}#g' &quot;
                  %span.o )
                  %span.k done
          %tr
            %td.docs
              %p Filter the template with the replacments.
            %td.code
              .highlight
                %pre
                  sed
                  %span.k ${
                  %span.nv _strings
                  %span.p [@]
                  %span.k }
                  %span.k ${
                  %span.nv _template
                  %span.k }
                  \&gt;&gt;
                  %span.k ${
                  %span.nv _template
                  = succeed "." do
                    %span.k }
                  %span.k ${
                  %span.nv timestamp
                  %span.k }
                  = succeed "file_exists" do
                    %span.k if
                  %span.s2 &quot;${_template}.${timestamp}&quot;
                  %span.k then
                  = succeed "mv" do
                    %span.k                   \-f
                  %span.s2 &quot;${_template}.${timestamp}&quot;
                  %span.s2 &quot;${_template}&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Something went horribly wrong, the template intermediate file &quot;
                  %span.se \
                  %span.s2 &quot;'${_template}.${timestamp}' does not exist.&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Can not seed template template file '${_template}' does not exist.&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Can not install template as no template was given.&quot;
                  %span.k fi
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 timestamp_set()
              %p Sets the variable named 'timestamp' to the current timestamp.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p Sets the variable named 'timestamp' to the current timestamp.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat ./test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules trace time # Load the trace module.
                    
                    timestamp_set
                    echo $timestamp
                    
                    user$ $PWD/test
                    2011-04-24T22:28:16
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  timestamp_set
                  %span.o ()
                  %span.o {
                  %span.nv timestamp
                  %span.o =
                  = succeed "timestamp" do
                    %span.k $(
                  %span.k )
                  %span.o }
          %tr
            %td.docs
              %h2 timestamp()
              %p Prints out the current timestamp.
              %h3 Input Parameters
              %p
                None required. The first parameter may optionally specify the format to output
                the time string in. See 'man 1 date' for formatting options.
              %h3 Stream Outputs
              %p
                Prints the current timestamp as a formatted datetime string to the STDOUT of
                the calling environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat ./test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules trace time # Load the trace module.
                    
                    timestamp
                    echo
                    
                    user$ $PWD/test
                    2011-04-24T22:31:54
            %td.code
              .highlight
                %pre
                  timestamp
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _format
                  %span.o =
                  = succeed "%Y-%m-%dT%H:%M:%S" do
                    %span.s2 &quot;${1:-&quot;
                  %span.s2 &quot;}&quot;
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;$(date +&quot;
                  %span.k ${
                  %span.nv _format
                  %span.k }
                  %span.s2 &quot;)&quot;
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 set_ps4()
              %p Set the environmental PS4 variable for informative tracing.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ echo "'$PS4'"
                    '+ '
                    user$ set_ps4
                    user$ echo "'$PS4'"
                    ' &gt; ${BASH_SOURCE##${bdsm_path}\/} ${FUNCNAME[0]:+${FUNCNAME[0]}()} ${LINENO} $ '
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  set_ps4
                  %span.o ()
                  %span.o {
                  %span.nv PS4
                  %span.o =
                  %span.s2 &quot; &gt; \${BASH_SOURCE##\${bdsm_path}\/} \${FUNCNAME[0]:+\${FUNCNAME[0]}()} \${LINENO} $ &quot;
                  = succeed "PS4" do
                    %span.nb export
                  %span.o }
          %tr
            %td.docs
              %h2 trace()
              %p
                Toggle tracing functionality on or off. If 'on' is triggered then every line
                of code execution after the function returns will be displayed in the format
                specified by the PS4 environment variable (see set_ps4).
              %h3 Input Parameters
              %p First parameter is either empty, 'on' or 'off'
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ trace on
                    user$ echo "hi"
                    &gt;   1 $ echo hi
                    user$ trace off
                    &gt;  trace() 1 $ local _option=off
                    &gt;  trace() 3 $ [[ off = \o\n ]]
                    &gt;  trace() 8 $ set +o xtrace
            %td.code
              .highlight
                %pre
                  trace
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _option
                  %span.o =
                  %span.s2 &quot;${1:-on}&quot;
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;${_option}&quot;
                  %span.o =
                  %span.s2 &quot;on&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb export
                  %span.nv trace_flag
                  = succeed "1" do
                    %span.o =
                  %span.nb set
                  \-o xtrace
                  %span.k else
                  %span.k                   %span.nb set
                  +o xtrace
                  %span.nb export
                  %span.nv trace_flag
                  = succeed "0" do
                    %span.o =
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 enable_trace()
              %p Turns tracing on.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ enable_trace
            %td.code
              .highlight
                %pre
                  enable_trace
                  %span.o ()
                  %span.o {
                  trace on
                  %span.o }
          %tr
            %td.docs
              %h2 disable_trace()
              %p Turns tracing off.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No current failure scenarios.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ disable_trace
            %td.code
              .highlight
                %pre
                  disable_trace
                  %span.o ()
                  %span.o {
                  trace off
                  %span.o }
          %tr
            %td.docs
              %h2 debug()
              %p
                Toggle verbose debugging functionality on or off. If 'on' is triggered then
                every line of code execution after the function returns will be displayed.
              %h3 Input Parameters
              %p First parameter is either empty, 'on' or 'off'
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ debug on
                    user$ echo "hi"
                    &gt;   1 $ echo hi
                    user$ debug off
                    &gt;  debug() 1 $ local _option=off
                    &gt;  debug() 3 $ [[ off = \o\n ]]
                    &gt;  debug() 8 $ set +o xdebug
            %td.code
              .highlight
                %pre
                  debug
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _option
                  %span.o =
                  %span.s2 &quot;${1:-on}&quot;
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;${_option}&quot;
                  %span.o =
                  %span.s2 &quot;on&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  %span.k                   %span.nb export
                  %span.nv debug_flag
                  = succeed "1" do
                    %span.o =
                  %span.nb set
                  \-o verbose
                  %span.k else
                  %span.k                   %span.nb set
                  +o verbose
                  %span.nb export
                  %span.nv debug_flag
                  = succeed "0" do
                    %span.o =
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 enable_debug()
              %p Enables verbose debugging output.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ enable_debug
            %td.code
              .highlight
                %pre
                  enable_debug
                  %span.o ()
                  %span.o {
                  debug on
                  %span.o }
          %tr
            %td.docs
              %h2 disable_debug()
              %p Disables verbose debugging output.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ disable_debug
            %td.code
              .highlight
                %pre
                  disable_debug
                  %span.o ()
                  %span.o {
                  debug off
                  %span.o }
          %tr
            %td.docs
              %h2 enable_backtrace()
              %p
                Enables backtrace and program exit whenever a command returns a nonzero value
                that is not handled.
              %h3 Input Parameters
              %p
                First parameter is optional. If it is passed it is a message that will be
                outputed when a command trigger the program to error exit.
              %h3 Stream Outputs
              %p What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat ./test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules trace # Load the trace module.
                    enable_backtrace
                    echo "Error exit with backtrace is now off."
                    false # Does not cause exiting with backtrace printing.
                    
                    user$ $PWD/test
                    Error exit with backtrace is on.
                    ERROR: A command has returned an unhandled error code (nonzero return value).
                    Error Backtrace:
                       Trace   Function           Line  File
                          1.   main()                7  /Users/wayneeseguin/test
            %td.code
              .highlight
                %pre
                  enable_backtrace
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _message
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_message}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb trap
                  %span.s2 &quot;backtrace \&quot;${_message}\&quot;&quot;
                  ERR
                  %span.k else
                  %span.k                   %span.nb trap
                  %span.s2 &quot;backtrace \&quot;A command has returned an unhandled error code (nonzero return value).\&quot;&quot;
                  ERR
                  %span.k fi
                  %span.k                   %span.nb set
                  \-o errexit
                  %span.o }
          %tr
            %td.docs
              %h2 function_name()
              %p Function Description
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat ./test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules trace # Load the trace module.
                    disable_backtrace
                    echo "Error exit with backtrace is now off."
                    false # Does not cause exiting with backtrace printing.
                    
                    user$ ./test
                    Error exit with backtrace is now off.
            %td.code
              .highlight
                %pre
                  disable_backtrace
                  %span.o ()
                  %span.o {
                  %span.nb set
                  +o errexit
                  %span.nb trap
                  \- ERR
                  %span.o }
          %tr
            %td.docs
              %h2 backtrace()
              %p
                Display a backtrace of the current call stack to the point that backtrace was
                called from. Currently trace is turned on as well so that execution after
                calling backtrace is traced.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                The call stack up to the current point of execution is printed to STDOUT of
                the calling environment.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat ./test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules trace # Load the trace module.
                    
                    functiona()
                    {
                      echo "function a"
                      functionb
                      echo "function a"
                    }
                    
                    functionb()
                    {
                      echo "function b"
                      functionc
                      echo "function b"
                    }
                    
                    functionc()
                    {
                      echo "function c"
                      backtrace
                      echo "function c"
                    }
                    
                    functiona
                    
                    user$ $PWD/test
                    function a
                    function b
                    function c
                    Error Backtrace:
                       Trace   Line Function             File
                          4.     25 functionc()          /Users/wayneeseguin/test
                          3.     18 functionb()          /Users/wayneeseguin/test
                          2.     11 functiona()          /Users/wayneeseguin/test
                          1.     29 main()               /Users/wayneeseguin/test
                     &gt; /Users/wayneeseguin/test functionc() 26 $ echo 'function c'
                    function c
                     &gt; /Users/wayneeseguin/test functionb() 19 $ echo 'function b'
                    function b
                     &gt; /Users/wayneeseguin/test functiona() 12 $ echo 'function a'
                    function a
            %td.code
              .highlight
                %pre
                  backtrace
                  %span.o ()
                  %span.o {
                  %span.nb set
                  +o xtrace
                  = succeed "_separator" do
                    %span.nb local
                  %span.nv _columns
                  %span.o =
                  = succeed "tput" do
                    %span.k $(
                  cols
                  %span.k )
                  %span.nb printf
                  \-v _separator
                  %span.s1 '%*s'
                  %span.s2 &quot;${_columns:-${COLUMNS:-80}}&quot;
                  %span.nb local
                  %span.nv _message
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_message}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb printf
                  %span.s2 &quot;\n${_message}\n\n&quot;
                  %span.k fi
                  %span.k                   = succeed "_source" do
                    %span.nb local
                  _function _line _index _largest _format _digits _longest
                  %span.k for
                  %span.o ((
                  %span.nv _index
                  = succeed "0" do
                    %span.o =
                  ; _index &lt;
                  %span.k ${#
                  %span.nv FUNCNAME
                  %span.p [@]
                  %span.k }
                  ; _index++
                  %span.o ))
                  %span.k do
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv FUNCNAME
                  %span.p [
                  %span.k ${
                  %span.nv _index
                  %span.k }
                  %span.p ]
                  %span.k }
                  \&gt;
                  %span.k ${#
                  %span.nv _largest
                  %span.k }
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nv _largest
                  %span.o =
                  %span.k ${
                  %span.nv FUNCNAME
                  %span.p [
                  %span.k ${
                  %span.nv _index
                  %span.k }
                  %span.p ]
                  %span.k }
                  %span.k fi
                  %span.k done
                  %span.k for
                  %span.o ((
                  %span.nv _index
                  = succeed "0" do
                    %span.o =
                  ; _index &lt;
                  %span.k ${#
                  %span.nv BASH_SOURCE
                  %span.p [@]
                  %span.k }
                  ; _index++
                  %span.o ))
                  %span.k do
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv BASH_SOURCE
                  %span.p [
                  %span.k ${
                  %span.nv _index
                  %span.k }
                  %span.p ]
                  %span.k }
                  \&gt;
                  %span.k ${#
                  %span.nv _longest
                  %span.k }
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nv _longest
                  %span.o =
                  %span.k ${
                  %span.nv BASH_SOURCE
                  %span.p [
                  %span.k ${
                  %span.nv _index
                  %span.k }
                  %span.p ]
                  %span.k }
                  %span.k fi
                  %span.k done
                  %span.k for
                  %span.o ((
                  %span.nv _index
                  = succeed "0" do
                    %span.o =
                  ; _index &lt;
                  %span.k ${#
                  %span.nv BASH_LINENO
                  %span.p [@]
                  %span.k }
                  ; _index++
                  %span.o ))
                  %span.k do
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv BASH_LINENO
                  %span.p [
                  %span.k ${
                  %span.nv _index
                  %span.k }
                  %span.p ]
                  %span.k }
                  \&gt;
                  %span.k ${#
                  %span.nv _digits
                  %span.k }
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nv _digits
                  %span.o =
                  %span.k ${
                  %span.nv BASH_LINENO
                  %span.p [
                  %span.k ${
                  %span.nv _index
                  %span.k }
                  %span.p ]
                  %span.k }
                  %span.k fi
                  %span.k done
                  %span.k case
                  %span.s2 &quot;${EDITOR:-}&quot;
                  in
                  = succeed "mvim*|mate*" do
                    %span.o (
                  %span.o )
                  %span.c #_format=&quot; %-$((${#_largest} + 2))s %-$((${#EDITOR} + ${#_digits} + 19 + ${#_longest}))s\n&quot;
                  %span.nv _format
                  %span.o =
                  %span.s2 &quot;%-$((${#_largest} + 2))s %-s\n&quot;
                  %span.nb printf
                  %span.s2 &quot;${_format}&quot;
                  %span.s2 &quot;function()&quot;
                  %span.s2 &quot;Source&quot;
                  1&gt;&amp;2
                  ;;
                  = succeed "vi*|gvim*|emacs*|*" do
                    %span.o (
                  %span.o )
                  %span.nv _format
                  %span.o =
                  %span.s2 &quot;%-$((${#_largest} + 2))s $ %${#EDITOR}s +%-$((${#_digits}))s %-$((${#_longest} + 2))s %s\n&quot;
                  %span.nb printf
                  %span.s2 &quot;${_format}&quot;
                  %span.s2 &quot;function()&quot;
                  %span.s1 ' '
                  %span.s2 &quot;#&quot;
                  %span.s2 &quot;source file&quot;
                  1&gt;&amp;2
                  
                  ;;
                  %span.k esac
                  %span.k                   %span.nb printf
                  %span.s2 &quot;${_separator// /=}\n&quot;
                  1&gt;&amp;2
                  %span.k for
                  %span.o ((
                  %span.nv _index
                  = succeed "1" do
                    %span.o =
                  ; _index &lt;
                  %span.k ${#
                  %span.nv FUNCNAME
                  %span.p [@]
                  %span.k }
                  ; ++_index
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv _source
                  %span.o =
                  %span.s2 &quot;${BASH_SOURCE[${_index}]}&quot;
                  %span.nv _function
                  %span.o =
                  %span.s2 &quot;${FUNCNAME[${_index}]:+${FUNCNAME[${_index}]}()}&quot;
                  %span.nv _line
                  %span.o =
                  %span.k ${
                  %span.nv BASH_LINENO
                  %span.p [
                  %span.k $((
                  _index
                  %span.o -
                  %span.m 1
                  %span.k ))
                  %span.p ]
                  %span.k }
                  %span.k case
                  %span.s2 &quot;$_function&quot;
                  in
                  fail
                  %span.se> \(\)
                  |error
                  %span.se> \(\)
                  |command_not_found_handle
                  %span.se> \(\)
                  |command_not_found
                  %span.se \(\)
                  %span.o )
                  %span.k continue
                  ;;
                  %span.k esac
                  %span.k case
                  %span.s2 &quot;${EDITOR:-}&quot;
                  in
                  = succeed "mvim*|mate*" do
                    %span.o (
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;${_format}&quot;
                  %span.s2 &quot;${_function}&quot;
                  %span.s2 &quot;${EDITOR// *}://open?url=file://${_source}&amp;line=${_line}&quot;
                  1&gt;&amp;2
                  ;;
                  = succeed "vi*|gvim*|emacs*|*" do
                    %span.o (
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;${_format}&quot;
                  %span.s2 &quot;${_function}&quot;
                  %span.s2 &quot;${EDITOR}&quot;
                  %span.s2 &quot;${_line}&quot;
                  %span.s2 &quot;${_source} &quot;
                  1&gt;&amp;2
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k                   %span.nb printf
                  %span.s2 &quot;${_separator// /=}\n&quot;
                  1&gt;&amp;2
                  %span.k if
                  %span.o ((
                  trace_flag &gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "enable_trace" do
                    %span.k                   %span.k fi
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2
                user
                %em> create
                if_missing()
              %p Create a system user if it does not exist on the system.
              %h3 Input Parameters
              %p
                The first parameter should be the user name, then optionally
                [with] group {{groupname}}
              %h3 Stream Outputs
              %p What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
              %h3 Environmental effects
              %p What, if any, environmental side effects this function causes. 'None.' for none.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no username is given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ user_create_if_missing "nginx" with group "nginx"
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  user_create_if_missing
                  %span.o ()
                  %span.o {
                  = succeed "_token" do
                    %span.nb local
                  _group
          %tr
            %td.docs
              %p parse arguments
            %td.code
              .highlight
                %pre
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  ;
                  %span.k do
                  %span.k                   %span.nv _token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  ;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${_token}&quot;
                  in
                  group
                  %span.o )
                  %span.nv _group
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  ;
                  %span.nb shift
                  ;;
                  with
                  %span.o )
                  %span.k continue
                  %span.c # Syntatic sugar, ignore, next!
                  ;;
                  from
                  %span.o )
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  ;
                  %span.nb shift
                  ;;
                  \--force
                  %span.o )
                  %span.nv _force_flag
                  = succeed "1" do
                    %span.o =
                  ;;
                  
                  *
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_group}&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  %span.k                   %span.nv _group
                  %span.o =
                  %span.s2 &quot;${_token}&quot;
                  %span.nb break
                  %span.nb                   %span.k fi
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o ((
                  %span.nv UID
                  %span.o ==
                  0
                  %span.o ))
                  ;
                  %span.k then
                  %span.o (
                  %span.k case
                  %span.s2 &quot;$(uname)&quot;
                  in
                  %span.s2 &quot;OpenBSD&quot;
                  %span.o )
                  groupadd
                  %span.s2 &quot;$package_user&quot;
                  useradd -g
                  %span.s2 &quot;$package_user&quot;
                  %span.s2 &quot;$package_user&quot;
                  \-s /bin/bash
                  usermod -s /bin/bash
                  %span.s2 &quot;$package_user&quot;
                  ;;
                  %span.s2 &quot;FreeBSD&quot;
                  %span.o )
                  pw groupadd -q
                  %span.s2 &quot;$package_user&quot;
                  ;;
                  %span.s2 &quot;Linux&quot;
                  %span.o )
          %tr
            %td.docs
              %p
                groupadd nginx
                useradd -G nginx -M nginx
            %td.code
              .highlight
                %pre
                  %span.k if
                  %span.o [[
                  \-f
                  %span.s2 &quot;/etc/SuSE-release&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  = succeed "groupadd" do
                    %span.k                   %span.s2 &quot;$package_user&quot;
                  %span.k else
                  = succeed "groupadd" do
                    %span.k                   \-f
                  %span.s2 &quot;$package_user&quot;
                  %span.k fi
                  = succeed "useradd" do
                    %span.k                   \-g
                  %span.s2 &quot;${package_user}&quot;
                  %span.s2 &quot;${package_user}&quot;
                  usermod -d
                  %span.s2 &quot;${data_path%\/*}&quot;
                  %span.s2 &quot;${package_user}&quot;
                  usermod -s /bin/bash
                  %span.s2 &quot;${package_user}&quot;
                  ;;
                  %span.s2 &quot;Darwin&quot;
                  %span.o )
                  %span.nv current_max_gid
                  %span.o =
                  = succeed "dscl" do
                    %span.k $(
                  \. -list /Groups gid | awk
                  %span.s1 '{print $2}'
                  | sort -g -r | head -1
                  %span.k )
                  %span.nv next_gid
                  %span.o =
                  = succeed "current_max_gid+1" do
                    %span.k $((
                  %span.k ))
                  %span.nv current_max_uid
                  %span.o =
                  = succeed "dscl" do
                    %span.k $(
                  \. -list /Users UniqueID | awk
                  %span.s1 '{print $2}'
                  | sort -g -r | head -1
                  %span.k )
                  %span.nv next_uid
                  %span.o =
                  = succeed "current_max_uid+1" do
                    %span.k $((
                  %span.k ))
                  %span.k if
                  \! dscl . -list /Users | grep -q
                  %span.s2 &quot;^${package_user}$&quot;
                  ;
                  %span.k then
                  = succeed "dscl" do
                    %span.k                   \. -create
                  %span.s2 &quot;/Groups/$package_user&quot;
                  dscl . -create
                  %span.s2 &quot;/Groups/$package_user&quot;
                  gid
                  %span.s2 &quot;$next_gid&quot;
                  dscl . -create
                  %span.s2 &quot;/Users/${package_user}&quot;
                  dscl . -create
                  %span.s2 &quot;/Users/${package_user}&quot;
                  PrimaryGroupID
                  %span.s2 &quot;$gid&quot;
                  %span.c # UserShell /bin/bash
                  dscl . -create
                  %span.s2 &quot;/Users/${package_user}&quot;
                  uid
                  %span.s2 &quot;$next_uid&quot;
                  dscl . -create
                  %span.s2 &quot;/Users/${package_user}&quot;
                  realname
                  %span.s2 &quot;Postgresql User&quot;
                  dscl . -create
                  %span.s2 &quot;/Users/${package_user}&quot;
                  home
                  %span.s2 &quot;${data_path%\/*}&quot;
                  dscl . -create
                  %span.s2 &quot;/Users/${package_user}&quot;
                  shell
                  %span.s2 &quot;/bin/bash&quot;
                  dscl . -create
                  %span.s2 &quot;/Users/${package_user}&quot;
                  gid
                  %span.s2 &quot;$gid&quot;
                  dscl . -create
                  %span.s2 &quot;/Users/${package_user}&quot;
                  passwd
                  %span.s2 &quot;*&quot;
                  %span.k fi
                  ;;
                  %span.s2 &quot;SunOS&quot;
                  %span.o )
                  groupadd
                  %span.s2 &quot;$package_user&quot;
                  useradd -g
                  %span.s2 &quot;$package_user&quot;
                  \-s /bin/bash -d
                  %span.s2 &quot;${data_path}&quot;
                  %span.s2 &quot;$package_user&quot;
                  usermod -s /bin/bash
                  %span.s2 &quot;$package_user&quot;
                  ;;
                  %span.k esac
                  %span.o )
                  %span.o ||
                  %span.nb true
                  %span.c # Ignore failures with this for now...
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Users and groups may be manipulated only by the super user (root) via su or sudo.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 user_delete()
              %p Deletes the named system user.
              %h3 Input Parameters
              %p The first parameter is the system user to delete.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p The given user will no longer exist on the system.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if the user name was not specified.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ user_delete "nginx"
            %td.code
              .highlight
                %pre
                  user_delete
                  %span.o ()
                  %span.o {
                  = succeed "_token" do
                    %span.nb local
                  _group
          %tr
            %td.docs
              %p parse arguments
            %td.code
              .highlight
                %pre
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  ;
                  %span.k do
                  %span.k                   %span.nv _token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  ;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${_token}&quot;
                  in
                  group
                  %span.o )
                  %span.nv _group
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  ;
                  %span.nb shift
                  ;;
                  with
                  %span.o )
                  %span.k continue
                  %span.c # Syntatic sugar, ignore, next!
                  ;;
                  from
                  %span.o )
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  ;
                  %span.nb shift
                  ;;
                  \--force
                  %span.o )
                  %span.nv _force_flag
                  = succeed "1" do
                    %span.o =
                  ;;
                  
                  *
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_group}&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  %span.k                   %span.nv _group
                  %span.o =
                  %span.s2 &quot;${_token}&quot;
                  %span.nb break
                  %span.nb                   %span.k fi
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o ((
                  %span.nv UID
                  %span.o ==
                  0
                  %span.o ))
                  ;
                  %span.k then
                  %span.o (
                  %span.k case
                  %span.s2 &quot;$(uname)&quot;
                  in
                  %span.s2 &quot;OpenBSD&quot;
                  %span.o )
                  groupdel
                  %span.s2 &quot;$package_user&quot;
                  userdel -g
                  %span.s2 &quot;$package_user&quot;
                  %span.s2 &quot;$package_user&quot;
                  ;;
                  %span.s2 &quot;FreeBSD&quot;
                  %span.o )
                  pw groupdel -q
                  %span.s2 &quot;$package_user&quot;
                  ;;
                  %span.s2 &quot;Linux&quot;
                  %span.o )
                  userdel
                  %span.s2 &quot;${package_user}&quot;
                  ;;
                  %span.s2 &quot;Darwin&quot;
                  %span.o )
                  %span.nv gid
                  %span.o =
                  %span.s2 &quot;501&quot;
                  %span.c #only gids &gt; 500 show up in user preferences
                  %span.c #Find an open gid
                  %span.k while
                  = succeed ";" do
                    %span.nb true
                  %span.k do
                  %span.k                   %span.nv name
                  %span.o =
                  = succeed "dscl" do
                    %span.k $(
                  \. search /groups PrimaryGroupID
                  %span.nv $gid
                  | cut -f1 -s
                  %span.k )
                  %span.k if
                  %span.o [
                  \-z
                  %span.s2 &quot;$name&quot;
                  %span.o ]
                  ;
                  %span.k then
                  %span.k                   %span.nb break
                  %span.nb                   %span.k fi
                  %span.k                   %span.nv gid
                  %span.o =
                  %span.nv $[$gid
                  +1
                  %span.o ]
                  %span.k done
                  %span.c #Create the group
                  dscl . -delete
                  %span.s2 &quot;/Users/${package_user}&quot;
                  PrimaryGroupID
                  %span.s2 &quot;$gid&quot;
                  %span.c # UserShell /bin/bash
                  dscl . -delete
                  %span.s2 &quot;/Groups/$package_user&quot;
                  dscl . -delete
                  %span.s2 &quot;/Groups/$package_user&quot;
                  gid
                  %span.s2 &quot;$gid&quot;
                  ;;
                  %span.s2 &quot;SunOS&quot;
                  %span.o )
                  groupdel
                  %span.s2 &quot;$package_user&quot;
                  userdel
                  %span.s2 &quot;$package_user&quot;
                  ;;
                  %span.k esac
                  %span.o )
                  %span.o ||
                  %span.nb true
                  %span.c # Ignore failures with this for now...
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Users and groups may be manipulated only by the super user (root) via su or sudo.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                user
                %em> is
                root()
              %p Tests if the user the current process is running as is root.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if user is root (UID 0).
                1 if user is not root (UID 0).
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ user_is_root
                    user$ echo $?
                    1
                    
                    root# user_is_root
                    root# echo $?
                    0
            %td.code
              .highlight
                %pre
                  user_is_root
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o ((
                  %span.nv UID
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                user
                %em> is
                not_root()
              %p Tests if the user the current process is running as is not root.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if user is not root (eg UID is nonzero)
                1 if user is root (UID 0)
              %h3 Failure Scenarios
              %p No failure scenarios currently
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ user_is_not_root
                    user$ echo $?
                    0
                    
                    root# user_is_not_root
                    root# echo $?
                    1
            %td.code
              .highlight
                %pre
                  user_is_not_root
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o ((
                  UID !
                  %span.o =
                  0
                  %span.o ))
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                user
                %em> must
                be_root()
              %p Halts the calling program with a failure message if the user is not root.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p A failure message is output to STDERR if the failure condition is met.
              %h3 Environmental effects
              %p What, if any, environmental side effects this function causes. 'None.' for none.
              %h3 Return Codes
              %p 0 if the user is root
              %h3 Failure Scenarios
              %p Fails if the program user running is not root.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ user_must_be_root
                    ERROR: bdsm test test must be run as root and NOT as a user(user)
            %td.code
              .highlight
                %pre
                  user_must_be_root
                  %span.o ()
                  %span.o {
                  user_is_root
                  %span.o ||
                  fail
                  %span.s2 &quot;bdsm $extension $action must be run as a root and NOT as a user ($USER).&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                user
                %em> must
                not
                %em> be
                root()
              %p Halts the calling program with a failure message if the user is not root.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p A failure message is output to STDERR if the failure condition is met.
              %h3 Environmental effects
              %p What, if any, environmental side effects this function causes. 'None.' for none.
              %h3 Return Codes
              %p 0 if the user is root
              %h3 Failure Scenarios
              %p Fails if the program user running is root.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ user_must_not_be_root
                    ERROR: bdsm test test must be run as a (project) user and NOT as a root.
            %td.code
              .highlight
                %pre
                  user_must_not_be_root
                  %span.o ()
                  %span.o {
                  user_is_not_root
                  %span.o ||
                  fail
                  %span.s2 &quot;bdsm $extension $action must be run as a (project) user and NOT as root.&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                user
                %em> run
                as()
              %p Runs a command as a given user.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Any stream outputs of the command being run.
              %h3 Environmental effects
              %p Any environmental effects of the command being run.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no user was specified.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    root# user_run_as "user" pwd
                    /home/user
            %td.code
              .highlight
                %pre
                  user_run_as
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _user
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_user:-}&quot;
                  %span.o ]]
                  %span.o ||
                  fail
                  %span.s2 &quot;Cannot run as user as no user or commands were given.&quot;
                  %span.nb shift
                  = succeed "su" do
                    %span.nb                   %span.s2 &quot;${_user}&quot;
                  \-c
                  %span.s2 &quot;$*&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                user
                %em> run
                as_login()
              %p Runs a command as a given user, in that users login shell.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Any stream outputs of the command being run.
              %h3 Environmental effects
              %p Any environmental effects of the command being run.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no user was specified.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    root# user_run_as_login "deploy" bdsm unicorn restart
                    &lt;&lt; unicorn restart output &gt;&gt;
            %td.code
              .highlight
                %pre
                  user_run_as_login
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _user
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_user:-}&quot;
                  %span.o ]]
                  %span.o ||
                  fail
                  %span.s2 &quot;Cannot run as login user as no user or commands were given.&quot;
                  %span.nb shift
                  = succeed "su" do
                    %span.nb                   \-
                  %span.s2 &quot;${_user}&quot;
                  \-c
                  %span.s2 &quot;$*&quot;
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 first()
              %p Returns the first parameter.
              %h3 Input Parameters
              %p One or more parameters.
              %h3 Stream Outputs
              %p Prints the first positional parameter to STDOUT of the calling environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no parameters are passed.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ first one two three
                    one
                    
                    user$ array=($(ls $HOME))
                    user$ first ${array[@]}
                    Desktop
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  first
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _array
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;${_array[0]}&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;No parameters given, cannot return the first one.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 last()
              %p Returns the last parameter.
              %h3 Input Parameters
              %p One or more parameters.
              %h3 Stream Outputs
              %p Prints the last positional parameter to STDOUT of the calling environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no parameters are passed.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ last one two three
                    one
                    
                    user$ array=($(ls $HOME))
                    user$ last ${array[@]}
                    tmp
            %td.code
              .highlight
                %pre
                  last
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _array
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;${_array[$((${#_array[@]} - 1))]}&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;No parameters given, cannot return the last one.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 match()
              %p Tests to see if a value matches a given regex (shell extended glob pattern).
              %h3 Input Parameters
              %p Positional Parameter listing and descriptions.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the value matches the regex (shell extended glob pattern)
                1 if the value does not match the regex (shell extended glob pattern)
              %h3 Failure Scenarios
              %p
                Fails if no value is given
                Fails if no regex is given
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ match "The quick brown fox jumped over the lazy dog." "*fox*"
                    user$ echo $?
                    0
                    
                    user$ match "The quick brown fox jumped over the lazy dog." "*smurf*"
                    user$ echo $?
                    1
            %td.code
              .highlight
                %pre
                  match
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _value
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_value}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb local
                  %span.nv _regex
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_value}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb shopt
                  \-s extglob
                  %span.k case
                  %span.s2 &quot;${_value}&quot;
                  in
                  %span.o (
                  %span.k ${
                  %span.nv _regex
                  %span.k }
                  %span.o )
                  = succeed "0" do
                    %span.k return
                  ;;
                  = succeed "*" do
                    %span.o (
                  %span.o )
                  = succeed "1" do
                    %span.k return
                  ;;
                  %span.k esac
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;A regex must be specified in order to match ${_value} against it.&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;A value and regex must be specified in order to match.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                variables
                %em> must
                be_nonempty()
              %p
                Halts the program with a fail message if any of the named variables are empty
                or undefined.
              %h3 Input Parameters
              %p One or more parameters specifying the names of variables.
              %h3 Stream Outputs
              %p None if all are
              %h3 Environmental effects
              %p What, if any, environmental side effects this function causes. 'None.' for none.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no varaible names were given.
                Fails if any of the named variables are empty.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules trace variables # Load the trace module.
                    unset HOME
                    variables_must_be_nonempty HOME
                    
                    user$ $PWD/test
                    ERROR: Required variable 'HOME' is not set.
                    ERROR: A command has returned an unhandled error code (nonzero return value).
                    Backtrace:
                       Trace   Line Function             File
                          3.     37 fail()               /usr/local/bdsm/modules/bash/logging/dsl
                          2.    192 variables_must_be_nonempty() /usr/local/bdsm/modules/bash/variables/dsl
                          1.      6 main()               /Users/wayneeseguin/test
                     &gt; modules/bash/logging/dsl fail() 38 $ exit 1
            %td.code
              .highlight
                %pre
                  variables_must_be_nonempty
                  %span.o ()
                  %span.o {
                  = succeed "_variable" do
                    %span.nb local
                  %span.nv _variables
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _variables
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_variable" do
                    %span.k for
                  in
                  %span.s2 &quot;${_variables}&quot;
                  %span.k do
                  %span.k if
                  %span.nb eval
                  %span.s2 &quot;[[ -n \&quot;\${${_variable}}\&quot; ]]&quot;
                  %span.k then
                  %span.k continue
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Required variable '$_variable' is not set.&quot;
                  %span.k fi
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot ensure variables are nonempty as no variables were given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                variable
                %em> is
                nonempty()
              %p Test to see if a variable is empty.
              %h3 Input Parameters
              %p First parameter is a string containing a variable name.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Fails if no variable name was given as the first argument.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ variable_is_nonempty asdf
                    user$ echo $?
                    1
                    
                    user$ asdf="w00t! "
                    user$ variable_is_nonempty asdf
                    user$ echo $?
                    0
            %td.code
              .highlight
                %pre
                  variable_is_nonempty
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _variable
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_variable}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.nb eval
                  %span.s2 &quot;[[ -n \&quot;\${${_variable}:-}\&quot; ]]&quot;
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check if variable is nonempty, no variable was given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                variable
                %em> is
                empty()
              %p Test to see if a variable is empty.
              %h3 Input Parameters
              %p First parameter is a string containing a variable name.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Fails if no variable name was given as the first argument.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ variable_is_empty asdf
                    user$ echo $?
                    1
                    
                    user$ asdf="w00t! "
                    user$ variable_is_empty asdf
                    user$ echo $?
                    0
            %td.code
              .highlight
                %pre
                  variable_is_empty
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _variable
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_variable}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.nb eval
                  %span.s2 &quot;[[ -z \&quot;\${${_variable}:-}\&quot; ]]&quot;
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check if variable is empty as no variable was given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                variables
                %em> are
                nonempty()
              %p Test to see if any of a given list of variables are empty.
              %h3 Input Parameters
              %p First parameter is a string containing a variable name.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if all variables given are nonempty.
                1 if any variable given is nonempty.
              %h3 Failure Scenarios
              %p Fails if no variable names were given as arguments.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ variables_are_nonempty BASH_VERSION asdf
                    user$ echo $?
                    1
                    
                    user$ asdf="w00t! "
                    user$ variables_are_nonempty BASH_VERSION asdf
                    user$ echo $?
                    0
            %td.code
              .highlight
                %pre
                  variables_are_nonempty
                  %span.o ()
                  %span.o {
                  = succeed "_variable" do
                    %span.nb local
                  %span.nv _variables
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.s2 &quot;${#_variables[@]}&quot;
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_variable" do
                    %span.k for
                  in
                  %span.s2 &quot;${_variables}&quot;
                  %span.k do
                  %span.k if
                  %span.nb eval
                  %span.s2 &quot;[[ -z \&quot;\${${_variable}:-}\&quot; ]]&quot;
                  %span.k then
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k done
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check if variables are nonempty as no variables were given.&quot;
                  %span.k fi
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %p TODO: Use git cli instead of awking it :)
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  scm_fetch
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _url
                  %span.o =
                  %span.s2 &quot;${1:-${extension_url:-}}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_url}&quot;
                  %span.o ]]
                  %span.k then
                  fail
                  %span.s2 &quot;Cannot fetch an extension from a url as no url was given&quot;
                  %span.k fi
                  %span.nb local
                  %span.nv _identifier
                  %span.o =
                  %span.s2 &quot;${_url//\//_}&quot;
                  %span.c # Convert '/' to an invalid url component '_'
                  %span.nb local
                  %span.nv repo_path
                  %span.o =
                  %span.s2 &quot;${repos_path}/${_identifier}&quot;
                  ensure_paths_exist
                  %span.s2 &quot;${repos_path}&quot;
                  %span.k case
                  %span.s2 &quot;${_url}&quot;
                  in
                  *git*
                  %span.o )
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${repo_path}/.git&quot;
                  %span.k then
                  %span.nb true
                  %span.c # already fetched!
                  %span.k else
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${repo_path}&quot;
                  %span.k then
                  remove_paths
                  %span.s2 &quot;${repo_path}&quot;
                  %span.k fi
                  %span.k if
                  \! git clone --depth 1
                  %span.k ${
                  %span.nv _url
                  %span.k }
                  %span.s2 &quot;${repo_path}&quot;
                  %span.k then
                  error
                  %span.s2 &quot;There was an error while cloning the repository from the url '${_url}'&quot;
                  %span.k fi
                  %span.k fi
                  ;;
                  *svn*
                  %span.o )
                  NIY
                  ;;
                  *hg*
                  %span.o )
                  NIY
                  ;;
                  *fossil*
                  %span.o )
                  NIY
                  ;;
                  *
                  %span.o )
                  ;;
                  %span.k esac
                  %span.o }
                  scm_update
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _url
                  %span.o =
                  %span.s2 &quot;${1:-${extension_url:-}}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_url}&quot;
                  %span.o ]]
                  %span.k then
                  fail
                  %span.s2 &quot;Cannot fetch an extension from a url as no url was given&quot;
                  %span.k fi
                  %span.nb local
                  %span.nv _identifier
                  %span.o =
                  %span.s2 &quot;${_url//\//_}&quot;
                  %span.c # Convert '/' to an invalid url component '_'
                  %span.nb local
                  %span.nv repo_path
                  %span.o =
                  %span.s2 &quot;${repos_path}/${_identifier}&quot;
                  %span.k case
                  %span.s2 &quot;${_url}&quot;
                  in
                  *git*
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-z
                  = succeed "/" do
                    %span.s2 &quot;$(git branch | awk &quot;
                  %span.k ${
                  %span.nv branch
                  %span.p :=master
                  %span.k }
                  %span.nv $/
                  %span.s2 &quot;)&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  \!
                  %span.o (
                  %span.nb builtin cd
                  = succeed ";" do
                    %span.s2 &quot;${repo_path}&quot;
                  git checkout -b
                  %span.s2 &quot;$branch&quot;
                  \--track
                  %span.s2 &quot;$remote/$branch&quot;
                  2&gt;/dev/null
                  %span.o )
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;$remote $branch remote branch not found. Halting.&quot;
                  %span.k fi
                  %span.k elif
                  %span.o [[
                  \-z
                  = succeed "/" do
                    %span.s2 &quot;$(git branch | awk &quot;
                  %span.se \*
                  %span.nv $branch$/
                  = succeed "print" do
                    %span.o {
                  = succeed "2" do
                    %span.se \$
                  %span.o }
                  %span.s2 &quot;)&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  \!
                  %span.o (
                  %span.nb builtin cd
                  = succeed ";" do
                    %span.s2 &quot;${repo_path}&quot;
                  git checkout
                  %span.nv $branch
                  2&gt;/dev/null
                  %span.o )
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Unable to checkout $branch.\nCould not get head. Halting.&quot;
                  %span.k fi
                  %span.k fi
                  %span.k if
                  \!
                  %span.o (
                  %span.nb builtin cd
                  %span.s2 &quot;${repo_path}&quot;
                  ;
                  git pull --rebase origin
                  %span.nv $branch
                  %span.o )
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Git pull failed. Halting.&quot;
                  %span.k fi
                  ;;
                  *svn*
                  %span.o )
                  NIY
                  %span.s2 &quot;Subversion scm_update&quot;
                  ;;
                  *hg*
                  %span.o )
                  NIY
                  %span.s2 &quot;hg scm_update&quot;
                  ;;
                  *fossil*
                  %span.o )
                  NIY
                  %span.s2 &quot;fossil scm_update&quot;
                  ;;
                  *
                  %span.o )
                  error
                  %span.s2 &quot;Unknownn SCM for url '${_url}'&quot;
                  ;;
                  %span.k esac
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2
                shell
                %em> is
                interactive()
              %p Test if the current shell is an interactive shell.
              %p Usage Examples:
              %pre
                %code
                  :preserve
                    if shell_is_interactive
                    then
                      ${PAGER} somefile
                    else
                      cat -v somefile
                    fi
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  shell_is_interactive
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o [[
                  \-t 0
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
                  = succeed "shell_is_interactive" do
                    %span.k if
                  %span.k then
                  %span.k                   %span.nb true
                  %span.c # Interactive functions will be loaded here, only if shell is interactive.
                  %span.k fi
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 timestamp_set()
              %p Sets the variable named 'timestamp' to the current timestamp.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p Sets the variable named 'timestamp' to the current timestamp.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat ./test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules trace time # Load the trace module.
                    
                    timestamp_set
                    echo $timestamp
                    
                    user$ $PWD/test
                    2011-04-24T22:28:16
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  timestamp_set
                  %span.o ()
                  %span.o {
                  %span.nv timestamp
                  %span.o =
                  = succeed "timestamp" do
                    %span.k $(
                  %span.k )
                  %span.o }
          %tr
            %td.docs
              %h2 timestamp()
              %p Prints out the current timestamp.
              %h3 Input Parameters
              %p
                None required. The first parameter may optionally specify the format to output
                the time string in. See 'man 1 date' for formatting options.
              %h3 Stream Outputs
              %p
                Prints the current timestamp as a formatted datetime string to the STDOUT of
                the calling environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat ./test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules trace time # Load the trace module.
                    
                    timestamp
                    echo
                    
                    user$ $PWD/test
                    2011-04-24T22:31:54
            %td.code
              .highlight
                %pre
                  timestamp
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _format
                  %span.o =
                  = succeed "%Y-%m-%dT%H:%M:%S" do
                    %span.s2 &quot;${1:-&quot;
                  %span.s2 &quot;}&quot;
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;$(date +&quot;
                  %span.k ${
                  %span.nv _format
                  %span.k }
                  %span.s2 &quot;)&quot;
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 rvm_install()
              %p Install the latest release version of RVM.
              %h3 Input Parameters
              %p First parameter is an optional version number of RVM to install.
              %h3 Stream Outputs
              %p
                Output from rvm-installer will be printed to the enclosing environment's
                STDOUT as well as curl output.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ rvm_install
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  rvm_install
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _version
                  %span.o =
                  %span.k ${
                  %span.nv 1
                  %span.k :-
                  %span.nv latest
                  %span.k }
                  %span.nv _result
                  = succeed "0" do
                    %span.o =
                  %span.nb local
                  %span.nv url
                  %span.o =
                  %span.s2 &quot;https://rvm.beginrescueend.com/install/rvm&quot;
                  %span.o (
                  %span.nb set
                  \-o errexit
                  curl -s
                  %span.s2 &quot;$url&quot;
                  \-o rvm-installer
                  ensure_files_are_executable
                  %span.s2 &quot;rvm-installer&quot;
                  \./rvm-installer --version
                  %span.k ${
                  %span.nv _version
                  %span.k }
                  remove_files
                  %span.s2 &quot;rvm-installer&quot;
                  %span.o )
                  %span.o ||
                  %span.nv _result
                  %span.o =
                  %span.nv $?
                  %span.k return
                  %span.nv $_result
                  %span.o }
          %tr
            %td.docs
              %h2 install_gem()
              %p installs the named gem(s) with --no-rdoc --no-ri flags
              %h3 Input Parameters
              %p One or more gem names
              %h3 Stream Outputs
              %p
                The output of the gem install command will be printed to the calling
                environments streams.
              %h3 Environmental effects
              %p Ruby gem(s) will be installed on the system, potentially enabling new commands.
              %h3 Return Codes
              %p
                0 if gem install was successful
                1 if gem install was not successful
              %h3 Failure Scenarios
              %p Fails if ...
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ {{ setup the scenario }}
                    user$ function_name {{ parameters }}
                    user$ {{ demonstrate the results}}
            %td.code
              .highlight
                %pre
                  install_gem
                  %span.o ()
                  %span.o {
                  = succeed "gem" do
                    %span.k if
                  install --no-rdoc --no-ri -q
                  %span.s2 &quot;$*&quot;
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 install_gems()
              %p Installs listed gems using the install_gem function.
              %h3 Input Parameters
              %p One or more rubygems names
              %h3 Stream Outputs
              %p
                Output from underlying gem install will be printed to the calling environments
                streams.
              %h3 Environmental effects
              %p One or more new commands may become available.
              %h3 Return Codes
              %p
                0 if all gem installs were successful
                n where n is the number of unsuccessful gem installs otherwise.
              %h3 Failure Scenarios
              %p Fails if no gems were given to install.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ install_gems rake rack
            %td.code
              .highlight
                %pre
                  install_gems
                  %span.o ()
                  %span.o {
                  = succeed "_gem" do
                    %span.nb local
                  %span.nv _gems
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.nv _result
                  = succeed "0" do
                    %span.o =
                  %span.o ((
                  %span.k ${#
                  %span.nv _gems
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.o ||
                  fail
                  %span.s2 &quot;Cannot install gems as no gem names were given!&quot;
                  = succeed "_gem" do
                    %span.k for
                  in
                  %span.s2 &quot;${_gems[@]}&quot;
                  %span.k do
                  = succeed "install_gem" do
                    %span.k                   %span.k ${
                  %span.nv _gem
                  %span.k }
                  %span.o ||
                  %span.o ((
                  _result++
                  %span.o ))
                  %span.k done
                  %span.k return
                  %span.nv $_result
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 project_initialize()
              %p Initializes paths and environment for the logical concept of a 'project'.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                Environmental variable settings, such as {shared,release}_path, environment,
                etc...
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ project_initialize
                    user$ echo $environment
                    production
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  project_initialize
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${project_path}&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  \:
                  %span.se \
                  %span.s2 &quot;${shared_path:=${project_path}/shared}&quot;
                  %span.se \
                  %span.s2 &quot;${release_path:=${project_path}/current}&quot;
                  %span.se \
                  = succeed "production" do
                    %span.s2 &quot;${environment:=&quot;
                  %span.s2 &quot;}&quot;
                  \:
                  %span.se \
                  %span.s2 &quot;${vcs:=$(vcs &quot;
                  %span.k ${
                  %span.nv shared_path
                  = succeed "/" do
                    %span.k }
                  %span.k ${
                  %span.nv project
                  %span.k }
                  %span.s2 &quot;)}&quot;
                  %span.nv log_path
                  %span.o =
                  %span.s2 &quot;$shared_path/log&quot;
                  %span.c # Override default BDSM log path.
                  %span.nv extension_log_path
                  %span.o =
                  %span.s2 &quot;${log_path}&quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${project}&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  %span.k                   %span.nv database_name
                  %span.o =
                  %span.s2 &quot;${database_name:-&quot;
                  %span.k ${
                  %span.nv project
                  = succeed "_" do
                    %span.k }
                  %span.k ${
                  %span.nv environment
                  %span.k }
                  %span.s2 &quot;}&quot;
                  source_files
                  %span.s2 &quot;.${project}rc&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 vcs()
              %p Detect and set the vcs, if any, for the current project.
              %h3 Input Parameters
              %p First parameter must be the path to a repository for determining the VCS.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                The environment variable 'vcs' will be set to the VCS detected, or 'git' by
                default.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no repository path is given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ vcs /home/appuser/shared/appuser
                    user$ echo $vcs
                    git
            %td.code
              .highlight
                %pre
                  vcs
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.o ||
                  fail
                  %span.s2 &quot;Repository path must be given in order to detect the VCS used.&quot;
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}/.git&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  %span.k                   %span.nv vcs
                  %span.o =
                  %span.s2 &quot;git&quot;
                  %span.k elif
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}/.svn&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  %span.k                   %span.nv vcs
                  %span.o =
                  %span.s2 &quot;svn&quot;
                  %span.k elif
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}/.hg&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  %span.k                   %span.nv vcs
                  %span.o =
                  %span.s2 &quot;hg&quot;
          %tr
            %td.docs
              %p
                TODO:
                elif [[ ... ]] ; then
                vcs="fossil"
            %td.code
              .highlight
                %pre
                  %span.k else
                  %span.k                   %span.nv vcs
                  %span.o =
                  %span.s2 &quot;git&quot;
                  %span.c # default
                  %span.k fi
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 lockfile_lock()
              %p
                If the current process is the first to write to the lockfile then the process
                continues processing past the line calling lockfile_lock "{file path/name}"
              %p
                Otherwise lockfile_lock causes the process to exit with a message and status
                code 0.
              %p If the lock is obtained then lockfile_lock ensures that
              %p Usage Examples:
              %p
                lockfile
                %em> lock /var/run/my
                script.pid
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  lockfile_lock
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _lockfile
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_lockfile}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot lock onto a lockfile as no lockfile was specified as the first parameter.&quot;
                  %span.k fi
          %tr
            %td.docs
              %p The first instance that successfully writes it's pid to the lockfile 'wins'
            %td.code
              .highlight
                %pre
                  %span.nb printf
                  %span.s2 &quot;$$&quot;
                  \&gt;&gt;
                  %span.s2 &quot;${_lockfile}&quot;
                  %span.nb read
                  \-r _pid &lt;
                  %span.s2 &quot;${_lockfile}&quot;
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;${_pid}&quot;
                  %span.o ==
                  %span.s2 &quot;$$&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "on_exit" do
                    %span.k                   %span.s2 &quot;rm -f ${_lockfile}&quot;
          %tr
            %td.docs
              %p Ensure the lockfile is released on exit while preserving existing EXIT traps.
            %td.code
              .highlight
                %pre
                  %span.nb trap
                  = succeed "s#" do
                    %span.s2 &quot;rm -f ${_lockfile};$(trap | awk '/EXIT/' | sed -e &quot;
                  %span.s1 ' EXIT##&quot; -e &quot;s#.*'
                  %span.c ##&quot;)&quot; EXIT
                  = succeed "0" do
                    %span.k return
                  %span.c # The lock has been obtained! Proceed with nefarious things!
                  %span.k else
                  %span.c # Question: Should this be an error exit code or ?
                  succeed
                  %span.s2 &quot;Another process already owns the lockfile, exiting.&quot;
                  %span.k fi
                  %span.o }
                  on_exit
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _commands
                  %span.o =
                  %span.s2 &quot;$*&quot;
                  %span.nb local
                  %span.nv _on_exit_code
                  %span.o =
                  = succeed "s#" do
                    %span.s2 &quot;$(trap | awk '/EXIT/' | sed -e &quot;
                  %span.s1 ' EXIT##&quot; -e &quot;s#.*'
                  %span.c ##&quot;)&quot;
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;${_on_exit_code}&quot;
                  \!
                  %span.o =
                  *on_exit*
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb trap
                  %span.s2 &quot;on_exit_commands;${_on_exit_code}&quot;
                  EXIT
                  %span.k fi
                  = succeed "on_exit_commands+" do
                    %span.k                   %span.o =(
                  %span.s2 &quot;${_commands}&quot;
                  %span.o )
                  %span.o }
                  on_exit_commands
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _result
                  %span.o =
                  %span.s2 &quot;$?&quot;
                  %span.c # Preserve actual exit code.
                  = succeed "_command" do
                    %span.nb local
                  = succeed "_command" do
                    %span.k for
                  in
                  %span.s2 &quot;${on_exit_commands[@]}&quot;
                  %span.k do
                  %span.k if
                  \!
                  %span.nb eval
                  %span.s2 &quot;${_command}&quot;
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;On Exit Command Failed: ${_command}&quot;
                  %span.k fi
                  %span.k done
                  %span.k return
                  %span.s2 &quot;${_result}&quot;
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 bdsm_exports()
              %p
                Exports bdsm framework relevant environment variables for extension action
                processes.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ bdsm_exports
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  bdsm_exports
                  %span.o ()
                  %span.o {
                  %span.c # TODO: Filter this list of exports down.
                  = succeed "action" do
                    %span.nb export
                  archives_path bdsm_path branch config_path database database_name debug_flag environment error_message extension extension_action extension_args extension_bin_path extension_config_path extension_modules_path extension_path extension_templates_path extensions_path flags framework head_flag hooks_flag keep_releases modules_path old_releases parse_break paths prefix_path previous_path project project_path release_path remote repository result revision shared_path src_path templates_path timestamp tmp_path trace_flag user extension_log_path
                  %span.o }
          %tr
            %td.docs
              %h2 bdsm_version()
              %p Reads the currently installed bdsm version into the variable 'bdsm_version'.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p The variable 'bdsm_version' will be set after the function is executed.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ bdsm_version
                    user$ echo $bdsm_version
                    69.69.69
            %td.code
              .highlight
                %pre
                  bdsm_version
                  %span.o ()
                  %span.o {
                  = succeed "file_is_nonempty" do
                    %span.k if
                  %span.s2 &quot;$bdsm_path/VERSION&quot;
                  %span.k then
                  %span.k                   %span.nb read
                  \-r bdsm_version &lt;
                  %span.s2 &quot;$bdsm_path/VERSION&quot;
                  %span.k else
                  %span.k                   %span.nv bdsm_version
                  %span.o =
                  %span.s2 &quot;?.?.?&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 NIY()
              %p
                Prints a failure message and backtrace to the screen letting the caller know
                that the requested feature has not yet been implemented.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                Prints "This feature has not yet been implemented." to STDERR of the calling
                environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p None, only exit is through failure.
              %h3 Failure Scenarios
              %p Fails always.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat $HOME/test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    NIY
                    
                    user$ $HOME/test
                    ERROR: This feature has not yet been implemented.
                    Backtrace:
                       Trace   Line Function             File
                          3.    262 fail()               /usr/local/bdsm/modules/bash/logging/dsl
                          2.      5 NIY()                /usr/local/bdsm/modules/bash/extensions/dsl
                          1.      5 main()               /Users/wayneeseguin/test
                     &gt; modules/bash/logging/dsl fail() 263 $ exit 1
            %td.code
              .highlight
                %pre
                  NIY
                  %span.o ()
                  %span.o {
                  fail
                  %span.s2 &quot;This feature has not yet been implemented.\n${*:-}&quot;
                  %span.o }
          %tr
            %td.docs
              %p Allow for method_missing when a command is not found during lookup.
            %td.code
              .highlight
                %pre
                  %span.k if
                  %span.o ((
                  %span.k ${
                  %span.nv BASH_VERSINFO
                  %span.p [0]
                  %span.k }
                  \&gt; 3
                  %span.o ))
                  %span.k then
                  = succeed "command_not_found" do
                    %span.k                   %span.o ()
                  %span.o {
                  %span.nb echo
                  %span.s2 &quot;bash: $1: command not found ($*)&quot;
                  \&gt;&amp;2
                  = succeed "127" do
                    %span.k return
                  %span.o }
                  command_not_found_handle
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${MC_SID}&quot;
                  %span.o ||
                  \! -t 1
                  %span.o ]]
                  %span.k then
                  %span.c # do not run when inside Midnight Commander or within a Pipe
                  command_not_found
                  %span.s2 &quot;$@&quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  %span.nv $MACHTYPE
                  %span.o =
                  *linux*
                  %span.o ]]
                  %span.k then
                  %span.c # do not run when within a subshell, Linux version.
                  = succeed "cmd" do
                    %span.nb local
                  state remainder
                  %span.nb local
                  \-i pid ppid pgrp session tty_nr tpgid
                  = succeed "pid" do
                    %span.nb read
                  cmd state ppid pgrp session tty_nr tpgid remainder &lt; /proc/self/stat
                  %span.k if
                  %span.o ((
                  %span.nv $$
                  %span.o ==
                  %span.k ${
                  %span.nv tpgid
                  %span.k }
                  %span.o ))
                  %span.k then
                  = succeed "command_not_found" do
                    %span.k                   %span.s2 &quot;$@&quot;
                  %span.k fi
                  %span.k fi
                  %span.k if
                  %span.nb command
                  \-v method_missing
                  %span.k then
                  %span.c # Pass to method_missing.
                  method_missing
                  %span.s2 &quot;$@&quot;
                  %span.k else
                  %span.c # Default behavior.
                  command_not_found
                  %span.s2 &quot;$@&quot;
                  %span.k fi
                  %span.o }
                  %span.k fi
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 command_exists()
              %p Checks to see whether a command exists within the current environment and PATH
              %h3 Input Parameters
              %p First parameter is a command name.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p none.
              %h3 return codes
              %p
                0 if the command was found in the current environment
                1 if the command was not found in the current environment
              %h3 failure scenarios
              %p Fails if no command name was given.
              %h3 usage examples
              %pre
                %code
                  :preserve
                    user$ command_exists adsf
                    user$ echo $?
                    1
                    
                    user$ command_exists ls
                    user$ echo $?
                    0
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  command_exists
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _name
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_name}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.nb command
                  \-v
                  %span.s2 &quot;${_name}&quot;
                  \&gt; /dev/null 2&gt;&amp;1
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot test if command exists as no command name was given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                is
                %em> a
                function()
              %p Checks to see whether a named function exists within the current environment
              %h3 Input Parameters
              %p First parameter is a function name.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p none.
              %h3 return codes
              %p
                0 if the function exists
                1 if the function does not exist
              %h3 failure scenarios
              %p Fails if no function name was given.
              %h3 usage examples
              %pre
                %code
                  :preserve
                    user$ is_a_function rvm
                    user$ echo $?
                    0
                    
                    user$ is_a_function asdf
                    user$ echo $?
                    1
                    
                    user$ is_a_function ls
                    user$ echo $?
                    1
            %td.code
              .highlight
                %pre
                  is_a_function
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _name
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_name}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.nb declare
                  \-f
                  %span.s2 &quot;${_name}&quot;
                  \&gt;/dev/null 2&gt;&amp;1
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot test if function exists as no function name was given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                shell
                %em> is
                interactive()
              %p Checks if the currently running shell is interactive (user controlled).
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p none.
              %h3 return codes
              %p
                0 if the shell is interactive (user controlled)
                1 if the shell is not interactive
              %h3 failure scenarios
              %p None currently.
              %h3 usage examples
              %p user$ cat $HOME/test
              %h1 !/usr/bin/env bash
              %p
                source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                modules environment # Load the trace module.
              %p
                if shell
                %em> is
                interactive
                then
                echo "Shell is Interactive! "
                else
                echo "Shell is Not Interactive! "
                fi
              %p
                user$ "$HOME/test"
                Shell is Not Interactive!
              %p
                user$ source "$HOME/test"
                Shell is Interactive!
            %td.code
              .highlight
                %pre
                  shell_is_interactive
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;$-&quot;
                  %span.o =
                  *i*
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 read_default()
              %p Reads default values from an extension's config/defaults file.
              %h3 Input Parameters
              %p
                First parameter is the defaults file key to read (key=value).
                Second parameter is the variable name to store the retrieved value in.
                Remaining parameters are parsed out as token, value and prefix
                into|as
                %variable{:name => ""}
                  prefix
                  %name
                    %variable # If no specifier.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                A variable will be set to the value, if the value is nonempty. If no variable
                name is specified the variable will be assigned the same name as the key.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Fails if no arguments are passed in, at least need to specify a key.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ read_default "version" prefix "package" # extension is nginx for example
                    user$ echo $package_version
                    1.0.0
              %h3 Notes
              %p read_default respects a tiered default file scheme,
              %p
                "/etc/bdsm/${extension}/defaults"
                "$HOME/.bdsm/${extension}/defaults"
                "${extension
                %em> config
                path}/defaults"
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  read_default
                  %span.o ()
                  %span.o {
                  = succeed "key" do
                    %span.nb local
                  variable token value prefix _file _files _temp
                  %span.nv key
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${key}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;$extension $action read_default() no arguments passed! &quot;
                  %span.k else
                  %span.k                   %span.nb shift
                  %span.nb                   %span.k fi
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;$token&quot;
                  in
                  into|as
                  %span.o )
                  %span.nv variable
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  ;;
                  prefix
                  %span.o )
                  %span.nv prefix
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  ;;
                  *
                  %span.o )
                  %span.nv variable
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.nb break
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${variable:-}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${prefix:-}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb true
                  %span.s2 &quot;${variable:=&quot;
                  %span.k ${
                  %span.nv prefix
                  = succeed "_" do
                    %span.k :-}
                  %span.nv $key
                  %span.s2 &quot;}&quot;
                  %span.k else
                  %span.k                   %span.nb true
                  %span.s2 &quot;${variable:=&quot;
                  %span.nv $key
                  %span.s2 &quot;}&quot;
                  %span.k fi
                  %span.k fi
                  %span.k                   %span.nv _files
                  %span.o =(
                  %span.s2 &quot;/etc/bdsm/${extension}/defaults&quot;
                  %span.s2 &quot;$HOME/.bdsm/${extension}/defaults&quot;
                  %span.s2 &quot;${extension_config_path}/defaults&quot;
                  %span.o )
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  = succeed "file_is_nonempty" do
                    %span.k if
                  %span.s2 &quot;${_file}&quot;
                  %span.k then
                  %span.k                   %span.nv _temp
                  %span.o =
                  %span.s2 &quot;$(hash_file &quot;
                  %span.k ${
                  %span.nv _file
                  %span.k }
                  %span.s2 &quot; &quot;
                  %span.k ${
                  %span.nv key
                  %span.k }
                  %span.s2 &quot;)&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_temp}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv value
                  %span.o =
                  %span.s2 &quot;${_temp}&quot;
                  %span.k fi
                  %span.k fi
                  %span.k done
                  %span.k                   %span.nb eval
                  %span.s2 &quot;${variable}=\&quot;${value}\&quot;&quot;
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %p TODO: Use git cli instead of awking it :)
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  scm_fetch
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _url
                  %span.o =
                  %span.s2 &quot;${1:-${extension_url:-}}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_url}&quot;
                  %span.o ]]
                  %span.k then
                  fail
                  %span.s2 &quot;Cannot fetch an extension from a url as no url was given&quot;
                  %span.k fi
                  %span.nb local
                  %span.nv _identifier
                  %span.o =
                  %span.s2 &quot;${_url//\//_}&quot;
                  %span.c # Convert '/' to an invalid url component '_'
                  %span.nb local
                  %span.nv repo_path
                  %span.o =
                  %span.s2 &quot;${repos_path}/${_identifier}&quot;
                  ensure_paths_exist
                  %span.s2 &quot;${repos_path}&quot;
                  %span.k case
                  %span.s2 &quot;${_url}&quot;
                  in
                  *git*
                  %span.o )
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${repo_path}/.git&quot;
                  %span.k then
                  %span.nb true
                  %span.c # already fetched!
                  %span.k else
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${repo_path}&quot;
                  %span.k then
                  remove_paths
                  %span.s2 &quot;${repo_path}&quot;
                  %span.k fi
                  %span.k if
                  \! git clone --depth 1
                  %span.k ${
                  %span.nv _url
                  %span.k }
                  %span.s2 &quot;${repo_path}&quot;
                  %span.k then
                  error
                  %span.s2 &quot;There was an error while cloning the repository from the url '${_url}'&quot;
                  %span.k fi
                  %span.k fi
                  ;;
                  *svn*
                  %span.o )
                  NIY
                  ;;
                  *hg*
                  %span.o )
                  NIY
                  ;;
                  *fossil*
                  %span.o )
                  NIY
                  ;;
                  *
                  %span.o )
                  ;;
                  %span.k esac
                  %span.o }
                  scm_update
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _url
                  %span.o =
                  %span.s2 &quot;${1:-${extension_url:-}}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_url}&quot;
                  %span.o ]]
                  %span.k then
                  fail
                  %span.s2 &quot;Cannot fetch an extension from a url as no url was given&quot;
                  %span.k fi
                  %span.nb local
                  %span.nv _identifier
                  %span.o =
                  %span.s2 &quot;${_url//\//_}&quot;
                  %span.c # Convert '/' to an invalid url component '_'
                  %span.nb local
                  %span.nv repo_path
                  %span.o =
                  %span.s2 &quot;${repos_path}/${_identifier}&quot;
                  %span.k case
                  %span.s2 &quot;${_url}&quot;
                  in
                  *git*
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-z
                  = succeed "/" do
                    %span.s2 &quot;$(git branch | awk &quot;
                  %span.k ${
                  %span.nv branch
                  %span.p :=master
                  %span.k }
                  %span.nv $/
                  %span.s2 &quot;)&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  \!
                  %span.o (
                  %span.nb builtin cd
                  = succeed ";" do
                    %span.s2 &quot;${repo_path}&quot;
                  git checkout -b
                  %span.s2 &quot;$branch&quot;
                  \--track
                  %span.s2 &quot;$remote/$branch&quot;
                  2&gt;/dev/null
                  %span.o )
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;$remote $branch remote branch not found. Halting.&quot;
                  %span.k fi
                  %span.k elif
                  %span.o [[
                  \-z
                  = succeed "/" do
                    %span.s2 &quot;$(git branch | awk &quot;
                  %span.se \*
                  %span.nv $branch$/
                  = succeed "print" do
                    %span.o {
                  = succeed "2" do
                    %span.se \$
                  %span.o }
                  %span.s2 &quot;)&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  \!
                  %span.o (
                  %span.nb builtin cd
                  = succeed ";" do
                    %span.s2 &quot;${repo_path}&quot;
                  git checkout
                  %span.nv $branch
                  2&gt;/dev/null
                  %span.o )
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Unable to checkout $branch.\nCould not get head. Halting.&quot;
                  %span.k fi
                  %span.k fi
                  %span.k if
                  \!
                  %span.o (
                  %span.nb builtin cd
                  %span.s2 &quot;${repo_path}&quot;
                  ;
                  git pull --rebase origin
                  %span.nv $branch
                  %span.o )
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Git pull failed. Halting.&quot;
                  %span.k fi
                  ;;
                  *svn*
                  %span.o )
                  NIY
                  %span.s2 &quot;Subversion scm_update&quot;
                  ;;
                  *hg*
                  %span.o )
                  NIY
                  %span.s2 &quot;hg scm_update&quot;
                  ;;
                  *fossil*
                  %span.o )
                  NIY
                  %span.s2 &quot;fossil scm_update&quot;
                  ;;
                  *
                  %span.o )
                  error
                  %span.s2 &quot;Unknownn SCM for url '${_url}'&quot;
                  ;;
                  %span.k esac
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 first()
              %p Returns the first parameter.
              %h3 Input Parameters
              %p One or more parameters.
              %h3 Stream Outputs
              %p Prints the first positional parameter to STDOUT of the calling environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no parameters are passed.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ first one two three
                    one
                    
                    user$ array=($(ls $HOME))
                    user$ first ${array[@]}
                    Desktop
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  first
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _array
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;${_array[0]}&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;No parameters given, cannot return the first one.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 last()
              %p Returns the last parameter.
              %h3 Input Parameters
              %p One or more parameters.
              %h3 Stream Outputs
              %p Prints the last positional parameter to STDOUT of the calling environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no parameters are passed.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ last one two three
                    one
                    
                    user$ array=($(ls $HOME))
                    user$ last ${array[@]}
                    tmp
            %td.code
              .highlight
                %pre
                  last
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _array
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;${_array[$((${#_array[@]} - 1))]}&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;No parameters given, cannot return the last one.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 match()
              %p Tests to see if a value matches a given regex (shell extended glob pattern).
              %h3 Input Parameters
              %p Positional Parameter listing and descriptions.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the value matches the regex (shell extended glob pattern)
                1 if the value does not match the regex (shell extended glob pattern)
              %h3 Failure Scenarios
              %p
                Fails if no value is given
                Fails if no regex is given
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ match "The quick brown fox jumped over the lazy dog." "*fox*"
                    user$ echo $?
                    0
                    
                    user$ match "The quick brown fox jumped over the lazy dog." "*smurf*"
                    user$ echo $?
                    1
            %td.code
              .highlight
                %pre
                  match
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _value
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_value}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb local
                  %span.nv _regex
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_value}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb shopt
                  \-s extglob
                  %span.k case
                  %span.s2 &quot;${_value}&quot;
                  in
                  %span.o (
                  %span.k ${
                  %span.nv _regex
                  %span.k }
                  %span.o )
                  = succeed "0" do
                    %span.k return
                  ;;
                  = succeed "*" do
                    %span.o (
                  %span.o )
                  = succeed "1" do
                    %span.k return
                  ;;
                  %span.k esac
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;A regex must be specified in order to match ${_value} against it.&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;A value and regex must be specified in order to match.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                variables
                %em> must
                be_nonempty()
              %p
                Halts the program with a fail message if any of the named variables are empty
                or undefined.
              %h3 Input Parameters
              %p One or more parameters specifying the names of variables.
              %h3 Stream Outputs
              %p None if all are
              %h3 Environmental effects
              %p What, if any, environmental side effects this function causes. 'None.' for none.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no varaible names were given.
                Fails if any of the named variables are empty.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules trace variables # Load the trace module.
                    unset HOME
                    variables_must_be_nonempty HOME
                    
                    user$ $PWD/test
                    ERROR: Required variable 'HOME' is not set.
                    ERROR: A command has returned an unhandled error code (nonzero return value).
                    Backtrace:
                       Trace   Line Function             File
                          3.     37 fail()               /usr/local/bdsm/modules/bash/logging/dsl
                          2.    192 variables_must_be_nonempty() /usr/local/bdsm/modules/bash/variables/dsl
                          1.      6 main()               /Users/wayneeseguin/test
                     &gt; modules/bash/logging/dsl fail() 38 $ exit 1
            %td.code
              .highlight
                %pre
                  variables_must_be_nonempty
                  %span.o ()
                  %span.o {
                  = succeed "_variable" do
                    %span.nb local
                  %span.nv _variables
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _variables
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_variable" do
                    %span.k for
                  in
                  %span.s2 &quot;${_variables}&quot;
                  %span.k do
                  %span.k if
                  %span.nb eval
                  %span.s2 &quot;[[ -n \&quot;\${${_variable}}\&quot; ]]&quot;
                  %span.k then
                  %span.k continue
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Required variable '$_variable' is not set.&quot;
                  %span.k fi
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot ensure variables are nonempty as no variables were given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                variable
                %em> is
                nonempty()
              %p Test to see if a variable is empty.
              %h3 Input Parameters
              %p First parameter is a string containing a variable name.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Fails if no variable name was given as the first argument.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ variable_is_nonempty asdf
                    user$ echo $?
                    1
                    
                    user$ asdf="w00t! "
                    user$ variable_is_nonempty asdf
                    user$ echo $?
                    0
            %td.code
              .highlight
                %pre
                  variable_is_nonempty
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _variable
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_variable}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.nb eval
                  %span.s2 &quot;[[ -n \&quot;\${${_variable}:-}\&quot; ]]&quot;
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check if variable is nonempty, no variable was given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                variable
                %em> is
                empty()
              %p Test to see if a variable is empty.
              %h3 Input Parameters
              %p First parameter is a string containing a variable name.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Fails if no variable name was given as the first argument.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ variable_is_empty asdf
                    user$ echo $?
                    1
                    
                    user$ asdf="w00t! "
                    user$ variable_is_empty asdf
                    user$ echo $?
                    0
            %td.code
              .highlight
                %pre
                  variable_is_empty
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _variable
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_variable}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.nb eval
                  %span.s2 &quot;[[ -z \&quot;\${${_variable}:-}\&quot; ]]&quot;
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check if variable is empty as no variable was given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                variables
                %em> are
                nonempty()
              %p Test to see if any of a given list of variables are empty.
              %h3 Input Parameters
              %p First parameter is a string containing a variable name.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if all variables given are nonempty.
                1 if any variable given is nonempty.
              %h3 Failure Scenarios
              %p Fails if no variable names were given as arguments.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ variables_are_nonempty BASH_VERSION asdf
                    user$ echo $?
                    1
                    
                    user$ asdf="w00t! "
                    user$ variables_are_nonempty BASH_VERSION asdf
                    user$ echo $?
                    0
            %td.code
              .highlight
                %pre
                  variables_are_nonempty
                  %span.o ()
                  %span.o {
                  = succeed "_variable" do
                    %span.nb local
                  %span.nv _variables
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.s2 &quot;${#_variables[@]}&quot;
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_variable" do
                    %span.k for
                  in
                  %span.s2 &quot;${_variables}&quot;
                  %span.k do
                  %span.k if
                  %span.nb eval
                  %span.s2 &quot;[[ -z \&quot;\${${_variable}:-}\&quot; ]]&quot;
                  %span.k then
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k done
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check if variables are nonempty as no variables were given.&quot;
                  %span.k fi
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 template_exists()
              %p
                Checks if a named template file exists in the extension
                %em> templates
                path
              %h3 Input Parameters
              %p First parameter must be the name of a template file, eg. a string.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p
                0 if the named template file exists and is nonempty.
                1 if the named template file does not exist or is empty.
              %h3 Failure Scenarios
              %p Fails if no template name is given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ {{ setup the scenario }}
                    user$ function_name {{ parameters }}
                    user$ {{ demonstrate the results}}
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  template_exists
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${1:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check if a template exists as no template name was given.&quot;
                  %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _template
                  %span.o =
                  %span.s2 &quot;${extension_templates_path}/${1}.template&quot;
                  %span.k if
                  %span.o [[
                  \-s
                  %span.s2 &quot;${_template}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 install_template()
              %p Installs a named template to a given location.
              %h3 Input Parameters
              %p
                The first parameter should be the template name.
                Remaining parameters specify the target, mode and owner:
                owner "&lt;
                %user
                  >[:&lt;
                  %group
                    >]"
                    mode 0755
                    to "/path/to/new/file"
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p
                0 if successful
                1 otherwise
              %h3 Failure Scenarios
              %p
                Fails if no template name was given.
                Fails if the template name given is a directory.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ install_template "nginx.conf" \
                          to "${nginx_path}/nginx.conf" \
                          mode 0644 owner "${nginx_user}"
            %td.code
              .highlight
                %pre
                  install_template
                  %span.o ()
                  %span.o {
                  = succeed "_template" do
                    %span.nb local
                  _name _target
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;${extension_templates_path}&quot;
                  %span.nv _mode
                  = succeed "0644" do
                    %span.o =
                  %span.nv _owner
                  %span.o =
                  %span.nv $USER
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  ;
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  ;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${token}&quot;
                  in
                  to
                  %span.o )
                  %span.nv _target
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  ;
                  %span.nb shift
                  ;;
                  
                  mode
                  %span.o )
                  %span.nv _mode
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  ;
                  %span.nb shift
                  ;;
                  
                  owner
                  %span.o )
                  %span.nv _owner
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  ;
                  %span.nb shift
                  ;;
                  
                  from
                  %span.o )
                  %span.c # TODO: finish this part.
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  ;
                  %span.nb shift
                  ;;
                  
                  *
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_name}&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  %span.k                   %span.nv _name
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.k elif
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  %span.k                   %span.nv _target
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.nb break
                  %span.c # When we have a target we are done.
          %tr
            %td.docs
              %p
                An alternative idea would be to allow an array of multiple targets
                to symlink to...
            %td.code
              .highlight
                %pre
                  %span.k fi
                  ;;
                  %span.k esac
                  %span.k done
                  = succeed "file_exists" do
                    %span.k if
                  %span.s2 &quot;${_name}&quot;
                  %span.k then
                  %span.k                   %span.nv _template
                  %span.o =
                  %span.s2 &quot;${_name}&quot;
                  = succeed "file_exists" do
                    %span.k elif
                  %span.s2 &quot;${_source}/${_name}&quot;
                  %span.k then
                  %span.k                   %span.nv _template
                  %span.o =
                  %span.s2 &quot;${_source}/${_name}&quot;
                  %span.k else
                  %span.k                   %span.nv _template
                  %span.o =
                  %span.s2 &quot;${_source}/${_name}.template&quot;
                  %span.k fi
                  = succeed "ensure_paths_exist" do
                    %span.k                   %span.s2 &quot;$(dirname &quot;
                  %span.k ${
                  %span.nv _target
                  %span.k }
                  %span.s2 &quot;)&quot;
                  %span.k if
                  %span.o [[
                  \-f
                  %span.s2 &quot;${_template}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_target}/${_name}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot install the template '${_template}' to ${_target}/${_name} &quot;
                  %span.se \
                  %span.s2 &quot; as it is a directory&quot;
                  %span.k else
                  = succeed "cp" do
                    %span.k                   \-f
                  %span.s2 &quot;${_template}&quot;
                  %span.s2 &quot;${_target}/${_name}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_mode:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "chmod" do
                    %span.k                   %span.s2 &quot;${_mode}&quot;
                  %span.s2 &quot;${_target}/${_name}&quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_owner:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "chown" do
                    %span.k                   %span.s2 &quot;${_owner}&quot;
                  %span.s2 &quot;${_target}/${_name}&quot;
                  %span.k fi
                  %span.k fi
                  %span.k else
                  = succeed "cp" do
                    %span.k                   \-f
                  %span.s2 &quot;${_template}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_mode:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "chmod" do
                    %span.k                   %span.s2 &quot;${_mode}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_owner:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "chown" do
                    %span.k                   %span.s2 &quot;${_owner}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k fi
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot install template as the template file '${_template}' is missing.'&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 seed_template()
              %p Seed a template file replacing all given keys with given values.
              %h3 Input Parameters
              %p
                First parameter must be the template filename to seed.
                Remaining parameters must come in pairs, the first of each pair specifies
                the key to search and replace in the template file and the second is the
                value to replace {{$key}} with.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no template filename is given.
                Fails if the template given does not exist.
                Fails if no key/value pairs are given.
                Fails if for every key there is no associated value.
                Fails if the intermediate template file does not exist...
              %h3 Usage Examples
              %p
                user$ seed
                %em>
                  template "/etc/conf.d/${extension}.conf" \
                  prefix
                path "${prefix
                %em>
                  path}" \
                  init
                scripts
                %em> path "${init
                scripts
                %em>
                  path}" \
                  modules
                path "${modules
                %em>
                  path}" \
                  data
                path "${data
                %em>
                  path}" \
                  confd
                path "${confd_path}" \
                extension "${extension}"
            %td.code
              .highlight
                %pre
                  seed_template
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _template
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_template}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb local
                  %span.nv _args
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.nv _strings
                  %span.o =()
                  %span.k if
                  %span.o [[
                  \-f
                  %span.s2 &quot;${_template}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _args
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot seed template '${_template}' as no replacement keys were&quot;
                  %span.se \
                  %span.s2 &quot;specified&quot;
                  %span.k else
                  %span.k if
                  %span.o ((
                  %span.o (
                  %span.k ${#
                  %span.nv _args
                  %span.p [@]
                  %span.k }
                  \% 2
                  %span.o )
                  %span.o ==
                  1
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Every replacement key must have a replacement value.&quot;
                  %span.k fi
                  %span.k fi
                  = succeed "warn" do
                    %span.k                   %span.s2 &quot;Template Seeding (replacing defaults) has not yet fully implemented.&quot;
          %tr
            %td.docs
              %p Aggregate the replacement strings.
            %td.code
              .highlight
                %pre
                  %span.k for
                  %span.o ((
                  %span.nv index
                  = succeed "0" do
                    %span.o =
                  ; index &lt;
                  %span.k ${#
                  %span.nv _args
                  %span.p [@]
                  %span.k }
                  ; index++
                  %span.o ))
                  %span.k do
                  = succeed "_strings+" do
                    %span.k                   %span.o =(
                  %span.s2 &quot; -e 's#${_args[${index}]}#${_args[$((++index))]}#g' &quot;
                  %span.o )
                  %span.k done
          %tr
            %td.docs
              %p Filter the template with the replacments.
            %td.code
              .highlight
                %pre
                  sed
                  %span.k ${
                  %span.nv _strings
                  %span.p [@]
                  %span.k }
                  %span.k ${
                  %span.nv _template
                  %span.k }
                  \&gt;&gt;
                  %span.k ${
                  %span.nv _template
                  = succeed "." do
                    %span.k }
                  %span.k ${
                  %span.nv timestamp
                  %span.k }
                  = succeed "file_exists" do
                    %span.k if
                  %span.s2 &quot;${_template}.${timestamp}&quot;
                  %span.k then
                  = succeed "mv" do
                    %span.k                   \-f
                  %span.s2 &quot;${_template}.${timestamp}&quot;
                  %span.s2 &quot;${_template}&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Something went horribly wrong, the template intermediate file &quot;
                  %span.se \
                  %span.s2 &quot;'${_template}.${timestamp}' does not exist.&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Can not seed template template file '${_template}' does not exist.&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Can not install template as no template was given.&quot;
                  %span.k fi
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 log()
              %p Log arguments to the calling environments STDOUT.
              %h3 Input Parameters
              %p Strings to be logged.
              %h3 Stream Outputs
              %p
                Prints arguments passed in to the calling environments STDOUT with a newline
                character appended.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no arguments are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ log "Hello there! "
                    Hello there!
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  log
                  %span.o ()
                  %span.o {
                  = succeed "_token" do
                    %span.nb local
                  _file _message
                  %span.nv _append_flag
                  = succeed "0" do
                    %span.o =
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv _token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${_token}&quot;
                  in
                  = succeed "append|--append" do
                    %span.o (
                  %span.o )
                  %span.nv _append_flag
                  = succeed "1" do
                    %span.o =
                  ;;
                  = succeed "to" do
                    %span.o (
                  %span.o )
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  = succeed "*" do
                    %span.o (
                  %span.o )
                  %span.nv _message
                  %span.o =
                  %span.s2 &quot;${_token}&quot;
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_message:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot log a message as no message was given.&quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o ((
                  %span.nv _append_flag
                  %span.o ==
                  1
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nb printf
                  %span.s2 &quot;${_message}\n&quot;
                  \&gt;&gt;
                  %span.s2 &quot;${_file}&quot;
                  %span.k else
                  %span.k                   %span.nb printf
                  %span.s2 &quot;${_message}\n&quot;
                  \&gt;
                  %span.s2 &quot;${_file}&quot;
                  %span.k fi
                  %span.k else
                  %span.k                   %span.nb printf
                  %span.s2 &quot;${_message}\n&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 info()
              %p Log arguments to the calling environments STDOUT preceeded by 'INFO .
              %h3 Input Parameters
              %p Strings to be logged.
              %h3 Stream Outputs
              %p
                Prints arguments passed in to the calling environments STDOUT with a newline
                character appended and 'INFO ' prepended.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no arguments are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ info "Hello there! "
                    INFO Hello there!
            %td.code
              .highlight
                %pre
                  info
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;INFO: $*&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 warn()
              %p Log arguments to the calling environments STDOUT preceeded by 'WARNING .
              %h3 Input Parameters
              %p Strings to be logged.
              %h3 Stream Outputs
              %p
                Prints arguments passed in to the calling environments STDOUT with a newline
                character appended and 'WARNING ' prepended.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no arguments are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ info "Bad Monkeys are Typing! "
                    WARNING: Bad Monkeys are Typing!
            %td.code
              .highlight
                %pre
                  warn
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;WARNING: $*&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 note()
              %p Log arguments to the calling environments STDOUT preceeded by 'NOTE .
              %h3 Input Parameters
              %p Strings to be logged.
              %h3 Stream Outputs
              %p
                Prints arguments passed in to the calling environments STDOUT with a newline
                character appended and 'NOTE ' prepended.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no arguments are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ info "You are not Smurfette! "
                    NOTE You are not Smurfette!
            %td.code
              .highlight
                %pre
                  note
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;NOTE: $*&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 debug()
              %p Log arguments to the calling environments STDOUT preceeded by 'DEBUG: .
              %h3 Input Parameters
              %p Strings to be logged.
              %h3 Stream Outputs
              %p
                Prints arguments passed in to the calling environments STDOUT with a newline
                character appended and 'DEBUG: ' prepended.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no arguments are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ debug "Hello there! "
                    DEBUG: Hello there!
            %td.code
              .highlight
                %pre
                  debug
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o ((
                  %span.k ${
                  %span.nv debug_flag
                  %span.p :=0
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;DEBUG: $*&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 error()
              %p
                Log arguments to the calling environments STDERR preceeded by 'ERROR '.
                Exits with status code 1.
              %h3 Input Parameters
              %p Strings to be logged.
              %h3 Stream Outputs
              %p
                Prints arguments passed in to the calling environments STDOUT with a newline
                character appended and 'ERROR ' prepended.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 1 for failure.
              %h3 Failure Scenarios
              %p Fails if no arguments are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ error "Hello there! "
                    ERROR Hello there!
                    *poof* shell closed...
            %td.code
              .highlight
                %pre
                  error
                  %span.o ()
                  %span.o {
                  %span.nb set
                  +o xtrace
                  log
                  %span.s2 &quot;\nERROR: $*&quot;
                  \&gt;&amp;2
                  disable_backtrace
                  = succeed "1" do
                    %span.nb exit
                  %span.o }
          %tr
            %td.docs
              %h2 succeed()
              %p Log arguments to the calling environments STDOUT. Exits with status code 0.
              %h3 Input Parameters
              %p Strings to be logged.
              %h3 Stream Outputs
              %p
                Prints arguments passed in to the calling environments STDOUT with a newline
                character appended.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no arguments are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ succeed "Hello there! "
                    Hello there!
                    *poof* shell closed...
            %td.code
              .highlight
                %pre
                  succeed
                  %span.o ()
                  %span.o {
                  %span.nb set
                  +o xtrace
                  log
                  %span.s2 &quot;$*&quot;
                  = succeed "0" do
                    %span.nb exit
                  %span.o }
          %tr
            %td.docs
              %h2 fail()
              %p
                Log arguments to the calling environments STDERR preceeded by 'ERROR '.
                Exits with status code 1.
              %h3 Input Parameters
              %p Strings to be logged.
              %h3 Stream Outputs
              %p
                Prints arguments passed in to the calling environments STDOUT with a newline
                character appended and 'ERROR ' prepended.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 1 for failure.
              %h3 Failure Scenarios
              %p Fails if no arguments are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ error "Hello there! "
                    ERROR Hello there!
                    *poof* shell closed...
            %td.code
              .highlight
                %pre
                  fail
                  %span.o ()
                  %span.o {
                  %span.nv trace_flag
                  = succeed "0" do
                    %span.o =
                  backtrace
                  %span.s2 &quot;$*&quot;
                  = succeed "1" do
                    %span.nb exit
                  %span.o }
          %tr
            %td.docs
              %h2 verbose()
              %p
                Log arguments to the calling environments STDERR preceeded by 'ERROR '.
                Exits with status code 1.
              %h3 Input Parameters
              %p Strings to be logged.
              %h3 Stream Outputs
              %p
                Prints arguments passed in to the calling environments STDOUT with a newline
                character appended and 'ERROR ' prepended.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 1 for verboseure.
              %h3 verboseure Scenarios
              %p verboses if no arguments are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ verbose "w00t! "
                    user$ verbose_flag=1
                    user$ verbose "w00t! "
                    w00t!
            %td.code
              .highlight
                %pre
                  verbose
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o ((
                  %span.k ${
                  %span.nv verbose_flag
                  %span.p :=0
                  %span.k }
                  %span.o ==
                  1
                  %span.o ))
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;$*&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 logrotate()
              %p Strategically rotate a logfile minimizing data loss.
              %p This function uses a copy, tail and truncate strategy.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    root# logrotate /var/log/my_logfile.log
            %td.code
              .highlight
                %pre
                  logrotate
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot rotate a log file as no log file was given.&quot;
                  %span.k fi
                  = succeed "set_timestamp" do
                    %span.k                   verbose
                  %span.s2 &quot;Tailing the file in a background process into a tail logfile.&quot;
                  %span.o (
                  tail -n 0 -f
                  %span.s2 &quot;${_file}&quot;
                  \&gt;
                  %span.k ${
                  %span.nv file
                  = succeed "." do
                    %span.k }
                  = succeed ".log" do
                    %span.nv $$
                  = succeed "&amp;amp;" do
                    %span.o )
                  %span.nb local
                  %span.nv _tail_pid
                  %span.o =
                  %span.nv $!
                  verbose
                  %span.s2 &quot;Copying the file's contentes into a new timestamped file.&quot;
                  cp
                  %span.s2 &quot;${_file}&quot;
                  %span.s2 &quot;${_file}.${timestamp}&quot;
                  verbose
                  %span.s2 &quot;Truncating the file.&quot;
                  cp /dev/null
                  %span.k ${
                  %span.nv _file
                  %span.k }
                  verbose
                  %span.s2 &quot;Signaling the tail background process to stop.&quot;
                  %span.nb kill
                  \-QUIT
                  %span.k ${
                  %span.nv _tail_pid
                  %span.k }
                  verbose
                  %span.s2 &quot;Appending the tail logfile to the new timestamped logfile.&quot;
                  cat
                  %span.s2 &quot;${file}.$$.log&quot;
                  \&gt;&gt;
                  %span.s2 &quot;${file}.${timestamp}&quot;
                  verbose
                  %span.s2 &quot;Compressing the timestamped file (gzip)&quot;
                  gzip -f -9
                  %span.s2 &quot;${file}.${timestamp}&quot;
                  verbose
                  %span.s2 &quot;Removing the tail logfile&quot;
                  rm
                  %span.s2 &quot;${file}.$$.log&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 log_streams()
              %p
                Log streams to three files:
                \- standard out
                \- standard in
                \- combined (what the user typically sees)
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    root# log_streams "make install" prefix make
                    cat make.out.log
                    root#
                    ...
              %p Alternatively,
              %pre
                %code
                  :preserve
                    root# log_streams "make install" \
                          out /path/to/out.log \
                          err /path/to/err.log \
                          mix /path/to/mix.log # both out &amp; err as they occurred.
                    root# cat /path/to/mix.log
                    ...
            %td.code
              .highlight
                %pre
                  log_streams
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _command
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _prefix _err _out _mix
          %tr
            %td.docs
              %p TODO: allow specification of path, name prefix
            %td.code
              .highlight
                %pre
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv _token
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${token}&quot;
                  in
                  prefix
                  %span.o )
                  %span.nv _prefix
                  %span.o =
                  %span.s2 &quot;${1}.&quot;
                  ;;
                  err
                  %span.o )
                  %span.nv _stderr
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  out
                  %span.o )
                  %span.nv _stdout
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  mix
                  %span.o )
                  %span.nv _stdmix
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  *
                  %span.o )
                  %span.nv _command
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  %span.k esac
                  %span.k done
                  \:
                  %span.se \
                  %span.s2 &quot;${_stdout=&quot;
                  %span.k ${
                  %span.nv 2
                  %span.k :-
                  %span.nv stdout
                  %span.p .log
                  %span.k }
                  %span.s2 &quot;}&quot;
                  %span.se \
                  %span.s2 &quot;${_stderr=&quot;
                  %span.k ${
                  %span.nv 3
                  %span.k :-
                  %span.nv stderr
                  %span.p .log
                  %span.k }
                  %span.s2 &quot;}&quot;
                  %span.se \
                  %span.s2 &quot;${_stdmix=&quot;
                  %span.k ${
                  %span.nv 4
                  %span.k :-
                  %span.nv stdmix
                  %span.p .log
                  %span.k }
                  %span.s2 &quot;}&quot;
                  %span.o {
                  %span.o {
                  %span.k ${
                  %span.nv _command
                  %span.k }
                  2&gt;&amp;1 1&gt;&amp;3 | tee
                  %span.s2 &quot;${_stderr}&quot;
                  %span.o }
                  3&gt;&amp;1 1&gt;&amp;2 | tee
                  %span.s2 &quot;${_stdout}&quot;
                  %span.o }
                  \&gt;
                  %span.s2 &quot;${_stdmix}&quot;
                  2&gt;&amp;1
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 set_ps4()
              %p Set the environmental PS4 variable for informative tracing.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ echo "'$PS4'"
                    '+ '
                    user$ set_ps4
                    user$ echo "'$PS4'"
                    ' &gt; ${BASH_SOURCE##${bdsm_path}\/} ${FUNCNAME[0]:+${FUNCNAME[0]}()} ${LINENO} $ '
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  set_ps4
                  %span.o ()
                  %span.o {
                  %span.nv PS4
                  %span.o =
                  %span.s2 &quot; &gt; \${BASH_SOURCE##\${bdsm_path}\/} \${FUNCNAME[0]:+\${FUNCNAME[0]}()} \${LINENO} $ &quot;
                  = succeed "PS4" do
                    %span.nb export
                  %span.o }
          %tr
            %td.docs
              %h2 trace()
              %p
                Toggle tracing functionality on or off. If 'on' is triggered then every line
                of code execution after the function returns will be displayed in the format
                specified by the PS4 environment variable (see set_ps4).
              %h3 Input Parameters
              %p First parameter is either empty, 'on' or 'off'
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ trace on
                    user$ echo "hi"
                    &gt;   1 $ echo hi
                    user$ trace off
                    &gt;  trace() 1 $ local _option=off
                    &gt;  trace() 3 $ [[ off = \o\n ]]
                    &gt;  trace() 8 $ set +o xtrace
            %td.code
              .highlight
                %pre
                  trace
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _option
                  %span.o =
                  %span.s2 &quot;${1:-on}&quot;
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;${_option}&quot;
                  %span.o =
                  %span.s2 &quot;on&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb export
                  %span.nv trace_flag
                  = succeed "1" do
                    %span.o =
                  %span.nb set
                  \-o xtrace
                  %span.k else
                  %span.k                   %span.nb set
                  +o xtrace
                  %span.nb export
                  %span.nv trace_flag
                  = succeed "0" do
                    %span.o =
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 enable_trace()
              %p Turns tracing on.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ enable_trace
            %td.code
              .highlight
                %pre
                  enable_trace
                  %span.o ()
                  %span.o {
                  trace on
                  %span.o }
          %tr
            %td.docs
              %h2 disable_trace()
              %p Turns tracing off.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No current failure scenarios.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ disable_trace
            %td.code
              .highlight
                %pre
                  disable_trace
                  %span.o ()
                  %span.o {
                  trace off
                  %span.o }
          %tr
            %td.docs
              %h2 debug()
              %p
                Toggle verbose debugging functionality on or off. If 'on' is triggered then
                every line of code execution after the function returns will be displayed.
              %h3 Input Parameters
              %p First parameter is either empty, 'on' or 'off'
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ debug on
                    user$ echo "hi"
                    &gt;   1 $ echo hi
                    user$ debug off
                    &gt;  debug() 1 $ local _option=off
                    &gt;  debug() 3 $ [[ off = \o\n ]]
                    &gt;  debug() 8 $ set +o xdebug
            %td.code
              .highlight
                %pre
                  debug
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _option
                  %span.o =
                  %span.s2 &quot;${1:-on}&quot;
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;${_option}&quot;
                  %span.o =
                  %span.s2 &quot;on&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  %span.k                   %span.nb export
                  %span.nv debug_flag
                  = succeed "1" do
                    %span.o =
                  %span.nb set
                  \-o verbose
                  %span.k else
                  %span.k                   %span.nb set
                  +o verbose
                  %span.nb export
                  %span.nv debug_flag
                  = succeed "0" do
                    %span.o =
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 enable_debug()
              %p Enables verbose debugging output.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ enable_debug
            %td.code
              .highlight
                %pre
                  enable_debug
                  %span.o ()
                  %span.o {
                  debug on
                  %span.o }
          %tr
            %td.docs
              %h2 disable_debug()
              %p Disables verbose debugging output.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ disable_debug
            %td.code
              .highlight
                %pre
                  disable_debug
                  %span.o ()
                  %span.o {
                  debug off
                  %span.o }
          %tr
            %td.docs
              %h2 enable_backtrace()
              %p
                Enables backtrace and program exit whenever a command returns a nonzero value
                that is not handled.
              %h3 Input Parameters
              %p
                First parameter is optional. If it is passed it is a message that will be
                outputed when a command trigger the program to error exit.
              %h3 Stream Outputs
              %p What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat ./test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules trace # Load the trace module.
                    enable_backtrace
                    echo "Error exit with backtrace is now off."
                    false # Does not cause exiting with backtrace printing.
                    
                    user$ $PWD/test
                    Error exit with backtrace is on.
                    ERROR: A command has returned an unhandled error code (nonzero return value).
                    Error Backtrace:
                       Trace   Function           Line  File
                          1.   main()                7  /Users/wayneeseguin/test
            %td.code
              .highlight
                %pre
                  enable_backtrace
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _message
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_message}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb trap
                  %span.s2 &quot;backtrace \&quot;${_message}\&quot;&quot;
                  ERR
                  %span.k else
                  %span.k                   %span.nb trap
                  %span.s2 &quot;backtrace \&quot;A command has returned an unhandled error code (nonzero return value).\&quot;&quot;
                  ERR
                  %span.k fi
                  %span.k                   %span.nb set
                  \-o errexit
                  %span.o }
          %tr
            %td.docs
              %h2 function_name()
              %p Function Description
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat ./test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules trace # Load the trace module.
                    disable_backtrace
                    echo "Error exit with backtrace is now off."
                    false # Does not cause exiting with backtrace printing.
                    
                    user$ ./test
                    Error exit with backtrace is now off.
            %td.code
              .highlight
                %pre
                  disable_backtrace
                  %span.o ()
                  %span.o {
                  %span.nb set
                  +o errexit
                  %span.nb trap
                  \- ERR
                  %span.o }
          %tr
            %td.docs
              %h2 backtrace()
              %p
                Display a backtrace of the current call stack to the point that backtrace was
                called from. Currently trace is turned on as well so that execution after
                calling backtrace is traced.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                The call stack up to the current point of execution is printed to STDOUT of
                the calling environment.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat ./test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules trace # Load the trace module.
                    
                    functiona()
                    {
                      echo "function a"
                      functionb
                      echo "function a"
                    }
                    
                    functionb()
                    {
                      echo "function b"
                      functionc
                      echo "function b"
                    }
                    
                    functionc()
                    {
                      echo "function c"
                      backtrace
                      echo "function c"
                    }
                    
                    functiona
                    
                    user$ $PWD/test
                    function a
                    function b
                    function c
                    Error Backtrace:
                       Trace   Line Function             File
                          4.     25 functionc()          /Users/wayneeseguin/test
                          3.     18 functionb()          /Users/wayneeseguin/test
                          2.     11 functiona()          /Users/wayneeseguin/test
                          1.     29 main()               /Users/wayneeseguin/test
                     &gt; /Users/wayneeseguin/test functionc() 26 $ echo 'function c'
                    function c
                     &gt; /Users/wayneeseguin/test functionb() 19 $ echo 'function b'
                    function b
                     &gt; /Users/wayneeseguin/test functiona() 12 $ echo 'function a'
                    function a
            %td.code
              .highlight
                %pre
                  backtrace
                  %span.o ()
                  %span.o {
                  %span.nb set
                  +o xtrace
                  = succeed "_separator" do
                    %span.nb local
                  %span.nv _columns
                  %span.o =
                  = succeed "tput" do
                    %span.k $(
                  cols
                  %span.k )
                  %span.nb printf
                  \-v _separator
                  %span.s1 '%*s'
                  %span.s2 &quot;${_columns:-${COLUMNS:-80}}&quot;
                  %span.nb local
                  %span.nv _message
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_message}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb printf
                  %span.s2 &quot;\n${_message}\n\n&quot;
                  %span.k fi
                  %span.k                   = succeed "_source" do
                    %span.nb local
                  _function _line _index _largest _format _digits _longest
                  %span.k for
                  %span.o ((
                  %span.nv _index
                  = succeed "0" do
                    %span.o =
                  ; _index &lt;
                  %span.k ${#
                  %span.nv FUNCNAME
                  %span.p [@]
                  %span.k }
                  ; _index++
                  %span.o ))
                  %span.k do
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv FUNCNAME
                  %span.p [
                  %span.k ${
                  %span.nv _index
                  %span.k }
                  %span.p ]
                  %span.k }
                  \&gt;
                  %span.k ${#
                  %span.nv _largest
                  %span.k }
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nv _largest
                  %span.o =
                  %span.k ${
                  %span.nv FUNCNAME
                  %span.p [
                  %span.k ${
                  %span.nv _index
                  %span.k }
                  %span.p ]
                  %span.k }
                  %span.k fi
                  %span.k done
                  %span.k for
                  %span.o ((
                  %span.nv _index
                  = succeed "0" do
                    %span.o =
                  ; _index &lt;
                  %span.k ${#
                  %span.nv BASH_SOURCE
                  %span.p [@]
                  %span.k }
                  ; _index++
                  %span.o ))
                  %span.k do
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv BASH_SOURCE
                  %span.p [
                  %span.k ${
                  %span.nv _index
                  %span.k }
                  %span.p ]
                  %span.k }
                  \&gt;
                  %span.k ${#
                  %span.nv _longest
                  %span.k }
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nv _longest
                  %span.o =
                  %span.k ${
                  %span.nv BASH_SOURCE
                  %span.p [
                  %span.k ${
                  %span.nv _index
                  %span.k }
                  %span.p ]
                  %span.k }
                  %span.k fi
                  %span.k done
                  %span.k for
                  %span.o ((
                  %span.nv _index
                  = succeed "0" do
                    %span.o =
                  ; _index &lt;
                  %span.k ${#
                  %span.nv BASH_LINENO
                  %span.p [@]
                  %span.k }
                  ; _index++
                  %span.o ))
                  %span.k do
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv BASH_LINENO
                  %span.p [
                  %span.k ${
                  %span.nv _index
                  %span.k }
                  %span.p ]
                  %span.k }
                  \&gt;
                  %span.k ${#
                  %span.nv _digits
                  %span.k }
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nv _digits
                  %span.o =
                  %span.k ${
                  %span.nv BASH_LINENO
                  %span.p [
                  %span.k ${
                  %span.nv _index
                  %span.k }
                  %span.p ]
                  %span.k }
                  %span.k fi
                  %span.k done
                  %span.k case
                  %span.s2 &quot;${EDITOR:-}&quot;
                  in
                  = succeed "mvim*|mate*" do
                    %span.o (
                  %span.o )
                  %span.c #_format=&quot; %-$((${#_largest} + 2))s %-$((${#EDITOR} + ${#_digits} + 19 + ${#_longest}))s\n&quot;
                  %span.nv _format
                  %span.o =
                  %span.s2 &quot;%-$((${#_largest} + 2))s %-s\n&quot;
                  %span.nb printf
                  %span.s2 &quot;${_format}&quot;
                  %span.s2 &quot;function()&quot;
                  %span.s2 &quot;Source&quot;
                  1&gt;&amp;2
                  ;;
                  = succeed "vi*|gvim*|emacs*|*" do
                    %span.o (
                  %span.o )
                  %span.nv _format
                  %span.o =
                  %span.s2 &quot;%-$((${#_largest} + 2))s $ %${#EDITOR}s +%-$((${#_digits}))s %-$((${#_longest} + 2))s %s\n&quot;
                  %span.nb printf
                  %span.s2 &quot;${_format}&quot;
                  %span.s2 &quot;function()&quot;
                  %span.s1 ' '
                  %span.s2 &quot;#&quot;
                  %span.s2 &quot;source file&quot;
                  1&gt;&amp;2
                  
                  ;;
                  %span.k esac
                  %span.k                   %span.nb printf
                  %span.s2 &quot;${_separator// /=}\n&quot;
                  1&gt;&amp;2
                  %span.k for
                  %span.o ((
                  %span.nv _index
                  = succeed "1" do
                    %span.o =
                  ; _index &lt;
                  %span.k ${#
                  %span.nv FUNCNAME
                  %span.p [@]
                  %span.k }
                  ; ++_index
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv _source
                  %span.o =
                  %span.s2 &quot;${BASH_SOURCE[${_index}]}&quot;
                  %span.nv _function
                  %span.o =
                  %span.s2 &quot;${FUNCNAME[${_index}]:+${FUNCNAME[${_index}]}()}&quot;
                  %span.nv _line
                  %span.o =
                  %span.k ${
                  %span.nv BASH_LINENO
                  %span.p [
                  %span.k $((
                  _index
                  %span.o -
                  %span.m 1
                  %span.k ))
                  %span.p ]
                  %span.k }
                  %span.k case
                  %span.s2 &quot;$_function&quot;
                  in
                  fail
                  %span.se> \(\)
                  |error
                  %span.se> \(\)
                  |command_not_found_handle
                  %span.se> \(\)
                  |command_not_found
                  %span.se \(\)
                  %span.o )
                  %span.k continue
                  ;;
                  %span.k esac
                  %span.k case
                  %span.s2 &quot;${EDITOR:-}&quot;
                  in
                  = succeed "mvim*|mate*" do
                    %span.o (
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;${_format}&quot;
                  %span.s2 &quot;${_function}&quot;
                  %span.s2 &quot;${EDITOR// *}://open?url=file://${_source}&amp;line=${_line}&quot;
                  1&gt;&amp;2
                  ;;
                  = succeed "vi*|gvim*|emacs*|*" do
                    %span.o (
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;${_format}&quot;
                  %span.s2 &quot;${_function}&quot;
                  %span.s2 &quot;${EDITOR}&quot;
                  %span.s2 &quot;${_line}&quot;
                  %span.s2 &quot;${_source} &quot;
                  1&gt;&amp;2
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k                   %span.nb printf
                  %span.s2 &quot;${_separator// /=}\n&quot;
                  1&gt;&amp;2
                  %span.k if
                  %span.o ((
                  trace_flag &gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "enable_trace" do
                    %span.k                   %span.k fi
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2
                user
                %em> create
                if_missing()
              %p Create a system user if it does not exist on the system.
              %h3 Input Parameters
              %p
                The first parameter should be the user name, then optionally
                [with] group {{groupname}}
              %h3 Stream Outputs
              %p What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
              %h3 Environmental effects
              %p What, if any, environmental side effects this function causes. 'None.' for none.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no username is given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ user_create_if_missing "nginx" with group "nginx"
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  user_create_if_missing
                  %span.o ()
                  %span.o {
                  = succeed "_token" do
                    %span.nb local
                  _group
          %tr
            %td.docs
              %p parse arguments
            %td.code
              .highlight
                %pre
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  ;
                  %span.k do
                  %span.k                   %span.nv _token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  ;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${_token}&quot;
                  in
                  group
                  %span.o )
                  %span.nv _group
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  ;
                  %span.nb shift
                  ;;
                  with
                  %span.o )
                  %span.k continue
                  %span.c # Syntatic sugar, ignore, next!
                  ;;
                  from
                  %span.o )
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  ;
                  %span.nb shift
                  ;;
                  \--force
                  %span.o )
                  %span.nv _force_flag
                  = succeed "1" do
                    %span.o =
                  ;;
                  
                  *
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_group}&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  %span.k                   %span.nv _group
                  %span.o =
                  %span.s2 &quot;${_token}&quot;
                  %span.nb break
                  %span.nb                   %span.k fi
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o ((
                  %span.nv UID
                  %span.o ==
                  0
                  %span.o ))
                  ;
                  %span.k then
                  %span.o (
                  %span.k case
                  %span.s2 &quot;$(uname)&quot;
                  in
                  %span.s2 &quot;OpenBSD&quot;
                  %span.o )
                  groupadd
                  %span.s2 &quot;$package_user&quot;
                  useradd -g
                  %span.s2 &quot;$package_user&quot;
                  %span.s2 &quot;$package_user&quot;
                  \-s /bin/bash
                  usermod -s /bin/bash
                  %span.s2 &quot;$package_user&quot;
                  ;;
                  %span.s2 &quot;FreeBSD&quot;
                  %span.o )
                  pw groupadd -q
                  %span.s2 &quot;$package_user&quot;
                  ;;
                  %span.s2 &quot;Linux&quot;
                  %span.o )
          %tr
            %td.docs
              %p
                groupadd nginx
                useradd -G nginx -M nginx
            %td.code
              .highlight
                %pre
                  %span.k if
                  %span.o [[
                  \-f
                  %span.s2 &quot;/etc/SuSE-release&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  = succeed "groupadd" do
                    %span.k                   %span.s2 &quot;$package_user&quot;
                  %span.k else
                  = succeed "groupadd" do
                    %span.k                   \-f
                  %span.s2 &quot;$package_user&quot;
                  %span.k fi
                  = succeed "useradd" do
                    %span.k                   \-g
                  %span.s2 &quot;${package_user}&quot;
                  %span.s2 &quot;${package_user}&quot;
                  usermod -d
                  %span.s2 &quot;${data_path%\/*}&quot;
                  %span.s2 &quot;${package_user}&quot;
                  usermod -s /bin/bash
                  %span.s2 &quot;${package_user}&quot;
                  ;;
                  %span.s2 &quot;Darwin&quot;
                  %span.o )
                  %span.nv current_max_gid
                  %span.o =
                  = succeed "dscl" do
                    %span.k $(
                  \. -list /Groups gid | awk
                  %span.s1 '{print $2}'
                  | sort -g -r | head -1
                  %span.k )
                  %span.nv next_gid
                  %span.o =
                  = succeed "current_max_gid+1" do
                    %span.k $((
                  %span.k ))
                  %span.nv current_max_uid
                  %span.o =
                  = succeed "dscl" do
                    %span.k $(
                  \. -list /Users UniqueID | awk
                  %span.s1 '{print $2}'
                  | sort -g -r | head -1
                  %span.k )
                  %span.nv next_uid
                  %span.o =
                  = succeed "current_max_uid+1" do
                    %span.k $((
                  %span.k ))
                  %span.k if
                  \! dscl . -list /Users | grep -q
                  %span.s2 &quot;^${package_user}$&quot;
                  ;
                  %span.k then
                  = succeed "dscl" do
                    %span.k                   \. -create
                  %span.s2 &quot;/Groups/$package_user&quot;
                  dscl . -create
                  %span.s2 &quot;/Groups/$package_user&quot;
                  gid
                  %span.s2 &quot;$next_gid&quot;
                  dscl . -create
                  %span.s2 &quot;/Users/${package_user}&quot;
                  dscl . -create
                  %span.s2 &quot;/Users/${package_user}&quot;
                  PrimaryGroupID
                  %span.s2 &quot;$gid&quot;
                  %span.c # UserShell /bin/bash
                  dscl . -create
                  %span.s2 &quot;/Users/${package_user}&quot;
                  uid
                  %span.s2 &quot;$next_uid&quot;
                  dscl . -create
                  %span.s2 &quot;/Users/${package_user}&quot;
                  realname
                  %span.s2 &quot;Postgresql User&quot;
                  dscl . -create
                  %span.s2 &quot;/Users/${package_user}&quot;
                  home
                  %span.s2 &quot;${data_path%\/*}&quot;
                  dscl . -create
                  %span.s2 &quot;/Users/${package_user}&quot;
                  shell
                  %span.s2 &quot;/bin/bash&quot;
                  dscl . -create
                  %span.s2 &quot;/Users/${package_user}&quot;
                  gid
                  %span.s2 &quot;$gid&quot;
                  dscl . -create
                  %span.s2 &quot;/Users/${package_user}&quot;
                  passwd
                  %span.s2 &quot;*&quot;
                  %span.k fi
                  ;;
                  %span.s2 &quot;SunOS&quot;
                  %span.o )
                  groupadd
                  %span.s2 &quot;$package_user&quot;
                  useradd -g
                  %span.s2 &quot;$package_user&quot;
                  \-s /bin/bash -d
                  %span.s2 &quot;${data_path}&quot;
                  %span.s2 &quot;$package_user&quot;
                  usermod -s /bin/bash
                  %span.s2 &quot;$package_user&quot;
                  ;;
                  %span.k esac
                  %span.o )
                  %span.o ||
                  %span.nb true
                  %span.c # Ignore failures with this for now...
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Users and groups may be manipulated only by the super user (root) via su or sudo.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 user_delete()
              %p Deletes the named system user.
              %h3 Input Parameters
              %p The first parameter is the system user to delete.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p The given user will no longer exist on the system.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if the user name was not specified.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ user_delete "nginx"
            %td.code
              .highlight
                %pre
                  user_delete
                  %span.o ()
                  %span.o {
                  = succeed "_token" do
                    %span.nb local
                  _group
          %tr
            %td.docs
              %p parse arguments
            %td.code
              .highlight
                %pre
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  ;
                  %span.k do
                  %span.k                   %span.nv _token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  ;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${_token}&quot;
                  in
                  group
                  %span.o )
                  %span.nv _group
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  ;
                  %span.nb shift
                  ;;
                  with
                  %span.o )
                  %span.k continue
                  %span.c # Syntatic sugar, ignore, next!
                  ;;
                  from
                  %span.o )
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  ;
                  %span.nb shift
                  ;;
                  \--force
                  %span.o )
                  %span.nv _force_flag
                  = succeed "1" do
                    %span.o =
                  ;;
                  
                  *
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_group}&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  %span.k                   %span.nv _group
                  %span.o =
                  %span.s2 &quot;${_token}&quot;
                  %span.nb break
                  %span.nb                   %span.k fi
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o ((
                  %span.nv UID
                  %span.o ==
                  0
                  %span.o ))
                  ;
                  %span.k then
                  %span.o (
                  %span.k case
                  %span.s2 &quot;$(uname)&quot;
                  in
                  %span.s2 &quot;OpenBSD&quot;
                  %span.o )
                  groupdel
                  %span.s2 &quot;$package_user&quot;
                  userdel -g
                  %span.s2 &quot;$package_user&quot;
                  %span.s2 &quot;$package_user&quot;
                  ;;
                  %span.s2 &quot;FreeBSD&quot;
                  %span.o )
                  pw groupdel -q
                  %span.s2 &quot;$package_user&quot;
                  ;;
                  %span.s2 &quot;Linux&quot;
                  %span.o )
                  userdel
                  %span.s2 &quot;${package_user}&quot;
                  ;;
                  %span.s2 &quot;Darwin&quot;
                  %span.o )
                  %span.nv gid
                  %span.o =
                  %span.s2 &quot;501&quot;
                  %span.c #only gids &gt; 500 show up in user preferences
                  %span.c #Find an open gid
                  %span.k while
                  = succeed ";" do
                    %span.nb true
                  %span.k do
                  %span.k                   %span.nv name
                  %span.o =
                  = succeed "dscl" do
                    %span.k $(
                  \. search /groups PrimaryGroupID
                  %span.nv $gid
                  | cut -f1 -s
                  %span.k )
                  %span.k if
                  %span.o [
                  \-z
                  %span.s2 &quot;$name&quot;
                  %span.o ]
                  ;
                  %span.k then
                  %span.k                   %span.nb break
                  %span.nb                   %span.k fi
                  %span.k                   %span.nv gid
                  %span.o =
                  %span.nv $[$gid
                  +1
                  %span.o ]
                  %span.k done
                  %span.c #Create the group
                  dscl . -delete
                  %span.s2 &quot;/Users/${package_user}&quot;
                  PrimaryGroupID
                  %span.s2 &quot;$gid&quot;
                  %span.c # UserShell /bin/bash
                  dscl . -delete
                  %span.s2 &quot;/Groups/$package_user&quot;
                  dscl . -delete
                  %span.s2 &quot;/Groups/$package_user&quot;
                  gid
                  %span.s2 &quot;$gid&quot;
                  ;;
                  %span.s2 &quot;SunOS&quot;
                  %span.o )
                  groupdel
                  %span.s2 &quot;$package_user&quot;
                  userdel
                  %span.s2 &quot;$package_user&quot;
                  ;;
                  %span.k esac
                  %span.o )
                  %span.o ||
                  %span.nb true
                  %span.c # Ignore failures with this for now...
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Users and groups may be manipulated only by the super user (root) via su or sudo.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                user
                %em> is
                root()
              %p Tests if the user the current process is running as is root.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if user is root (UID 0).
                1 if user is not root (UID 0).
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ user_is_root
                    user$ echo $?
                    1
                    
                    root# user_is_root
                    root# echo $?
                    0
            %td.code
              .highlight
                %pre
                  user_is_root
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o ((
                  %span.nv UID
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                user
                %em> is
                not_root()
              %p Tests if the user the current process is running as is not root.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if user is not root (eg UID is nonzero)
                1 if user is root (UID 0)
              %h3 Failure Scenarios
              %p No failure scenarios currently
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ user_is_not_root
                    user$ echo $?
                    0
                    
                    root# user_is_not_root
                    root# echo $?
                    1
            %td.code
              .highlight
                %pre
                  user_is_not_root
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o ((
                  UID !
                  %span.o =
                  0
                  %span.o ))
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                user
                %em> must
                be_root()
              %p Halts the calling program with a failure message if the user is not root.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p A failure message is output to STDERR if the failure condition is met.
              %h3 Environmental effects
              %p What, if any, environmental side effects this function causes. 'None.' for none.
              %h3 Return Codes
              %p 0 if the user is root
              %h3 Failure Scenarios
              %p Fails if the program user running is not root.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ user_must_be_root
                    ERROR: bdsm test test must be run as root and NOT as a user(user)
            %td.code
              .highlight
                %pre
                  user_must_be_root
                  %span.o ()
                  %span.o {
                  user_is_root
                  %span.o ||
                  fail
                  %span.s2 &quot;bdsm $extension $action must be run as a root and NOT as a user ($USER).&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                user
                %em> must
                not
                %em> be
                root()
              %p Halts the calling program with a failure message if the user is not root.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p A failure message is output to STDERR if the failure condition is met.
              %h3 Environmental effects
              %p What, if any, environmental side effects this function causes. 'None.' for none.
              %h3 Return Codes
              %p 0 if the user is root
              %h3 Failure Scenarios
              %p Fails if the program user running is root.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ user_must_not_be_root
                    ERROR: bdsm test test must be run as a (project) user and NOT as a root.
            %td.code
              .highlight
                %pre
                  user_must_not_be_root
                  %span.o ()
                  %span.o {
                  user_is_not_root
                  %span.o ||
                  fail
                  %span.s2 &quot;bdsm $extension $action must be run as a (project) user and NOT as root.&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                user
                %em> run
                as()
              %p Runs a command as a given user.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Any stream outputs of the command being run.
              %h3 Environmental effects
              %p Any environmental effects of the command being run.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no user was specified.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    root# user_run_as "user" pwd
                    /home/user
            %td.code
              .highlight
                %pre
                  user_run_as
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _user
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_user:-}&quot;
                  %span.o ]]
                  %span.o ||
                  fail
                  %span.s2 &quot;Cannot run as user as no user or commands were given.&quot;
                  %span.nb shift
                  = succeed "su" do
                    %span.nb                   %span.s2 &quot;${_user}&quot;
                  \-c
                  %span.s2 &quot;$*&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                user
                %em> run
                as_login()
              %p Runs a command as a given user, in that users login shell.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Any stream outputs of the command being run.
              %h3 Environmental effects
              %p Any environmental effects of the command being run.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no user was specified.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    root# user_run_as_login "deploy" bdsm unicorn restart
                    &lt;&lt; unicorn restart output &gt;&gt;
            %td.code
              .highlight
                %pre
                  user_run_as_login
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _user
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_user:-}&quot;
                  %span.o ]]
                  %span.o ||
                  fail
                  %span.s2 &quot;Cannot run as login user as no user or commands were given.&quot;
                  %span.nb shift
                  = succeed "su" do
                    %span.nb                   \-
                  %span.s2 &quot;${_user}&quot;
                  \-c
                  %span.s2 &quot;$*&quot;
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 show_help()
              %p
                Display help for the current extension based on settings declared in the help
                action.
              %h3 Input Parameters
              %p First parameter is the help section to display, default is all sections 'usage'.
              %h3 Stream Outputs
              %p Prints out formatted help sections to the calling environments STDOUT stream.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ show_help usage
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  show_help
                  %span.o ()
                  %span.o {
                  = succeed "_help_command" do
                    %span.nb local
                  _token
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  ;
                  %span.k do
                  %span.k                   %span.nv _token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  ;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${_token}&quot;
                  in
                  desc*|description
                  %span.o )
                  %span.nv _help_command
                  %span.o =
                  %span.s2 &quot;description&quot;
                  ;;
                  actions
                  %span.o )
                  %span.nv _help_command
                  %span.o =
                  %span.s2 &quot;actions&quot;
                  ;;
                  usage
                  %span.o )
                  %span.nv _help_command
                  %span.o =
                  %span.s2 &quot;usage&quot;
                  ;;
                  %span.k esac
                  %span.k done
                  %span.s2 &quot;${_help_command:-usage}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 description()
              %p Set the string that will be printed when the actions help section is output.
              %h3 Input Parameters
              %p First parameter is a string containing a description of the extension.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Fails if no description is given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ description "This extension handles X Y and Z."
            %td.code
              .highlight
                %pre
                  description
                  %span.o ()
                  %span.o {
                  %span.o [[
                  \-n
                  %span.s2 &quot;$*&quot;
                  %span.o ]]
                  %span.o ||
                  fail
                  %span.s2 &quot;Cannot add description to help as no help description was given.&quot;
                  help_descriptions+
                  %span.o =(
                  %span.s2 &quot;$*&quot;
                  %span.o )
                  %span.o }
          %tr
            %td.docs
              %h2 help_description()
              %p Outputs the collected help description.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Prints the help description output.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p None.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ description "This extension handles X Y and Z."
            %td.code
              .highlight
                %pre
                  help_description
                  %span.o ()
                  %span.o {
                  = succeed "_description" do
                    %span.nb local
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv help_descriptions
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "help_section" do
                    %span.k                   %span.s2 &quot;Description&quot;
                  = succeed "_description" do
                    %span.k for
                  in
                  %span.s2 &quot;${help_descriptions[@]}&quot;
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot;  %s\n&quot;
                  %span.s2 &quot;${_description}&quot;
                  %span.k done
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 actions()
              %p Set the string that will be printed when the actions help section is output.
              %h3 Input Parameters
              %p First parameter is a string of the action descriptions.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Fails if no actions are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ actions "install  - Installs the extension..."
            %td.code
              .highlight
                %pre
                  actions
                  %span.o ()
                  %span.o {
                  %span.o [[
                  \-n
                  %span.s2 &quot;$*&quot;
                  %span.o ]]
                  %span.o ||
                  fail
                  %span.s2 &quot;No help actions were given.&quot;
                  warn
                  %span.s2 &quot;help actions() is depreciated, use action() instead for each action.&quot;
                  %span.nv help_actions
                  %span.o =
                  %span.s2 &quot;$*&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 action()
              %p Adds an action definition for help output.
              %h3 Input Parameters
              %p
                First parameter is the name of the extension action
                Second parameter is the description of the extension action
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p The action description will be stored for use on help output.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if an action name is not given.
                Fails if a description is not provided.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ action "install"  "Installs the extension..."
            %td.code
              .highlight
                %pre
                  action
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _name
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.nb local
                  %span.nv _description
                  %span.o =
                  %span.s2 &quot;${2:-}&quot;
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_name}&quot;
                  %span.o &amp;&amp;
                  \-n
                  %span.s2 &quot;${_description}&quot;
                  %span.o ]]
                  %span.o ||
                  fail
                  %span.s2 &quot;An action and a description must be provided:\naction {name} {description}&quot;
                  help_action_names+
                  %span.o =(
                  %span.s2 &quot;${_name}&quot;
                  %span.o )
                  help_action_descriptions+
                  %span.o =(
                  %span.s2 &quot;${_description}&quot;
                  %span.o )
                  %span.o }
          %tr
            %td.docs
              %h2 note()
              %p Adds a note definition for help Notes section.
              %h3 Input Parameters
              %p
                First parameter is a string containing any note for the notes section of
                the current extension's help output.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ note "Help for this extension can be found in #beginrescueend on irc.freenode.net"
            %td.code
              .highlight
                %pre
                  note
                  %span.o ()
                  %span.o {
                  help_notes+
                  %span.o =(
                  %span.s2 &quot;$*&quot;
                  %span.o )
                  %span.o }
          %tr
            %td.docs
              %h2 dependencies()
              %p Specify content for the dependencies section of the help command.
              %h3 Input Parameters
              %p
                First parameter is a string containing any dependencies for the dependencies
                section of the current extension's help output.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ dependencies " * pcre"
            %td.code
              .highlight
                %pre
                  dependencies
                  %span.o ()
                  %span.o {
                  %span.nv help_dependencies
                  %span.o =
                  %span.s2 &quot;$*&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 resource()
              %p Add a resource for the Resources section of the help command.
              %h3 Input Parameters
              %p
                First parameter is a string containing any resources for the resources
                section of the current extension's help output.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ resource "website: ..."
            %td.code
              .highlight
                %pre
                  resource
                  %span.o ()
                  %span.o {
                  help_resources+
                  %span.o =(
                  %span.s2 &quot;$*&quot;
                  %span.o )
                  %span.o }
          %tr
            %td.docs
              %h2 help_actions()
              %p
                Outputs the help actions in a formatted manner.
                Outputs a message if there are no actions.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                Prints a formatted listing of the actions and their descriptions to the
                calling environments STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat $HOME/test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules help
                    
                    action "help" "Displays the help output for the ${extension} extension"
                    action "install" "Installs Z redis package"
                    action "uninstall" "Uninstalls Z redis package"
                    
                    help_actions
                    
                    user$ "$HOME/test"
                    help      - Displays the help output for the redis extension
                    install   - Installs Z redis package
                    uninstall - Uninstalls Z redis package
            %td.code
              .highlight
                %pre
                  help_actions
                  %span.o ()
                  %span.o {
                  = succeed "_largest" do
                    %span.nb local
                  _index
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv help_action_names
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nv _largest
                  %span.o =
                  %span.k $(
                  array_largest help_action_names
                  %span.k )
                  %span.c # Use the array DSL to grab largest
                  %span.nv _largest
                  %span.o =
                  %span.k $((
                  %span.k ${#
                  %span.nv _largest
                  %span.k }
                  %span.o +
                  %span.m 1
                  %span.k ))
                  help_section
                  %span.s2 &quot;Actions&quot;
                  %span.k for
                  %span.o ((
                  %span.nv _index
                  = succeed "0" do
                    %span.o =
                  ; _index &lt;
                  %span.k ${#
                  %span.nv help_action_names
                  %span.p [@]
                  %span.k }
                  ; _index++
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot;  %-$((_largest + 2))s - %s\n&quot;
                  %span.se \
                  %span.s2 &quot;${help_action_names[${_index}]}&quot;
                  %span.s2 &quot;${help_action_descriptions[${_index}]}&quot;
                  %span.k done
                  %span.k else
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;# No help has been defined for ${extension} actions .&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 help_notes()
              %p
                Outputs the help notes in a formatted manner.
                Outputs a message if there are no notes.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Prints a formatted listing of the notes to the calling environments STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat $HOME/test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules help
                    
                    note "Don't forget the milk! "
                    note "... and cookies... mmm...."
                    
                    help_notes
                    
                    user$ "$HOME/test"
                    * Don't forget the milk!
                    * ... and cookies... mmm....
            %td.code
              .highlight
                %pre
                  help_notes
                  %span.o ()
                  %span.o {
                  = succeed "_index" do
                    %span.nb local
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv help_notes
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "help_section" do
                    %span.k                   %span.s2 &quot;Notes&quot;
                  %span.k for
                  %span.o ((
                  %span.nv _index
                  = succeed "0" do
                    %span.o =
                  ; _index &lt;
                  %span.k ${#
                  %span.nv help_notes
                  %span.p [@]
                  %span.k }
                  ; _index++
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot;  * %s\n&quot;
                  %span.s2 &quot;${help_notes[${_index}]}&quot;
                  %span.k done
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 help_dependencies()
              %p Outputs the help dependencies in a formatted manner.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                Prints a formatted listing of the current extensions defined dependencies to
                the calling environments STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
            %td.code
              .highlight
                %pre
                  help_dependencies
                  %span.o ()
                  %span.o {
                  = succeed "_index" do
                    %span.nb local
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv help_dependencies
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "help_section" do
                    %span.k                   %span.s2 &quot;Dependencies&quot;
                  %span.k for
                  %span.o ((
                  %span.nv _index
                  = succeed "0" do
                    %span.o =
                  ; _index &lt;
                  %span.k ${#
                  %span.nv help_dependencies
                  %span.p [@]
                  %span.k }
                  ; _index++
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot; * %s\n&quot;
                  %span.s2 &quot;${help_dependencies[${_index}]}&quot;
                  %span.k done
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 help_resources()
              %p
                Outputs the help notes in a formatted manner.
                Outputs a message if there are no notes.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                Prints a formatted listing of the defined resources to the calling
                environments STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
            %td.code
              .highlight
                %pre
                  help_resources
                  %span.o ()
                  %span.o {
                  = succeed "_index" do
                    %span.nb local
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv help_resources
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "help_section" do
                    %span.k                   %span.s2 &quot;Resources&quot;
                  %span.k for
                  %span.o ((
                  %span.nv _index
                  = succeed "0" do
                    %span.o =
                  ; _index &lt;
                  %span.k ${#
                  %span.nv help_resources
                  %span.p [@]
                  %span.k }
                  ; _index++
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot; * %s\n&quot;
                  %span.s2 &quot;${help_resources[${_index}]}&quot;
                  %span.k done
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 help_section()
              %p Displays a help section header.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Prints the given string as a help section header.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ help_section Usage
            %td.code
              .highlight
                %pre
                  help_section
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;\n$*\n&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 help_usage()
              %p Display the CLI signature.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Prints the CLI command signature.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ help_usage
                    bdsm core {action} [arguments...]
            %td.code
              .highlight
                %pre
                  help_usage
                  %span.o ()
                  %span.o {
                  help_section
                  %span.s2 &quot;Usage&quot;
                  log
                  %span.s2 &quot;  bdsm ${extension} {action} [arguments...]&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 usage()
              %p Display the usage help output of the command. This displays all help sections.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Prints all help sections to the STDOUT of the calling environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ usage
            %td.code
              .highlight
                %pre
                  usage
                  %span.o ()
                  %span.o {
                  bdsm_version
                  
                  log
                  %span.s2 &quot;\nbdsm ${bdsm_version} https://bdsm.beginrescueend.com/ by Wayne E. Seguin (wayneeseguin@gmail.com)&quot;
                  %span.nv sections
                  = succeed "usage" do
                    %span.o =(
                  description actions notes dependencies resources
                  %span.o )
                  = succeed "section" do
                    %span.k for
                  in
                  %span.s2 &quot;${sections[@]}&quot;
                  %span.k do
                  %span.s2 &quot;help_${section}&quot;
                  %span.k done
                  %span.k case
                  %span.s2 &quot;${extension}&quot;
                  in
                  ext|extension|extend
                  %span.o )
                  help_section
                  %span.s2 &quot;Installed Extensions&quot;
                  %span.nb printf
                  %span.s2 &quot;  &quot;
                  extensions_installed
                  %span.nb echo
                  = succeed "help_section" do
                    %span.nb                   %span.s2 &quot;Available Extensions&quot;
                  %span.nb printf
                  %span.s2 &quot;  &quot;
                  extensions_available
                  %span.nb echo
                  ;;
                  %span.k esac
                  %span.k                   %span.nb echo
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 modules()
              %p Loads named BDSM modules into the calling environment.
              %h3 Input Parameters
              %p Positional Parameter listing and descriptions.
              %h3 Stream Outputs
              %p None, unless loading the module causes output to a stream.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no module names were given as parameters.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ modules array system
                    user$ modules_loaded
                    logging trace filesystem array system
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  modules
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o ((
                  trace_flag &lt; 2
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nb set
                  +o xtrace
                  %span.k fi
                  %span.k                   = succeed "_module" do
                    %span.nb local
                  _bdsm _extension _path _file
                  %span.nv _modules
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _modules
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;No modules specified to load.&quot;
                  %span.k fi
                  = succeed "_module" do
                    %span.k for
                  in
                  %span.s2 &quot;${_modules[@]}&quot;
                  %span.k do
                  = succeed "module_is_loaded" do
                    %span.k if
                  %span.s2 &quot;${_module}&quot;
                  %span.k then
                  %span.k continue
                  %span.c # The module has already been loaded, continue to the next one.
                  %span.k else
                  %span.k                   %span.nv _bdsm
                  %span.o =
                  %span.s2 &quot;${modules_path}/bash/${_module}&quot;
                  %span.nv _extension
                  %span.o =
                  %span.s2 &quot;${extension_modules_path}/bash/${_module}&quot;
                  = succeed "_path" do
                    %span.k for
                  in
                  %span.s2 &quot;${_bdsm}&quot;
                  %span.s2 &quot;${_extension}&quot;
                  %span.k do
                  = succeed "_file" do
                    %span.k for
                  in dsl initialize
                  %span.k do
                  %span.k if
                  %span.o [[
                  \-s
                  %span.s2 &quot;${_path}/${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb source
                  %span.s2 &quot;${_path}/${_file}&quot;
                  %span.k fi
                  %span.k done
                  %span.k done
                  = succeed "modules+" do
                    %span.k                   %span.o =(
                  %span.s2 &quot;${_module}&quot;
                  %span.o )
                  %span.k fi
                  %span.k done
                  %span.k if
                  %span.o ((
                  trace_flag &gt; 0
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nb set
                  \-o xtrace
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 module_load()
              %p Function Description
              %h3 Input Parameters
              %p Positional Parameter listing and descriptions.
              %h3 Stream Outputs
              %p None, unless loading the module causes output to a stream.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no extension module files names have been given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ ls ${extension_modules_path}/bash/
                    cli dsl initialize zebra
                    
                    user$ cat ${extension_modules_path}/bash/zebra
                    #!/usr/bin/env bash
                    echo "Zebra!!! "
                    
                    user$ module_load zebra # This will load zebra into the current context
                    Zebra!!!
            %td.code
              .highlight
                %pre
                  module_load
                  %span.o ()
                  %span.o {
                  = succeed "_file" do
                    %span.nb local
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot load a module as no module was given.&quot;
                  %span.k fi
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  = succeed "source_files" do
                    %span.k                   %span.s2 &quot;${extension_modules_path:-&quot;
                  %span.nv $modules_path
                  %span.s2 &quot;}/bash/${_file}&quot;
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2
                module
                %em> is
                loaded()
              %p Checks to see whether or not the named module has been loaded or not.
              %h3 Input Parameters
              %p First parameter is a module name.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p
                0 if the module has already been loaded
                1 if the module has not already been loaded
              %h3 Failure Scenarios
              %p Fails if no module name was given as the first parameter.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ module_is_loaded package
                    user$ echo $?
                    1
                    user$ modules package
                    user$ module_is_loaded package
                    0
            %td.code
              .highlight
                %pre
                  module_is_loaded
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _name
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_name}&quot;
                  %span.o ]]
                  %span.o ||
                  fail
                  %span.s2 &quot;Cannot determine if a module is loaded as no module was given.&quot;
                  %span.k case
                  %span.s2 &quot; ${modules[@]} &quot;
                  in
                  = succeed "*" do
                    %span.o (
                  = succeed ":space:" do
                    %span.o [[
                  %span.o ]]
                  %span.k ${
                  %span.nv _name
                  %span.k }
                  = succeed ":space:" do
                    %span.o [[
                  = succeed "*" do
                    %span.o ]]
                  %span.o )
                  = succeed "0" do
                    %span.k return
                  ;;
                  = succeed "*" do
                    %span.o (
                  %span.o )
                  = succeed "1" do
                    %span.k return
                  ;;
                  %span.k esac
                  %span.o }
          %tr
            %td.docs
              %h2 modules_loaded()
              %p Outputs a list of all modules that have been loaded.
              %h3 Input Parameters
              %p Positional Parameter listing and descriptions.
              %h3 Stream Outputs
              %p
                Prints a space separated list of all loaded modules to the STDOUT stream of
                the calling environment.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ modules_loaded
                    logging trace filesystem
            %td.code
              .highlight
                %pre
                  modules_loaded
                  %span.o ()
                  %span.o {
                  %span.nb printf
                  %span.s2 &quot;${modules[@]}\n&quot;
                  %span.o }
          %tr
            %td.docs
              %p Print out a list of all installed modules.
            %td.code
              .highlight
                %pre
                  modules_installed
                  %span.o ()
                  %span.o {
                  = succeed "_module" do
                    %span.nb local
                  %span.nb local
                  %span.nv _module_type
                  %span.o =
                  = succeed "bash" do
                    %span.s2 &quot;${1:-&quot;
                  %span.s2 &quot;}&quot;
                  %span.nb local
                  %span.nv _modules
                  %span.o =(
                  = succeed "find" do
                    %span.k $(
                  %span.s2 &quot;${modules_path}/${_module_type}&quot;
                  \-mindepth 1 -maxdepth 1 -type d | sed -e
                  %span.s1 's#.*/##g'
                  \-e
                  %span.s1 '/\..*/d'
                  %span.k )
                  %span.o )
                  = succeed "_module" do
                    %span.k for
                  in
                  %span.k ${
                  %span.nv _modules
                  %span.p [@]
                  %span.k }
                  ;
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot;%s\n&quot;
                  %span.s2 &quot;${_module}&quot;
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 module_dsl()
              %p Print out a list of all dsl for the given module.
              %h3 Input Parameters
              %p First parameter is the module name to print out the dsl for.
              %h3 Stream Outputs
              %p
                The named module's DSL function listing will is printed to the calling
                environments STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no module name was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ module_dsl defaults
                    read_default()
            %td.code
              .highlight
                %pre
                  module_dsl
                  %span.o ()
                  %span.o {
                  = succeed "_function" do
                    %span.nb local
                  _dsl
                  %span.nv _modules
                  %span.o =
                  %span.s2 &quot;${@:-}&quot;
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _modules
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot print the DSL for module(s) as no module names were given.&quot;
                  %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${modules_path}/bash/${_module}&quot;
                  %span.nv _dsl
                  %span.o =(
                  = succeed "find" do
                    %span.k $(
                  %span.s2 &quot;${_path}&quot;
                  \-mindepth 1 -maxdepth 1 -name dsl -type f -print0 | xargs -0 grep
                  %span.s1 '^[a-z_]*()$'
                  2&gt;/dev/null
                  %span.o ||
                  %span.nb true
                  %span.k )
                  %span.o )
                  = succeed "_function" do
                    %span.k for
                  in
                  %span.s2 &quot;${_dsl[@]}&quot;
                  %span.k do
                  %span.k                   %span.nv _function
                  %span.o =
                  %span.s2 &quot;${_function##*modules\/bash\/}&quot;
                  %span.nb printf
                  %span.s2 &quot;%s\n&quot;
                  %span.s2 &quot;${_function//*:}&quot;
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 modules_list()
              %p Lists dsl for all modules.
              %h3 Input Parameters
              %p First parameter is the module name to print out the dsl for.
              %h3 Stream Outputs
              %p
                DSL function listing for each module is printed to the STDOUT of the calling
                environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ modules_list
                    array
                    
                      array_is_nonempty()
                      array_length()
                      array_last_element()
                      array_first_element()
                      array_push()
                      array_append()
                      array_shift()
                      array_unshift()
                      array_join()
                    ... longish output ...
            %td.code
              .highlight
                %pre
                  modules_list
                  %span.o ()
                  %span.o {
                  = succeed "_module" do
                    %span.nb local
                  _modules _function _dsl
                  = succeed "language" do
                    %span.k for
                  in bash ruby
                  %span.k do
                  %span.k                   %span.nv _modules
                  %span.o =(
                  = succeed "modules_installed" do
                    %span.k $(
                  %span.k ${
                  %span.nv language
                  %span.k })
                  %span.o )
                  = succeed "_module" do
                    %span.k for
                  in
                  %span.s2 &quot;${_modules[@]}&quot;
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot;\n%s\n\n&quot;
                  %span.s2 &quot;${_module}&quot;
                  %span.nv _dsl
                  %span.o =(
                  = succeed "module_dsl" do
                    %span.k $(
                  %span.s2 &quot;${_module}&quot;
                  %span.k )
                  %span.o )
                  = succeed "_function" do
                    %span.k for
                  in
                  %span.s2 &quot;${_dsl[@]}&quot;
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot;%s\n&quot;
                  %span.s2 &quot;  ${_function}&quot;
                  %span.k done
                  %span.k done
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 modules_docs()
              %p Output the module DSL documentation for a given module name.
              %h3 Input Parameters
              %p First parameter is the module name to print out the dsl documentation for.
              %h3 Stream Outputs
              %p DSL documentation for every function of the named module.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no module name is given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ module_docs defaults
                    
                    # read_default
                    
                    Reads default values from an extension's config/defaults file.
                    
                    ### Input Parameters
                    
                    First parameter is the defaults file key to read (key=value).
                    Second parameter is the variable name to store the retrieved value in.
                    Remaining parameters are parsed out as token, value and prefix
                      into|as &lt;variable name&gt;
                      prefix &lt;name&gt;
                      &lt;variable&gt; # If no specifier.
                    
                    ### Stream Outputs
                    
                    None.
                    
                    ### Environmental effects
                    
                    A variable will be set to the value, if the value is nonempty. If no variable
                    name is specified the variable will be assigned the same name as the key.
                    
                    ### Return Codes
                    
                    0 for success.
                    
                    ### Failure Scenarios
                    
                    Fails if no arguments are passed in, at least need to specify a key.
                    
                    ### Usage Examples
                    
                        user$ read_default "version" prefix "package" # extension is nginx for example
                        user$ echo $package_version
                        1.0.0
            %td.code
              .highlight
                %pre
                  module_docs
                  %span.o ()
                  %span.o {
                  = succeed "_function" do
                    %span.nb local
                  _dsl _module content_flag table_flag
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${token}&quot;
                  in
                  \--content
                  %span.o )
                  %span.nv content_flag
                  = succeed "1" do
                    %span.o =
                  ;;
                  \--table
                  %span.o )
                  %span.nv table_flag
                  = succeed "1" do
                    %span.o =
                  ;;
                  *
                  %span.o )
                  %span.nv _module
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_module}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${core_development_path}/modules/bash/${_module}&quot;
                  %span.k if
                  %span.o ((
                  %span.nv content_flag
                  %span.o ==
                  1
                  %span.o ))
                  %span.k then
                  = succeed "shocco" do
                    %span.k                   %span.s2 &quot;${_path}/dsl&quot;
                  | awk
                  %span.s1 '/&lt;body&gt;/{p=1;next;} /\/body&gt;/{p=0;next;} {if (p == 1) print ; } '
                  %span.k elif
                  %span.o ((
                  %span.nv table_flag
                  %span.o ==
                  1
                  %span.o ))
                  %span.k then
                  = succeed "shocco" do
                    %span.k                   %span.s2 &quot;${_path}/dsl&quot;
                  | awk
                  %span.s1 '/&lt;table/{p=1;} {if (p == 1) print ; } /\/table&gt;/{p=0;} '
                  %span.k else
                  = succeed "shocco" do
                    %span.k                   %span.s2 &quot;${_path}/dsl&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot glean documentation for a module as no module name was given&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 modules_docgen()
              %p Lists dsl for all modules.
              %h3 Input Parameters
              %p First parameter is the module name to print out the dsl for.
              %h3 Stream Outputs
              %p
                DSL function listing for each module is printed to the STDOUT of the calling
                environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ modules_list
                    array
                    
                      array_is_nonempty()
                      array_length()
                      array_last_element()
                      array_first_element()
                      array_push()
                      array_append()
                      array_shift()
                      array_unshift()
                      array_join()
                    ... longish output ...
            %td.code
              .highlight
                %pre
                  modules_docgen
                  %span.o ()
                  %span.o {
          %tr
            %td.docs
              %p
                TODO: Replace with,
                for file in modules/bash/
                %em> /dsl ; do (name=${file%%\/dsl}; shocco $file > html/${name//
                \\/}.html)&amp; done ; wait
            %td.code
              .highlight
                %pre
                  %span.nb> local
                  _module _modules _function _dsl
                  %span.nb local
                  %span.nv _prefix
                  %span.o =
                  %span.s2 &quot;${core_development_path}/html&quot;
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${site_development_path}&quot;
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${core_development_path}&quot;
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;  &lt;ul&gt;&quot;
                  \&gt;
                  %span.s2 &quot;${_prefix}/index.html&quot;
                  %span.nv _modules
                  %span.o =(
                  %span.k $(
                  find
                  %span.s2 &quot;${core_development_path}/modules/bash&quot;
                  \-mindepth 1 -maxdepth 1
                  %span.se \
                  \-type d | sed -e
                  %span.s1 's#.*/##g'
                  \-e
                  %span.s1 '/\..*/d'
                  %span.k )
                  %span.o )
                  = succeed "_module" do
                    %span.k for
                  in
                  %span.s2 &quot;${_modules[@]}&quot;
                  %span.k do
                  %span.o (
                  ensure_paths_exist
                  %span.s2 &quot;${_prefix}/${_module}&quot;
                  %span.nv _base
                  %span.o =
                  %span.s2 &quot;${_prefix}/${_module}/index&quot;
                  log
                  %span.s2 &quot;Generating ${_base}.html&quot;
                  module_docs
                  %span.s2 &quot;${_module}&quot;
                  \&gt;
                  %span.s2 &quot;${_base}.html&quot;
                  html2haml
                  %span.s2 &quot;${_base}.html&quot;
                  %span.se \
                  \&gt;&gt;
                  %span.s2 &quot;${site_development_path}/content/modules/bash/${name}/dsl.haml&quot;
                  log
                  %span.s2 &quot;&lt;li&gt;&lt;a href=\&quot;/${_module}/${_module}.html\&quot;&gt;${_module}&lt;/a&gt;&lt;/li&gt;&quot;
                  %span.se \
                  \&gt;&gt;
                  %span.s2 &quot;${_prefix}/index.html&quot;
                  = succeed "&amp;amp;" do
                    %span.o )
                  %span.k done
                  %span.k                   %span.nb wait
                  = succeed "log" do
                    %span.nb                   %span.s2 &quot;  &lt;/ul&gt;&quot;
                  \&gt;&gt;
                  %span.s2 &quot;${_prefix}/index.html&quot;
                  log
                  %span.s2 &quot;Modules documentation content has been generated in ${_prefix}.&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Set core_development_path in ~/.bdsmrc in order to run docgen.&quot;
                  %span.k fi
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${site_development_path}&quot;
                  %span.k then
          %tr
            %td.docs
              %p Copy the generated files into the proper site content dir.
            %td.code
              .highlight
                %pre
                  %span.nv files
                  %span.o =(
                  = succeed "find" do
                    %span.k $(
                  %span.s2 &quot;${_prefix}&quot;
                  \-mindepth 1 -iname
                  %span.s1 '*.haml'
                  %span.k )
                  %span.o )
                  = succeed "file" do
                    %span.k for
                  in
                  %span.s2 &quot;${files[@]}&quot;
                  %span.k do
                  %span.o (
                  %span.nv name
                  %span.o =
                  %span.k ${
                  %span.nv file
                  %span.p ##*\/
                  %span.k }
                  %span.nv name
                  %span.o =
                  %span.k ${
                  %span.nv name
                  %span.p %.haml
                  %span.k }
                  ensure_paths_exist
                  %span.s2 &quot;${site_development_path}/content/modules/bash/${name}&quot;
                  log
                  %span.s2 &quot;Building ${name} dsl from generated docs.&quot;
                  cat &gt;
                  %span.s2 &quot;${site_development_path}/content/modules/bash/${name}/dsl.haml&quot;
                  %span.s &lt;&lt;Header
                  %span.s .breadcrumbs
                  %span.s %a{ :href =&gt; &quot;/&quot; }
                  %span.s Documentation
                  %span.s &amp;nbsp;&gt;&amp;nbsp;
                  %span.s %a{ :href =&gt; &quot;/modules/&quot; }
                  %span.s Modules
                  %span.s &amp;nbsp;&gt;&amp;nbsp;
                  %span.s %a{ :href =&gt; &quot;/modules/bash/&quot; }
                  %span.s Bash
                  %span.s &amp;nbsp;&gt;&amp;nbsp;
                  %span.s %a{ :href =&gt; &quot;/modules/bash/${name}/&quot; }
                  %span.s ${name}
                  %span.s &amp;nbsp;&gt;&amp;nbsp;
                  %span.s %a{ :href =&gt; &quot;/modules/bash/${name}/dsl/&quot; }
                  %span.s DSL API :: ${name}
                  %span.s %hr
                  %span.s %h1
                  %span.s Module ${name}
                  %span.s Header
                  cat
                  %span.nv $file
                  \&gt;&gt;
                  %span.s2 &quot;${site_development_path}/content/modules/bash/${name}/dsl.haml&quot;
                  = succeed "&amp;amp;" do
                    %span.o )
                  %span.k done
                  %span.k                   %span.nb wait
                  = succeed "log" do
                    %span.nb                   %span.s2 &quot;Module documentation has been generated from the source code path ${core_development_path} into the site development path ${site_development_path}&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Set site_development_path in ~/.bdsmrc in order to run docgen.&quot;
                  %span.k fi
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2
                init
                %em> scripts
                path()
              %p Returns the system init scripts path (eg. /etc/init.d /etc/rc.d)
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p The system init scripts path is printed to the calling environments STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Fails the OS is not of a (yet) recognized type.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user@archlinux$ init_scripts_path
                    /etc/rc.d
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  init_scripts_path
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o ((
                  %span.nv UID
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  %span.k case
                  %span.s2 &quot;$MACHTYPE&quot;
                  in
                  *darwin*
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;/etc/init.d&quot;
                  %span.c # Service module will create and use this.
                  ;;
                  
                  *linux-gnu*|*
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;/etc/init.d&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb printf
                  %span.s2 &quot;/etc/init.d&quot;
                  %span.k elif
                  %span.o [[
                  \-d
                  %span.s2 &quot;/etc/rc.d&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb printf
                  %span.s2 &quot;/etc/rc.d&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Unknown init scripts directory (/etc/init.d or /etc/rc.d not found).&quot;
                  %span.k fi
                  ;;
                  %span.k esac
                  %span.k else
                  %span.k                   %span.nb printf
                  %span.s2 &quot;$HOME/.init.d&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 confd_path()
              %p Return the system conf.d path.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Prints the conf.d path for the current system and user.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    root# confd_path
                    /etc/conf.d
            %td.code
              .highlight
                %pre
                  confd_path
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o ((
                  %span.nv UID
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nb printf
                  %span.s2 &quot;/etc/conf.d&quot;
                  %span.k else
                  %span.k                   %span.nb printf
                  %span.s2 &quot;$HOME/.conf.d&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                os
                %em> is
                linux()
              %p Tests if the operating system the process is running on is Linux.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the operating system is linux
                1 if the operating system is not linux
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    root@archlinux# os_is_linux
                    root@archlinux# echo $?
                    0
            %td.code
              .highlight
                %pre
                  os_is_linux
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;$MACHTYPE&quot;
                  %span.o =
                  *linux*
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                os
                %em> is
                darwin()
              %p Tests if the operating system the process is running on is darwin.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the operating system is darwin
                1 if the operating system is not darwin
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user@OSX# os_is_darwin
                    user@OSX# echo $?
                    0
            %td.code
              .highlight
                %pre
                  os_is_darwin
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;$MACHTYPE&quot;
                  %span.o =
                  *darwin*
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                os
                %em> is
                bsd()
              %p Tests if the operating system the process is running on is bsd.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the operating system is bsd
                1 if the operating system is not bsd
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    root@bsd# os_is_bsd
                    root@bsd# echo $?
                    0
            %td.code
              .highlight
                %pre
                  os_is_bsd
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;$MACHTYPE&quot;
                  %span.o =
                  *bsd*
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                os
                %em> is
                solaris()
              %p Tests if the operating system the process is running on is solaris.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the operating system is linux
                1 if the operating system is not linux
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    root@linux# os_is_linux
                    root@linux# echo $?
                    0
            %td.code
              .highlight
                %pre
                  os_is_solaris
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;$MACHTYPE&quot;
                  %span.o =
                  *solaris*
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                os
                %em> is
                aix()
              %p Tests if the operating system the process is running on is aix.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the operating system is aix
                1 if the operating system is not aix
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    root@aix# os_is_aix
                    root@aix# echo $?
                    0
            %td.code
              .highlight
                %pre
                  os_is_aix
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;$MACHTYPE&quot;
                  %span.o =
                  *aix*
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 os_type()
              %p Prints out the operating system category / type.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Prints the OS category/type to the calling environments STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    root@archlinux# os_type
                    linux
                    
                    user@osx# os_type
                    darwin
            %td.code
              .highlight
                %pre
                  os_type
                  %span.o ()
                  %span.o {
                  %span.k case
                  %span.s2 &quot;$MACHTYPE&quot;
                  in
                  = succeed "*linux*" do
                    %span.o (
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;linux&quot;
                  ;;
                  = succeed "*darwin*" do
                    %span.o (
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;darwin&quot;
                  ;;
                  = succeed "*bsd*" do
                    %span.o (
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;bsd&quot;
                  ;;
                  = succeed "*solaris*" do
                    %span.o (
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;solaris&quot;
                  ;;
                  = succeed "*aix*" do
                    %span.o (
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;aix&quot;
                  ;;
                  = succeed "*" do
                    %span.o (
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;$MACHTYPE&quot;
                  ;;
                  %span.k esac
                  %span.o }
          %tr
            %td.docs
              %h2
                os
                %em> arch
                type()
              %p Prints out the OS Arch type.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                Prints out the architecture type string of the system that is running the
                current process.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ os_arch_type
                    x86_64
            %td.code
              .highlight
                %pre
                  os_arch_type
                  %span.o ()
                  %span.o {
                  %span.k case
                  %span.s2 &quot;${MACHTYPE//-*}&quot;
                  in
                  = succeed "i386|i686|i86pc" do
                    %span.o (
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;i386&quot;
                  ;;
                  = succeed "*x86_64*" do
                    %span.o (
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;x86_64&quot;
                  ;;
                  = succeed "*ppc*" do
                    %span.o (
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;ppc&quot;
                  ;;
                  %span.k esac
                  %span.o }
          %tr
            %td.docs
              %h2 os_arch()
              %p Prints out the full OS machine type string.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Print the OS machine type string to STDOUT of the calling environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user@OSX# os_arch
                    i386-apple-darwin10.7.0
            %td.code
              .highlight
                %pre
                  os_arch
                  %span.o ()
                  %span.o {
                  %span.nb printf
                  %span.s1 '%s'
                  %span.s2 &quot;${MACHTYPE//-*}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                os
                %em> arch
                capable()
              %p Tests if the operating system the process is running on is Linux.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the operating system is linux
                1 if the operating system is not linux
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user@OSX$ os_arch_capable
                    x86_64
            %td.code
              .highlight
                %pre
                  os_arch_capable
                  %span.o ()
                  %span.o {
                  = succeed "os_is_darwin" do
                    %span.k if
                  %span.k then
                  %span.k                   = succeed "_string" do
                    %span.nb local
                  %span.nb read
                  \-r _string &lt; &lt;
                  %span.o> (
                  sysctl hw.cpu64bit_capable
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${
                  %span.nv _string
                  %span.p //*
                  %span.k }
                  %span.o ==
                  1
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;x86_64&quot;
                  %span.k else
                  = succeed "os_arch_type" do
                    %span.k                   %span.c # Either i386 or ppc
                  %span.k fi
                  %span.k else
                  = succeed "os_arch_type" do
                    %span.k                   %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                os
                %em> cpu
                count()
              %p Print the number of cpu cores on the current system to STDOUT
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p An integer representing the number of CPU cores or 1 if unknown.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ os_cpu_count
                    24
            %td.code
              .highlight
                %pre
                  os_cpu_count
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _count
                  = succeed "1" do
                    %span.o =
                  %span.c # Defaulting to 1.
                  = succeed "os_is_darwin" do
                    %span.k if
                  %span.k then
                  %span.k                   %span.nb read
                  \-r _count &lt; &lt;
                  %span.o> (
                  sysctl hw.ncpu
                  %span.o )
                  %span.nv _count
                  %span.o =
                  %span.s2 &quot;${_count//* }&quot;
                  = succeed "os_is_linux" do
                    %span.k elif
                  %span.k then
                  %span.k                   %span.nv _count
                  %span.o =
                  = succeed "awk" do
                    %span.k $(
                  %span.s1 '/^processor/{count++} END{print count}'
                  \/proc/cpuinfo 2&gt;&amp;1
                  %span.k )
                  %span.k fi
                  %span.k                   %span.nb printf
                  %span.s1 '%d'
                  %span.k ${
                  %span.nv _count
                  %span.k }
                  %span.o }
          %tr
            %td.docs
              %h2 os_version()
              %p Prints the OS version to STDOUT and sets the 'os_version' variable
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p The OS (Kernel) Version is printed to STDOUT.
              %h3 Environmental effects
              %p
                After running this function the os version is stored in the 'os_version'
                variable.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user@archlinux$ os_version
                    2.6.38
                    
                    user@osx$ os_version
                    10.7.0
            %td.code
              .highlight
                %pre
                  os_version
                  %span.o ()
                  %span.o {
                  %span.nb read
                  \-r os_version &lt; &lt;
                  %span.o> (
                  uname -r
                  %span.o )
                  %span.nv os_version
                  %span.o =
                  %span.k ${
                  %span.nv os_version
                  %span.p //-*
                  %span.k }
                  %span.nb printf
                  %span.s1 '%s'
                  %span.s2 &quot;${os_version}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                os
                %em> version
                major()
              %p
                Prints the OS major version to STDOUT and sets the 'os
                %em> version
                major' variable
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p The OS Major Version is printed to STDOUT.
              %h3 Environmental effects
              %p
                After running this function the os major version is stored in the
                'os
                %em> version
                major' variable.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user@archlinux$ os_version
                    2.6.38
                    
                    user@osx$ os_version_major
                    2
            %td.code
              .highlight
                %pre
                  os_version_major
                  %span.o ()
                  %span.o {
                  %span.nv os_version_major
                  %span.o =
                  = succeed "os_version" do
                    %span.k $(
                  %span.k )
                  %span.nv os_version_major
                  %span.o =
                  %span.s2 &quot;${os_version_major//\.*}&quot;
                  %span.nb printf
                  %span.s2 &quot;${os_version_major}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                os
                %em> version
                minor()
              %p
                Prints the OS minor version to STDOUT and sets the 'os
                %em> version
                minor' variable
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p The OS minor Version is printed to STDOUT.
              %h3 Environmental effects
              %p
                After running this function the os minor version is stored in the
                'os
                %em> version
                minor' variable.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user@archlinux$ os_version
                    2.6.38
                    
                    user@osx$ os_version_minor
                    6
            %td.code
              .highlight
                %pre
                  os_version_minor
                  %span.o ()
                  %span.o {
                  %span.nv os_version_minor
                  %span.o =
                  = succeed "os_version" do
                    %span.k $(
                  %span.k )
                  %span.nv os_version_minor
                  %span.o =
                  %span.s2 &quot;${os_version_minor#*\.}&quot;
                  %span.nv os_version_minor
                  %span.o =
                  %span.s2 &quot;${os_version_minor%\.*}&quot;
                  %span.nb printf
                  %span.s2 &quot;${os_version_minor}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                os
                %em> version
                patch()
              %p
                Prints the OS patch version to STDOUT and sets the 'os
                %em> version
                patch' variable
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p The OS patch Version is printed to STDOUT.
              %h3 Environmental effects
              %p
                After running this function the os patch version is stored in the
                'os
                %em> version
                patch' variable.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user@archlinux$ os_version
                    2.6.38
                    
                    user@osx$ os_version_patch
                    38
            %td.code
              .highlight
                %pre
                  os_version_patch
                  %span.o ()
                  %span.o {
                  %span.nv os_version_patch
                  %span.o =
                  = succeed "os_version" do
                    %span.k $(
                  %span.k )
                  %span.nv os_version_patch
                  %span.o =
                  %span.s2 &quot;${os_version_patch//*\.}&quot;
                  %span.nb printf
                  %span.s2 &quot;${os_version_patch}&quot;
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h1 Array Module
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
          %tr
            %td.docs
              %h2
                array
                %em> is
                nonempty()
              %p
                Checks to see if an array with the name given as the first parameter
                is nonempty.
              %h3 Input Parameters
              %p The first parameter is the name of the array variable.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p
                0 if the array is non-empty.
                1 if the array is empty.
              %h3 Failure Scenarios
              %p Fails if the array name, the first parameter, is not given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ the_array=(1 2 3 4 5)
                    user$ array_is_nonempty the_array
                    user$ echo $?
                    0
                    
                    user$ the_array=()
                    user$ array_is_nonempty the_array
                    user$ echo $?
                    1
            %td.code
              .highlight
                %pre
                  array_is_nonempty
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb eval
                  %span.s2 &quot;(( \${#${_array_name}[@]} &gt; 0 ))&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot push onto array as an array name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                array
                %em> is
                empty()
              %p Checks to see if an array with the name given as the first parameter is empty.
              %h3 Input Parameters
              %p The first parameter is the name of the array variable.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p
                0 if the array is empty.
                1 if the array is non-empty.
              %h3 Failure Scenarios
              %p Fails if the array name, the first parameter, is not given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ the_array=()
                    user$ array_is_empty the_array
                    user$ echo $?
                    0
                    
                    user$ the_array=(1 2 3 4 5)
                    user$ array_is_empty the_array
                    user$ echo $?
                    1
            %td.code
              .highlight
                %pre
                  array_is_empty
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb eval
                  %span.s2 &quot;(( \${#${_array_name}[@]} == 0 ))&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot push onto array as an array name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 array_length()
              %p Return the length of the given array.
              %h3 Input Parameters
              %p First parameter is the name of the array variable.
              %h3 Stream Outputs
              %p
                Prints the length of the named array to the STDOUT stream of the calling
                environment.
              %h3 Return Codes
              %p returns 0
              %h3 Failure Scenarios
              %p Fails if the array name, first parameter, is not given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ the_array=(1 2 3 4 5)
                    user$ array_length the_array
                    5
            %td.code
              .highlight
                %pre
                  array_length
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb eval
                  %span.s2 &quot;printf \&quot;%s\\n\&quot; \&quot;\${#${_array_name}[@]}\&quot;&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot push onto array as an array name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                array
                %em> last
                element()
              %p Print the last element of the given array.
              %h3 Input Parameters
              %p First parameter is the name of the array variable.
              %h3 Stream Outputs
              %p
                Prints the last element of the named array to the STDOUT stream of the
                calling environment.
              %h3 Failure Scenarios
              %p Fails if the array name, first parameter, is not given.
              %h3 Return Codes
              %p 0 denoting success
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    $ the_array=(one two three four five)
                    $ array_last_element the_array
                    five
            %td.code
              .highlight
                %pre
                  array_last_element
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  _length
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb eval
                  %span.s2 &quot;_length=\${#${_array_name}[@]}&quot;
                  %span.nb eval
                  %span.s2 &quot;printf \&quot;%s\\n\&quot; \&quot;\${${_array_name}[${_length}]}\&quot;&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot push onto array as an array name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                array
                %em> first
                element()
              %p Print the first element of the given array.
              %h3 Input Parameters
              %p First parameter is the name of the array variable.
              %h3 Stream Outputs
              %p
                Prints the first element of the named array to the STDOUT stream of the
                calling environment.
              %h3 Return Codes
              %p 0 denoting success
              %h3 Failure Scenarios
              %p Fails if the array name, the first parameter, is not given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    $ the_array=(one two three four five)
                    $ array_first_element the_array
                    one
            %td.code
              .highlight
                %pre
                  array_first_element
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  _length
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb eval
                  %span.s2 &quot;printf \&quot;%s\\n\&quot; \&quot;\${${_array_name}[0]}\&quot;&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot push onto array as an array name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 array_push()
              %p Appends one or more elements to the array with the given name.
              %h3 Input Parameters
              %p
                The first parameter is the name of the array variable.
                Remaining parameters are the elements to be appended to the array.
              %h3 Stream Outputs
              %p None.
              %h3 Returns
              %p 0 denoting success
              %h3 Failure Scenarios
              %p
                Fails if the array name, the first parameter, is not given.
                Fails if no elements were given (second paramater and beyond).
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    $ the_array=(1 2 3 4 5)
                    $ array_push the_array 6
                    $ array_join the_array # print the contents of the array, space separated
                    1 2 3 4 5 6
            %td.code
              .highlight
                %pre
                  array_push
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  %span.nb                   = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb eval
                  %span.s2 &quot;(( \${#${_array_name}[@]} &gt; 0 ))&quot;
                  = succeed "_element" do
                    %span.nb local
                  %span.nv _elements
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _elements
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot push elements onto array as no elements were given.&quot;
                  %span.k fi
                  = succeed "_element" do
                    %span.k for
                  in
                  %span.s2 &quot;${_elements[@]}&quot;
                  %span.k do
                  %span.k                   %span.nb eval
                  %span.s2 &quot;${_array_name}+=(\${_element})&quot;
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot push elements onto array as an array name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 array_append()
              %p Return the length of the given array.
              %h3 Input Parameters
              %p
                The first parameter is the name of the array variable.
                Remaining parameters are the elements to append to the end of the array.
              %h3 Stream Outputs
              %p None.
              %h3 Returns
              %p 0 denoting success
              %h3 Failure Scenarios
              %p
                Fails if the array name, the first parameter, is not given.
                Fails if no elements were given to append to the array.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ the_array=(1)
                    user$ array_append the_array 2 3 4 5
                    user$ array_join the_array # print the contents of the array,
                    space separated.
                    1 2 3 4 5
            %td.code
              .highlight
                %pre
                  array_append
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb shift
                  = succeed "_element" do
                    %span.nb local
                  %span.nv _elements
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _elements
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot push elements onto array as no elements were given.&quot;
                  %span.k fi
                  = succeed "_element" do
                    %span.k for
                  in
                  %span.s2 &quot;${_elements[@]}&quot;
                  %span.k do
                  %span.k                   %span.nb eval
                  %span.s2 &quot;${_array_name}+=(\${_element})}&quot;
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot push onto array as an array name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 array_shift()
              %p Removes the first element of the array and prints it.
              %h3 Input Parameters
              %p The first parameter is the name of the array variable.
              %h3 Stream Outputs
              %p
                Prints the first element of the named array to the STDOUT stream of the
                calling environment.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat $HOME/test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework.
                    modules array
                    
                    my_array=(1 2 3 4)
                    echo ${my_array[@]}
                    array_shift my_array
                    echo ${my_array[@]}
                    
                    user$ $HOME/test
                    1 2 3 4
                    1
                    2 3 4
            %td.code
              .highlight
                %pre
                  array_shift
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nv new_array
                  %span.o =()
                  index first_element
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb eval
                  %span.s2 &quot;
                  %span.s2 first_element=\${${_array_name}[0]}
                  %span.s2 for (( index=1; index &lt; \${#${_array_name}[@]}; index++ ))
                  %span.s2 do
                  %span.s2 new_array+=(\${${_array_name}[\${index}]})
                  %span.s2 done
                  %span.s2 ${_array_name}=(\&quot;\${new_array[@]}\&quot;)
                  %span.s2 &quot;
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;${first_element}&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot shift from array as an array name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 array_unshift()
              %p
                Prepends one or more elements to the array whose name is given, in the order
                given.
              %h3 Input Parameters Parameters
              %p
                The first parameter is the name of the array variable.
                Remaining parameters are the elements to prepend to the array.
              %h3 Stream Outputs
              %p
                None.
                Yields a failure message if no array name was given.
                Yields a failure message if no elements were given to unshift.
              %h3 Return Codes
              %p 0 denoting success
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    $ the_array=(2 3 4 5)
                    $ array_unshift 1
                    user$ array_join the_array # print contents of the array, space separated.
                    1 2 3 4 5
                    
                    $ the_array=(4 5)
                    $ array_unshift 3 2 1
                    user$ array_join the_array # print contents of the array, space separated.
                    1 2 3 4 5
            %td.code
              .highlight
                %pre
                  array_unshift
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb shift
                  = succeed "_element" do
                    %span.nb local
                  %span.nv _elements
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _elements
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot push elements onto array as no elements were given.&quot;
                  %span.k fi
                  = succeed "_element" do
                    %span.k for
                  in
                  %span.s2 &quot;${_elements[@]}&quot;
                  %span.k do
                  %span.k                   %span.nb eval
                  %span.s2 &quot;${_array_name}=(\&quot;${_element}\&quot; \&quot;\${${_array_name}[@]}\&quot;)&quot;
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot push onto array as an array name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 array_join()
              %p
                Joins the named array into a string separated by either a space or
                a given string.
              %h3 Input Parameters
              %p
                The first parameter is the name of the array variable.
                The second parameter is the separator between elements in the string, this is
                optional and defaults to a space.
              %h3 Stream Outputs
              %p
                Prints the elements of the named array, separated by either the 2nd parameter
                if given or else a space character, to the STDOUT stream of the calling
                environment.
              %h3 Return Codes
              %p 0 denoting success
              %h3 Failure Scenarios
              %p Fails if the array name, the first parameter, is not given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    $ the_array=(1 2 3 4 5)
                    $ array_join the_array
                    1 2 3 4 5
                    
                    $ array_join the_array '.'
                    1.2.3.4.5
            %td.code
              .highlight
                %pre
                  array_join
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb local
                  %span.nv _separator
                  %span.o =
                  %span.s2 &quot;${1:-' '}&quot;
                  %span.nb eval
                  %span.s2 &quot;
                  %span.s2 for (( index=0 ; index &lt; \${#${_array_name}[@]} ; index++ )) ;
                  %span.s2 do (( index &gt;  0 )) &amp;&amp; printf \&quot;%s\&quot;${_separator}\&quot;\&quot; ;
                  %span.s2 printf \&quot;%s\&quot; \&quot;\${${_array_name}[\${index}]}\&quot; ;
                  %span.s2 done&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot join array as an array name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 array_largest()
              %p Outputs the first string in the array with the largest length.
              %h3 Input Parameters
              %p The first element is an array variable name.
              %h3 Stream Outputs
              %p
                Prints the largest elements of the named array to the STDOUT
                stream of the calling environment.
              %h3 Return Codes
              %p 0 denoting success
              %h3 Failure Scenarios
              %p Fails if the array name, the first parameter, is not given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    $ the_array=(billie bob joe)
                    $ array_largest the_array
                    billie
            %td.code
              .highlight
                %pre
                  array_largest
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _index
                  %span.nv _largest
                  %span.o =
                  %span.s2 &quot;&quot;
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb eval
                  %span.s2 &quot;
                  %span.s2 for (( _index=0 ; _index &lt; \${#${_array_name}[@]} ; _index++ ))
                  %span.s2 do
                  %span.s2 if (( \${#${_array_name}[\${_index}]} &gt; \${#_largest} ))
                  %span.s2 then
                  %span.s2 _largest=\${${_array_name}[\${_index}]}
                  %span.s2 fi
                  %span.s2 done
                  %span.s2 &quot;
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;${_largest}&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot find largest element as an array variable name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                array
                %em> sort
                desc()
              %p Sorts the named array contents in descending order.
              %h3 Input Parameters
              %p An array variable name.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 denoting success
              %h3 Failure Scenarios
              %p Fails if the array name, the first parameter, is not given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat $HOME/test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # BDSM framework
                    modules array
                    
                    arr=(c a d e f b h j i )
                    array_sort_desc arr
                    array_join arr
                    echo
                    
                    user$ $HOME/test
                    j i h f e d c b a
            %td.code
              .highlight
                %pre
                  array_sort_desc
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _index
                  %span.nv _largest
                  %span.o =
                  %span.s2 &quot;&quot;
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb eval
                  %span.s2 &quot;${_array_name}=(\$(
                  %span.s2 echo \&quot;\${${_array_name}[@]}\&quot; | tr ' ' \&quot;\n\&quot; | sort -r
                  %span.s2 ))&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot sort an array in decending order as an array&quot;
                  %span.se \
                  %span.s2 &quot;variable name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                array
                %em> sort
                asc()
              %p Sorts the named array contents in ascending order.
              %h3 Input Parameters
              %p An array variable name.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 denoting success
              %h3 Failure Scenarios
              %p Fails if the array name, the first parameter, is not given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat $HOME/test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # BDSM framework
                    modules array
                    
                    arr=(c a d e f b h j i )
                    array_sort_asc arr
                    array_join arr
                    echo
                    
                    user$ $HOME/test
                    a b c d e f h i j
            %td.code
              .highlight
                %pre
                  array_sort_asc
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _index
                  %span.nv _largest
                  %span.o =
                  %span.s2 &quot;&quot;
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb eval
                  %span.s2 &quot;${_array_name}=(\$(
                  %span.s2 echo \&quot;\${${_array_name}[@]}\&quot; | tr ' ' \&quot;\n\&quot; | sort
                  %span.s2 ))&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot sort an array in ascending order as an array &quot;
                  %span.se \
                  %span.s2 &quot;variable name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 array_unique()
              %p Sorts the named array contents in ascending order.
              %h3 Input Parameters
              %p An array variable name.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 denoting success
              %h3 Failure Scenarios
              %p Fails if the array name, the first parameter, is not given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat $HOME/test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # BDSM framework
                    modules array
                    
                    arr=(a a a b b c c c c d d d d d d)
                    array_unique arr
                    array_join arr
                    echo
                    
                    user$ $HOME/test
                    a b c d
            %td.code
              .highlight
                %pre
                  array_unique
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _index
                  %span.nv _largest
                  %span.o =
                  %span.s2 &quot;&quot;
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb eval
                  %span.s2 &quot;${_array_name}=(\$(
                  %span.s2 echo \&quot; \${${_array_name}[@]} \&quot; | awk -v RS=' ' -v ORS=' ' '!(\$0 in a){a[\$0];print}'
                  %span.s2 ))&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot sort an array in ascending order as an array &quot;
                  %span.se \
                  %span.s2 &quot;variable name was not given.&quot;
                  %span.k fi
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 extension_action()
              %p
                Load the environment for a given extension action and then call it.
                This is the main function for BDSM.
              %h3 Input Parameters
              %p One or more extension names.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                The current extension's initialize file will be resourced into the current
                environment.
              %h3 Return Codes
              %p
                0 for success
                1 for failure
              %h3 Failure Scenarios
              %p
                Fails if no extension was given.
                Fails if no action was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    $ cat $HOME/test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules extensions
                    extension_action ext list
                    
                    $  $HOME/test
                    bash fossil git libevent nginx p7zip postgresql rails redis srv tig tmux zeromq zlib
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  extension_action
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv result
                  = succeed "0" do
                    %span.o =
                  = succeed "extension" do
                    %span.nb unset
                  action
                  %span.nb export
                  %span.nv extension
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${extension}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;'extension' is not set! Something has gone terribly wrong.&quot;
                  %span.k fi
                  %span.k                   %span.nb shift
                  %span.nb export
                  %span.nv action
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${action}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;'action' is not set! Something has gone terribly wrong.&quot;
                  %span.k fi
                  %span.k                   %span.nb shift
                  %span.nb                   %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv extension_args
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nv extension_args
                  %span.o =
                  %span.s2 &quot;$@&quot;
                  %span.k fi
                  %span.k                   = succeed "extension_args" do
                    %span.nb export
                  %span.nv extension_path
                  %span.o =
                  %span.s2 &quot;$extensions_path/$extension&quot;
                  %span.nv extension_config_path
                  %span.o =
                  %span.s2 &quot;$extensions_path/$extension/config&quot;
                  %span.nv extension_templates_path
                  %span.o =
                  %span.s2 &quot;$extensions_path/$extension/templates&quot;
                  %span.nv extension_modules_path
                  %span.o =
                  %span.s2 &quot;$extensions_path/$extension/modules&quot;
                  %span.nv extension_bin_path
                  %span.o =
                  %span.s2 &quot;$extensions_path/$extension/bin&quot;
                  %span.nv extension_log_path
                  %span.o =
                  %span.s2 &quot;$log_path/$extension&quot;
                  %span.nv paths
                  %span.o =
                  = succeed "env" do
                    %span.k $(
                  | awk -F
                  %span.o =
                  \-v
                  %span.nv ORS
                  %span.o =
                  %span.s1 ' '
                  %span.s1 '/_path/{print $1}'
                  %span.k )
                  %span.nv flags
                  %span.o =
                  = succeed "env" do
                    %span.k $(
                  | awk -F
                  %span.o =
                  \-v
                  %span.nv ORS
                  %span.o =
                  %span.s1 ' '
                  %span.s1 '/_flag/{print $1}'
                  %span.k )
                  enter
                  %span.s2 &quot;${extension_path}&quot;
                  %span.o ||
                  fail
                  %span.s2 &quot;Could not enter the extension directory!\n    (${extension_path})&quot;
                  bdsm_exports
                  %span.nv action_file
                  %span.o =
                  %span.s2 &quot;${extension_path}/bin/${action}&quot;
                  file_exists
                  %span.s2 &quot;${action_file}&quot;
                  %span.o ||
                  fail
                  %span.s2 &quot;Action binary/file ${action} missing for extension ${extension}\n    (${action_file})&quot;
                  %span.nv action_file_type
                  %span.o =
                  %span.s2 &quot;$(file &quot;
                  %span.nv $action_file
                  %span.s2 &quot;)&quot;
                  %span.k case
                  %span.s2 &quot;${action_file_type}&quot;
                  in
                  
                  *sh
                  %span.o> [[
                  \:space:
                  %span.o> ]]
                  script*|*POSIX
                  %span.o> [[
                  \:space:
                  %span.o> ]]
                  shell*|*Bourne-Again*
                  %span.o )
                  %span.nv action_type
                  %span.o =
                  %span.s2 &quot;bash&quot;
                  ;;
                  
                  *ASCII*
                  %span.o )
          %tr
            %td.docs
              %p Launch with helper dsl, if possible.
            %td.code
              .highlight
                %pre
                  %span.nv extension
                  %span.o =
                  %span.s2 &quot;${action_file//.}&quot;
                  %span.k case
                  %span.s2 &quot;${extension}&quot;
                  in
                  bash|sh
                  %span.o )
                  %span.nv action_type
                  %span.o =
                  %span.s2 &quot;bash&quot;
                  %span.c #rb) action_type=&quot;ruby&quot;   ;;
                  ;;
                  *
                  %span.o )
                  %span.nb read
                  \-r shebang &lt;
                  %span.s2 &quot;${action_file}&quot;
                  %span.k case
                  %span.s2 &quot;${shebang}&quot;
                  in
                  *ruby|*rbx|*jruby|*macruby
                  %span.o )
                  %span.nv binary
                  %span.o =
                  %span.s2 &quot;${shebang##*(#|!)}&quot;
                  %span.nv binary
                  %span.o =
                  %span.s2 &quot;${binary##* }&quot;
                  %span.nv action_type
                  %span.o =
                  %span.s2 &quot;ruby&quot;
                  ;;
                  *
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-x
                  %span.s2 &quot;${action_file}&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  %span.k                   %span.nv action_type
                  %span.o =
                  %span.s2 &quot;binary&quot;
                  %span.k else
                  %span.k                   %span.nv action_type
                  %span.o =
                  %span.s2 &quot;not executable&quot;
                  %span.k fi
                  ;;
                  %span.k esac
                  ;;
                  %span.k esac
                  %span.k                   %span.nv result
                  %span.o =
                  %span.nv $?
                  ;;
                  
                  cannot
                  %span.o> [[
                  \:space:
                  %span.o> ]]
                  open
                  %span.o )
                  %span.nv action_type
                  %span.o =
                  %span.s2 &quot;dne&quot;
                  ;;
                  
                  *
                  %span.o )
                  = succeed "file_is_executable" do
                    %span.k if
                  %span.s2 &quot;${action_file}&quot;
                  ;
                  %span.k then
                  %span.k                   %span.nv action_type
                  %span.o =
                  %span.s2 &quot;binary&quot;
                  %span.k else
                  %span.k                   %span.nv action_type
                  %span.o =
                  %span.s2 &quot;noexec&quot;
                  %span.k fi
                  ;;
                  %span.k esac
                  %span.o ||
                  %span.nv result
                  %span.o =
                  %span.nv $?
          %tr
            %td.docs
              %p Now based on the determined action_type we launch the extension.
            %td.code
              .highlight
                %pre
                  %span.k case
                  %span.s2 &quot;${action_type}&quot;
                  in
                  bash
                  %span.o )
                  %span.o (
                  enable_backtrace
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;${action}&quot;
                  %span.o =
                  %span.s2 &quot;help&quot;
                  %span.o ]]
                  %span.k then
                  %span.c # Load the help module also.
                  modules core
                  %span.nb help
                  %span.nb                   %span.k else
                  = succeed "modules" do
                    %span.k                   core
                  %span.k fi
                  = succeed "source_files" do
                    %span.k                   %span.se \
                  %span.s2 &quot;${extension_modules_path}/bash/dsl&quot;
                  %span.se \
                  %span.s2 &quot;${extension_modules_path}/bash/initialize&quot;
                  %span.se \
                  %span.s2 &quot;${extension_modules_path}/bash/cli&quot;
                  \.
                  %span.s2 &quot;${action_file}&quot;
                  %span.o )
                  %span.o ||
                  %span.nv result
                  %span.o =
                  %span.nv $?
                  %span.k return
                  %span.nv $result
                  ;;
                  
                  ruby
                  %span.o )
                  %span.nv requires
                  %span.o =()
                  = succeed "script" do
                    %span.k for
                  in dsl initialize
                  %span.k do
                  = succeed "requires+" do
                    %span.k                   %span.o =(
                  %span.s2 &quot;-r${modules_path}/ruby/core/${script}.rb&quot;
                  %span.o )
                  %span.k done
                  %span.s2 &quot;${binary:-ruby}&quot;
                  \-I
                  %span.s2 &quot;${modules_path}/ruby&quot;
                  \-I
                  %span.s2 &quot;${extension_modules_path}/ruby&quot;
                  %span.se \
                  %span.k ${
                  %span.nv requires
                  %span.p [@]
                  %span.k }
                  %span.s2 &quot;${action_file}&quot;
                  ;;
          %tr
            %td.docs
              %p
                python|lua|javascript)
                ADD "${modules
                %em> path}/${action
                type}/" to the lib path so the script can require "bdsm"
                "${action_file}"
                ;;
            %td.code
              .highlight
                %pre
                  dne|noexec
                  %span.o )
                  fail
                  %span.s2 &quot;Processing ${action} failed, file type is unknown, file does not exist or file is not executable.&quot;
                  ;;
                  binary|*
                  %span.o )
                  %span.s2 &quot;${action_file}&quot;
                  %span.s2 &quot;${extension_action}&quot;
                  %span.s2 &quot;${extension_args[@]}&quot;
                  ;;
                  %span.k esac
                  %span.o ||
                  %span.nv result
                  %span.o =
                  %span.nv $?
                  %span.k return
                  %span.nv $result
                  %span.o }
          %tr
            %td.docs
              %h2 extension_reload()
              %p Reloads (re-sources) the current extension's DSL and initialization files.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                The current extension's DSL and initialization files are re-sourced into the
                calling environment.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No current failure scenarios.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ extension_reload
            %td.code
              .highlight
                %pre
                  extension_reload
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${extension_modules_path}/bash&quot;
                  source_files
                  %span.s2 &quot;${_path}/dsl&quot;
                  %span.s2 &quot;${_path}/initialize&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 extension_reinitialize()
              %p Reinitializes the current extension.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                The current extension's initialize file will be resourced into the current
                environment.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ extension_reinitialize
            %td.code
              .highlight
                %pre
                  extension_reinitialize
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${extension_modules_path}/bash&quot;
                  source_files
                  %span.s2 &quot;${_path}/initialize&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 extension_version()
              %p Outputs the named extension's version
              %h3 Input Parameters
              %p First parameter must be the name of an extension.
              %h3 Stream Outputs
              %p The extension-version string for the named extension.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if the extension name is not given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ extension_reinitialize
            %td.code
              .highlight
                %pre
                  extension_version
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _extension
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  variable_is_nonempty
                  %span.o ||
                  fail
                  %span.s2 &quot;Can not retrieve extension version as no extension was given.&quot;
                  %span.nb shift
                  %span.nb true
                  %span.k ${
                  %span.nv extension_path
                  %span.p :=
                  %span.s2 &quot;${extensions_path}/${_extension}&quot;
                  %span.k }
                  = succeed "file_exists" do
                    %span.k if
                  %span.s2 &quot;${extension_path}/VERSION&quot;
                  %span.k then
                  %span.k                   %span.nb read
                  \-r extension_version &lt;
                  %span.s2 &quot;${extension_path}/VERSION&quot;
                  %span.k else
                  %span.k                   %span.nv extension_version
                  %span.o =
                  %span.s2 &quot;head&quot;
                  %span.k fi
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;${extension}-${extension_version}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 extension_licence()
              %p Emits the extension's license file, if it exists.
              %h3 Input Parameters
              %p First parameter may optionally be an extension name.
              %h3 Stream Outputs
              %p If the extension has a LICENSE file then it wil be printed to STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently exist.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    $ cat $HOME/test
                    !/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules extensions
                    extension_license postgresql
                    
                    $ $HOME/test
                    Copyright (c) 2009-2011 Wayne E. Seguin
                    
                    Licensed under the Apache License, Version 2.0 (the \"License\");
                    you may not use this file except in compliance with the License.
                    You may obtain a copy of the License at
                    
                        http://www.apache.org/licenses/LICENSE-2.0
                    
                    Unless required by applicable law or agreed to in writing, software
                    distributed under the License is distributed on an \"AS IS\" BASIS,
                    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                    See the License for the specific language governing permissions and
                    limitations under the License.
            %td.code
              .highlight
                %pre
                  extension_license
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _extension
                  %span.o =
                  %span.s2 &quot;${1:-${extension}}&quot;
                  variable_is_nonempty _extension
                  %span.o ||
                  fail
                  %span.s2 &quot;Can not display extension license as an extension was not given.&quot;
                  cat -v
                  %span.s2 &quot;${extensions_path}/${_extension}/LICENSE&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 extensions_installed()
              %p Lists the extensions installed on the currently running process's system.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                The names of the currently installed non-core extensions are printed to the
                calling environment's STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    $ cat $HOME/test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules extensions
                    extensions_installed
                    
                    $ $HOME/test
                    bash fossil git libevent nginx p7zip postgresql rails redis tig tmux zeromq zlib
            %td.code
              .highlight
                %pre
                  extensions_installed
                  %span.o ()
                  %span.o {
                  extensions_in
                  %span.s2 &quot;${extensions_path}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 extensions_available()
              %p
                Lists the extensions available to install on the currently running process's
                system.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                The names of the available to install non-core extensions are printed to the
                calling environment's STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                     $ cat $HOME/test
                     #!/usr/bin/env bash
                     source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                     modules extensions
                     extensions_available
            %td.code
              .highlight
                %pre
                  :preserve
                    
                    
          %tr
            %td.docs
              %pre
                %code
                  :preserve
                     $  $HOME/test
                     ack androidsdk apache bash bcrypt cacti cmake ctags curl deploy erlang fossil freetype ghc ghostscript git god iconv imagemagick jpeg keepalived lcms libevent libpng libwmf libxml2 libxslt logrotate lua memcached mercurial mongodb monit mysql nginx node npm openpkg openssl p7zip passenger pcre perl postgresql r rails rainbows readline redis riak rsync rvm screen sphinx sqlite3 subversion system thin tiff tig tmux unicorn unrar zeromq zlib zsh
            %td.code
              .highlight
                %pre
                  extensions_available
                  %span.o ()
                  %span.o {
                  extensions_in
                  %span.s2 &quot;${extensions_src_path}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                extensions
                %em> in
                development()
              %p Lists the extensions available in the development repository, if set.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                The names of the available to install non-core development repository
                extensions are printed to the calling environment's STDOUT, if defined.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                     $ cat $HOME/test
                     #!/usr/bin/env bash
                     source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                     modules extensions
                     extensions_in_development
            %td.code
              .highlight
                %pre
                  :preserve
                    
                    
          %tr
            %td.docs
              %pre
                %code
                  :preserve
                     $  $HOME/test
                     ack androidsdk apache bash bcrypt cacti cmake ctags curl deploy erlang fossil freetype ghc ghostscript git god iconv imagemagick jpeg keepalived lcms libevent libpng libwmf libxml2 libxslt logrotate lua memcached mercurial mongodb monit mysql nginx node npm openpkg openssl p7zip passenger pcre perl postgresql r rails rainbows readline redis riak rsync rvm screen sphinx sqlite3 subversion system thin tiff tig tmux unicorn unrar zeromq zlib zsh
            %td.code
              .highlight
                %pre
                  extensions_in_development
                  %span.o ()
                  %span.o {
                  %span.nb true
                  %span.s2 &quot;${extensions_development_path:=&quot;
                  %span.k ${
                  %span.nv extensions_src_path
                  %span.k }
                  %span.s2 &quot;}&quot;
                  list_extensions_in
                  %span.s2 &quot;${extensions_development_path}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 extensions_in()
              %p Lists the extensions in a given directory.
              %h3 Input Parameters
              %p
                First parameter is a full path a BDSM extensions directory.
                (example: /usr/local/bdsm/extensions)
              %h3 Stream Outputs
              %p
                The names of the extensions in the given directory are printed to the
                calling environment's STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    $ cat $HOME/test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules extensions
                    extensions_in /usr/local/bdsm/extensions
                    
                    $  $HOME/test
                    bash fossil git libevent nginx p7zip postgresql rails redis tig tmux zeromq zlib
            %td.code
              .highlight
                %pre
                  extensions_in
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  directory_exists
                  %span.s2 &quot;${_path}&quot;
                  %span.o ||
                  fail
                  %span.s2 &quot;Cannot list extensions in '${_path}' as the directory does not exist.&quot;
                  %span.nv _files
                  %span.o =(
                  = succeed "find" do
                    %span.k $(
                  %span.s2 &quot;${_path}&quot;
                  \-mindepth 2 -maxdepth 2 -name
                  %span.s1 'VERSION'
                  \-type f
                  %span.k )
                  %span.o )
                  %span.nv extensions
                  %span.o =()
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  %span.k                   %span.nv extension_source_path
                  %span.o =
                  %span.s2 &quot;${_file/%\/VERSION}&quot;
                  %span.nv extension_name
                  %span.o =
                  %span.s2 &quot;${extension_source_path//*\/}&quot;
                  %span.k case
                  %span.k ${
                  %span.nv extension_name
                  %span.k }
                  in
                  = succeed "core|ext|mod|pkg|srv|svc|" do
                    %span.o (
                  = succeed "." do
                    %span.o [[=
                  = succeed "*" do
                    %span.o =]]
                  %span.o )
                  %span.nb true
                  %span.c # Ignore core extensions, they are updated with BDSM itself.
                  ;;
                  = succeed "*" do
                    %span.o (
                  %span.o )
                  extensions
                  %span.o [
                  %span.k ${#
                  %span.nv extensions
                  %span.p [@]
                  %span.k }
                  %span.o ]=
                  %span.s2 &quot;${extension_name//*\//}&quot;
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k                   %span.nv extensions
                  %span.o =
                  %span.s2 &quot;${extensions[@]}&quot;
                  %span.nb printf
                  %span.s2 &quot;${extensions}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 extension_actions()
              %p Lists actions exposed by the named extension.
              %h3 Input Parameters
              %p First parameter is the name of the extension to list actions for.
              %h3 Stream Outputs
              %p
                The names of the extensions in the given directory are printed to the
                calling environment's STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Fails if no extension name is given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                     $ cat $HOME/test
                     #!/usr/bin/env bash
                     source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                     modules extensions
                     extension_actions "postgresql"
                    
                     $ $HOME/test
                     backup configure help initialize install restart start status stop uninstall upgrade
            %td.code
              .highlight
                %pre
                  extension_actions
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _extension
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_extension}&quot;
                  %span.o ]]
                  %span.o ||
                  fail
                  %span.s2 &quot;Cannot list actions for extension as no extension was given.&quot;
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;$extensions_path/${_extension}/bin&quot;
                  directory_exists
                  %span.s2 &quot;${_path}&quot;
                  %span.o ||
                  = succeed "0" do
                    %span.k return
                  %span.nb local
                  %span.nv _files
                  %span.o =(
                  = succeed "find" do
                    %span.k $(
                  %span.s2 &quot;${_path}&quot;
                  \-mindepth 1 -maxdepth 1 -type f
                  %span.k )
                  %span.o )
                  = succeed "_file" do
                    %span.nb local
                  %span.nv _actions
                  %span.o =()
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  %span.o [[
                  \! -x
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.o ||
                  _actions+
                  %span.o =(
                  %span.s2 &quot;${_file//*\/}&quot;
                  %span.o )
                  %span.k done
                  %span.k                   %span.nv _actions
                  %span.o =
                  %span.s2 &quot;${_actions[@]}&quot;
                  %span.c # Convert from array to string.
                  %span.nb printf
                  %span.s2 &quot;${_actions}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                extension
                %em> is
                installed()
              %p Tests if a given extension is installed.
              %h3 Input Parameters
              %p First parameter is an extension name.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the extension is installed.
                1 if the extension is not installed.
              %h3 Failure Scenarios
              %p Fails if no extension name is given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    $ cat $HOME/test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules extensions
                    extensions_installed
                    echo
                    for extension in postgresql asdf
                    do
                      if extension_is_installed "${extension}"
                      then
                        echo "${extension} is installed! "
                      else
                        echo "${extension} is NOT installed! "
                      fi
                    done
                    
                    $  $HOME/test
                    bash fossil git libevent mysql nginx node npm p7zip postgresql rails redis tig tmux zeromq zlib
                    postgresql is installed!
                    asdf is NOT installed!
            %td.code
              .highlight
                %pre
                  extension_is_installed
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _name
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_name}&quot;
                  %span.o ]]
                  %span.o ||
                  fail
                  %span.s2 &quot;Can not check for an installed extension as no extension name was given.&quot;
                  %span.nb local
                  %span.nv _extensions
                  %span.o =
                  %span.s2 &quot; $(extensions_in &quot;
                  %span.k ${
                  %span.nv extensions_path
                  %span.k }
                  %span.s2 &quot;) &quot;
                  %span.k case
                  %span.s2 &quot;${_extensions}&quot;
                  in
                  = succeed "*" do
                    %span.o (
                  = succeed ":space:" do
                    %span.o [[
                  %span.o ]]
                  %span.k ${
                  %span.nv _name
                  %span.k }
                  = succeed ":space:" do
                    %span.o [[
                  = succeed "*" do
                    %span.o ]]
                  %span.o )
                  = succeed "0" do
                    %span.k return
                  ;;
                  = succeed "*" do
                    %span.o (
                  %span.o )
                  = succeed "1" do
                    %span.k return
                  ;;
                  %span.k esac
                  %span.o }
          %tr
            %td.docs
              %h2 extensions_install()
              %p Installs the given extensions.
              %h3 Input Parameters
              %p One or more extension names.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                The named extensions will be installed to the filesystem in the BDSM
                extensions directory.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no extensions are passed in to install.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ extensions_install libevent tmux
            %td.code
              .highlight
                %pre
                  extensions_install
                  %span.o ()
                  %span.o {
                  = succeed "_extension" do
                    %span.nb local
                  %span.nb local
                  %span.nv _extensions
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _extensions
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot install extensions as no extensions were given to install.&quot;
                  %span.k fi
          %tr
            %td.docs
              %p
                We need to ensure that the extensions directory already exists before calling
                install in parallel.
            %td.code
              .highlight
                %pre
                  extension_fetch
                  %span.s2 &quot;${extension_uri:=&quot;
                  %span.k ${
                  %span.nv extensions_repository_url
                  %span.k }
                  %span.s2 &quot;}&quot;
                  = succeed "_extension" do
                    %span.k for
                  in
                  %span.s2 &quot;${_extensions[@]}&quot;
                  %span.k do
                  %span.k case
                  %span.s2 &quot;${_extension#\/}&quot;
                  in
                  ext|srv|pkg|core|mod
                  %span.o )
                  %span.k continue
                  %span.c # Skip core extensions.
                  ;;
                  %span.k esac
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_extension}&quot;
                  %span.o ]]
                  %span.k then
                  %span.c # Skip any empty extensions / 'artifact'.
                  %span.k continue
                  %span.k else
                  %span.o (
                  extension_install
                  %span.s2 &quot;${_extension}&quot;
                  = succeed "&amp;amp;" do
                    %span.o )
                  %span.k fi
                  %span.k done
                  %span.k                   %span.nb wait
                  %span.o }
          %tr
            %td.docs
              %h2 extension_install()
              %p Installs the given extension.
              %h3 Input Parameters
              %p First parameter is the name of the extension to install
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                The named extension will be installed to the filesystem in the BDSM
                extension directory.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no extension are passed in to install.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ extension_install redis
            %td.code
              .highlight
                %pre
                  extension_install
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _extension
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_extension}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot install an extension as no extension name was given.&quot;
                  %span.k fi
                  = succeed "extension_is_valid" do
                    %span.k if
                  %span.s2 &quot;${extension_src_path}/${_extension}&quot;
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot; - ${_extension}&quot;
                  copy_directories to
                  %span.s2 &quot;${bdsm_path}/extensions&quot;
                  %span.s2 &quot;${extension_src_path}/${_extension}&quot;
                  log
                  %span.s2 &quot;${extension_uri}&quot;
                  to
                  %span.s2 &quot;${bdsm_path}/extensions/${_extension}/.uri&quot;
          %tr
            %td.docs
              %p TODO: Process extension dependencies...
            %td.code
              .highlight
                %pre
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;${extension_src_path} is not a proper extension.
                  %span.s2 The named extension is missing VERSION and/or bin/help files.
                  %span.s2 Halting installation.&quot;
                  %span.k fi
                  %span.o }
                  extension_fetch_and_install
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _extension
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_extension}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot fetch and install an extension as no extension name was given.&quot;
                  %span.k fi
                  = succeed "extension_fetch" do
                    %span.k                   %span.s2 &quot;${extension_uri:=&quot;
                  %span.k ${
                  %span.nv extensions_repository_url
                  %span.k }
                  %span.s2 &quot;}&quot;
                  extension_install
                  %span.s2 &quot;${_extension}&quot;
                  %span.o }
                  extension_fetch
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _url
                  %span.o =
                  %span.s2 &quot;${1:-$extension_uri}&quot;
                  %span.nb local
                  %span.nv _identifier
                  %span.o =
                  %span.s2 &quot;${_url//\//_}&quot;
                  %span.c # Convert '/' to an invalid url component '_'
                  %span.nb local
                  %span.nv repo_path
                  %span.o =
                  %span.s2 &quot;${repos_path}/${_identifier}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_url}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot fetch an extension from a url as no url was given&quot;
                  %span.k fi
          %tr
            %td.docs
              %p TODO: scm fetch vs tarball fetch
            %td.code
              .highlight
                %pre
                  scm_fetch
                  %span.s2 &quot;${_url}&quot;
                  scm_update
                  %span.s2 &quot;${_url}&quot;
                  %span.nv extension_src_path
                  %span.o =
                  %span.s2 &quot;${repo_path}&quot;
                  %span.o }
                  extension_is_valid
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot determine if an extension is valid as the path to the extension was not given.&quot;
                  %span.k fi
          %tr
            %td.docs
              %p TODO: Add all extension requirement checks here.
            %td.code
              .highlight
                %pre
                  %span.k if
                  %span.o [[
                  \-s
                  %span.s2 &quot;${_path}/VERSION&quot;
                  %span.o &amp;&amp;
                  \-x
                  %span.s2 &quot;${_path}/bin/help&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
                  extension_package
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _name
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_name}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot package an extension as no extension name was given.&quot;
                  %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${extensions_development_path:-&quot;
                  %span.nv $extensions_src_path
                  %span.s2 &quot;}&quot;
                  enter
                  %span.s2 &quot;${_path}&quot;
                  = succeed "extension_is_valid" do
                    %span.k if
                  %span.s2 &quot;${_path}/${_name}&quot;
                  %span.k then
                  %span.k                   %span.nb local
                  %span.nv _version
                  %span.o =
                  %span.s2 &quot;$(cat &quot;
                  %span.k ${
                  %span.nv _name
                  = succeed "/VERSION" do
                    %span.k }
                  %span.s2 &quot;)&quot;
                  log
                  %span.s2 &quot;Packaging extension ${_name}&quot;
                  log
                  %span.s2 &quot;${_name}-${_version}:&quot;
                  = succeed "archiver" do
                    %span.k for
                  in
                  %span.s2 &quot;gzip&quot;
                  %span.s2 &quot;bzip2 -z&quot;
                  %span.s2 &quot;xz -z&quot;
                  %span.k do
                  = succeed "command_exists" do
                    %span.k if
                  %span.k ${
                  %span.nv archiver
                  %span.p // *
                  %span.k }
                  %span.k then
                  = succeed "tar" do
                    %span.k if
                  cf
                  %span.s2 &quot;${_name}-${_version}.tar&quot;
                  %span.s2 &quot;${_name}/&quot;
                  %span.k then
                  %span.k ${
                  %span.nv archiver
                  %span.k }
                  \-f -9
                  %span.s2 &quot;${_name}-${_version}.tar&quot;
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;There was an error ($?) while trying to create a tar of the '${_name}' directory while packaging.&quot;
                  %span.k fi
                  %span.k fi
                  = succeed "ensure_paths_exist" do
                    %span.k                   %span.s2 &quot;${_path}/pkg&quot;
                  = succeed "file" do
                    %span.k for
                  in
                  = succeed ".tar.*" do
                    %span.s2 &quot;${_name}-${_version}&quot;
                  %span.k do
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;  - ${file}&quot;
                  log
                  %span.s2 &quot;$( file_md5 &quot;
                  %span.k ${
                  %span.nv file
                  %span.k }
                  %span.s2 &quot; )&quot;
                  to
                  %span.s2 &quot;${file}.md5&quot;
                  log
                  %span.s2 &quot;  - ${file}.md5&quot;
                  move_files --force
                  %span.s2 &quot;${file}&quot;
                  %span.s2 &quot;${file}.md5&quot;
                  to
                  %span.s2 &quot;${_path}/pkg&quot;
                  %span.k done
                  %span.k done
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Packaging complete (packages are located in '${_path}/pkg' )&quot;
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot package extension '${_name}' as the extension is not valid.&quot;
                  %span.k fi
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 package_error
              %p
                Presents the user with a package related error message including the tail
                of an optional log file.
              %h3 Input Parameters
              %p
                String to be logged, an optional log file containing more details and
                an optional number of lines of the file to show (defaults to 25)
              %h3 Stream Outputs
              %p
                Prints arguments passed in to the calling environments STDOUT with a newline
                character appended and 'ERROR ' prepended.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 1 for failure.
              %h3 Failure Scenarios
              %p Fails if no arguments are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ package_error "Hello there! " configure.log 5
                    ERROR Hello there!
                    
                    
                    Tail of configure.log:
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  %span.c #			checking for inflate in -lz... no
                  %span.c #			configure: error: zlib library not found
                  %span.c #			If you have zlib already installed, see config.log for details on the
                  %span.c #			failure.  It is possible the compiler isn't looking in the proper directory.
                  %span.c #			Use --without-zlib to disable zlib support.
          %tr
            %td.docs
              %pre
                %code
                  :preserve
                    *poof* shell closed...
            %td.code
              .highlight
                %pre
                  package_error
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _message
                  %span.o =
                  %span.nv $1
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_message}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot print a package error as no message was provided.&quot;
                  %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _log
                  %span.o =
                  %span.nv $2
                  %span.k if
                  %span.o [[
                  \-n
                  %span.k ${
                  %span.nv _log
                  %span.k }
                  %span.o ]]
                  %span.o &amp;&amp;
                  file_exists
                  %span.k ${
                  %span.nv _log
                  %span.k }
                  %span.k then
                  %span.c # Append tail of error log to the error message.
                  %span.nb local
                  %span.nv _num_lines
                  %span.o =
                  %span.k ${
                  %span.nv 3
                  %span.k :-
                  %span.nv 25
                  %span.k }
                  %span.c # Default the number of lines to 25
                  %span.nv _message
                  %span.o =
                  %span.s2 &quot;${_message}\n\nTail of ${_log}:\n$( tail -n ${_num_lines} ${_log} )&quot;
                  %span.k fi
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;${_message}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 package_definition
              %p Enables module developers to easily set package variables in name, value pairs.
              %h3 Input Parameters
              %p
                Parameters must come in pairs, variable name first (without the 'package'
                prefix), value second.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                For each name/value pair, a variable package_${name} is created with the given
                value.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if extension developer accidentailly separates key/value with an = :)
                Fails if a key is given without a matching value.
              %h3 Usage Examples
              %p Example Usage:
              %p
                user$ package_definition \
                name "bash" \
                version "4.2" \
                url "ftp.gnu.org/gnu/bash/"
              %h3 Notes
              %p
                For readability it is recommended to split the line into "key value" lines by
                ending the line with a singele backslash '\' character with no space afterwards.
            %td.code
              .highlight
                %pre
                  package_definition
                  %span.o ()
                  %span.o {
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  ;
                  %span.k do
                  %span.k                   %span.nv key
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  ;
                  %span.nb shift
                  %span.nb                   %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${1:-}&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  %span.k                   %span.nv value
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  ;
                  %span.nb shift
                  %span.nb                   %span.k else
                  %span.k if
                  %span.nb echo
                  %span.s2 &quot;$key&quot;
                  | grep
                  %span.s1 '='
                  ;
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Invalid key '${key}'\n =&gt; Guess: Most likely the '=' is supposed to be a ' '.&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Value not specified for key '${key}'\n =&gt; They tend to come in pairs :)&quot;
                  %span.k fi
                  %span.k fi
                  %span.k case
                  %span.s2 &quot;$key&quot;
                  in
                  name
                  %span.o )
                  %span.nv package_name
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  version
                  %span.o )
                  %span.nv package_version
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  file
                  %span.o )
                  %span.nv package_file
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  dir
                  %span.o )
                  %span.nv package_dir
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  url
                  %span.o )
                  %span.nv package_url
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  base_url
                  %span.o )
                  %span.nv package_base_url
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  docs_url
                  %span.o )
                  %span.nv package_docs_url
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  patches_url
                  %span.o )
                  %span.nv package_patches_url
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  md5_url
                  %span.o )
                  %span.nv package_md5_url
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  active_path
                  %span.o )
                  %span.nv active_path
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  bin_path
                  %span.o )
                  %span.nv bin_path
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  packages_path
                  %span.o )
                  %span.nv packages_path
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  source_path
                  %span.o )
                  %span.nv source_path
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  target_path
                  %span.o )
                  %span.nv target_path
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  archive_format
                  %span.o )
                  %span.nv archive_format
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
          %tr
            %td.docs
              %p TODO: Simplify into
            %td.code
              .highlight
                %pre
                  %span.c #(+([[[:alnum:]]|])_path|name|version|url|md5_url)
          %tr
            %td.docs
              %p
                eval "${key}=${value}"
                ;;
            %td.code
              .highlight
                %pre
                  *
                  %span.o )
                  fail
                  %span.s2 &quot;Unknown key '${key}' (value: ${value})&quot;
                  ;;
                  %span.k esac
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 package_install
              %p
                Performs all package installation steps:
                * download
                * extract
                * patch
                * confiure
                * build
                * install
                * postinstall
                * activation
                * service setup, if service module is loaded
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Steps performed are logged to STDOUT of the calling environment.
              %h3 Environmental effects
              %p Package installation artifacts are created in the system and source directories.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Fails if any of the constituant components fail.
              %h3 Usage Examples
              %p Example Usage:
              %p
                user$ package_definition \
                name "bash" \
                version "4.2" \
                url "ftp.gnu.org/gnu/bash/"
              %p user$ package_install
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_install
                  %span.o ()
                  %span.o {
                  variables_must_be_nonempty package_name package_version archive_format
                  %span.nb true
                  %span.s2 &quot;${package_dir:=&quot;
                  %span.k ${
                  %span.nv package_name
                  = succeed "-" do
                    %span.k }
                  %span.k ${
                  %span.nv package_version
                  %span.k }
                  %span.s2 &quot;}&quot;
                  ensure_paths_exist
                  %span.s2 &quot;${source_path}&quot;
                  enter
                  %span.s2 &quot;${source_path}&quot;
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_download&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_download&quot;
                  %span.k else
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Downloading ${package_name} ${package_version}&quot;
                  package_fetch
                  %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_preextract&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_preextract&quot;
                  %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_extract&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_extract&quot;
                  %span.k else
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Extracting ${package_name} ${package_version}&quot;
                  package_extract
                  %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_postextract&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_postextract&quot;
                  %span.k fi
                  = succeed "enter" do
                    %span.k                   %span.s2 &quot;${package_dir}&quot;
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_patch&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_patch&quot;
                  %span.k else
                  = succeed "package_patch" do
                    %span.k                   %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_preconfigure&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_preconfigure&quot;
                  %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_configure&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_configure&quot;
                  %span.k else
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Configuring ${package_name} ${package_version}&quot;
                  package_configure
                  %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_postconfigure&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_postconfigure&quot;
                  %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_build&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_build&quot;
                  %span.k else
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Building ${package_name} ${package_version}&quot;
                  package_build
                  %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_preinstall&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_preinstall&quot;
                  %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_install&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_install&quot;
                  %span.k else
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Installing ${package_name} ${package_version}&quot;
                  package_make_install
                  
                  log
                  %span.s2 &quot;Installed ${package_name} ${package_version}.&quot;
                  %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_postinstall&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_postinstall&quot;
                  %span.k fi
                  = succeed "package_activate_if_first" do
                    %span.k                   %span.s2 &quot;${package_name}&quot;
                  %span.s2 &quot;${package_version}&quot;
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_postactivate&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_postactivate&quot;
                  %span.k fi
                  = succeed "package_setup" do
                    %span.k                   = succeed "module_is_loaded" do
                    %span.k if
                  %span.s2 &quot;service&quot;
                  %span.k then
                  = succeed "service_setup" do
                    %span.k                   %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                package
                %em> fetch
                md5
              %p Fetches the package's md5 sum from the md5_url, if given.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p The 'package_md5' variable is set with the downloaded md5 sum.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Fails if any of the constituant components fail.
              %h3 Usage Examples
              %p Example Usage:
              %p
                user$ package
                %em> fetch
                md5
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_fetch_md5
                  %span.o ()
                  %span.o {
                  variables_must_be_nonempty package_name package_version archive_format
                  = succeed "download_url" do
                    %span.nb local
                  \:
                  %span.se \
                  %span.s2 &quot;${package_file:=&quot;
                  %span.k ${
                  %span.nv package_name
                  = succeed "-" do
                    %span.k }
                  %span.k ${
                  %span.nv package_version
                  = succeed "." do
                    %span.k }
                  %span.k ${
                  %span.nv archive_format
                  %span.k }
                  %span.s2 &quot;}&quot;
                  %span.se \
                  %span.s2 &quot;${packge_md5_url:=&quot;
                  %span.k ${
                  %span.nv package_base_url
                  = succeed "/" do
                    %span.k }
                  %span.k ${
                  %span.nv package_file
                  = succeed ".md5" do
                    %span.k }
                  %span.s2 &quot;}&quot;
                  %span.se \
                  %span.s2 &quot;${package_md5:=$( hash_file &quot;
                  %span.k ${
                  %span.nv extension_config_path
                  = succeed "/md5" do
                    %span.k }
                  %span.s2 &quot; &quot;
                  %span.k ${
                  %span.nv package_file
                  %span.k }
                  %span.s2 &quot; )}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${package_md5}&quot;
                  %span.o &amp;&amp;
                  \-n
                  %span.s2 &quot;${package_md5_url}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "curl" do
                    %span.k                   \-L
                  %span.s2 &quot;${packge_md5_url}&quot;
                  \-o
                  %span.s2 &quot;${package_file}.md5&quot;
                  2&gt;/dev/null
                  %span.o ||
                  error
                  %span.s2 &quot;Fetching md5 from '${package_md5_url}' failed.&quot;
                  %span.nv package_md5
                  %span.o =
                  = succeed "cat" do
                    %span.k $(
                  %span.s2 &quot;${package_file}.md5&quot;
                  %span.k )
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 package_fetch
              %p Fetches the package's archive file.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p curl output goes to STDERR of the calling environment.
              %h3 Environmental effects
              %p The package archive file will be placed on the filesystem.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_fetch
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_fetch
                  %span.o ()
                  %span.o {
                  variables_must_be_nonempty package_name package_version archive_format
                  
                  \:
                  %span.se \
                  %span.s2 &quot;${package_file:=&quot;
                  %span.k ${
                  %span.nv package_name
                  = succeed "-" do
                    %span.k }
                  %span.k ${
                  %span.nv package_version
                  = succeed "." do
                    %span.k }
                  %span.k ${
                  %span.nv archive_format
                  %span.k }
                  %span.s2 &quot;}&quot;
                  %span.se \
                  %span.s2 &quot;${package_url:=&quot;
                  %span.k ${
                  %span.nv package_base_url
                  = succeed "/" do
                    %span.k }
                  %span.k ${
                  %span.nv package_file
                  %span.k }
                  %span.s2 &quot;}&quot;
                  package_fetch_md5
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  package_md5
                  %span.k then
                  = succeed "file_matches_md5" do
                    %span.k                   %span.s2 &quot;${package_file}&quot;
                  %span.s2 &quot;${package_md5}&quot;
                  %span.o ||
                  %span.o {
                  log
                  %span.s2 &quot;${package_file} does not match md5 ${package_md5}, removing and downloading.&quot;
                  remove_files
                  %span.s2 &quot;${package_file}&quot;
                  curl -L
                  %span.s2 &quot;${package_url}&quot;
                  \-o
                  %span.s2 &quot;${package_file}&quot;
                  %span.o ||
                  error
                  %span.s2 &quot;Downloading ${package_name} from '${package_url}' to '${package_file}' failed &quot;
                  %span.o }
                  %span.k else
                  = succeed "curl" do
                    %span.k                   \-L
                  %span.s2 &quot;${package_url}&quot;
                  \-o
                  %span.s2 &quot;${package_file}&quot;
                  %span.o ||
                  error
                  %span.s2 &quot;Downloading ${package_name} from '${package_url}' to '${package_file}' failed &quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 package_extract
              %p Extracts the package archive into the package source directory.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p The 'package_md5' variable is set with the downloaded md5 sum.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Errors halting program if any extraction fails or if the archive format is
                unknown.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_extract
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_extract
                  %span.o ()
                  %span.o {
                  extract_archive
                  %span.s2 &quot;${package_file}&quot;
                  %span.s2 &quot;${source_path}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 package_configure
              %p Configures the package source (eg. ./configure ...).
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Makefile will be generated for a standard package extension.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if configuration fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_configure
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_configure
                  %span.o ()
                  %span.o {
                  = succeed "_command" do
                    %span.nb local
                  %span.k if
                  %span.o [[
                  \-n
                  %span.k ${
                  %span.nv configure_command
                  %span.k :-}
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _command
                  %span.o =
                  %span.s2 &quot;${configure_command}&quot;
                  %span.k else
                  %span.k                   %span.nb export
                  %span.nv PREFIX
                  %span.o =
                  %span.s2 &quot;${install_base_path}/${package_version}&quot;
                  %span.nv _command
                  %span.o =
                  = succeed "--prefix" do
                    %span.s2 &quot;./configure ${configure_flags[@]:-&quot;
                  %span.o =
                  %span.k ${
                  %span.nv install_path
                  %span.k :-
                  %span.nv $packages_path
                  %span.k }
                  %span.s2 &quot;}&quot;
                  file_is_executable
                  %span.s2 &quot;configure&quot;
                  %span.o ||
                  = succeed "0" do
                    %span.k return
                  %span.k fi
                  %span.k if
                  %span.k ${
                  %span.nv _command
                  %span.k }
                  \&gt; configure.log 2&gt;&amp;1
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Configuration of ${package_name} ${package_version} successful.&quot;
                  %span.k else
                  = succeed "package_error" do
                    %span.k                   %span.s2 &quot;Configuration of ${package_name} ${package_version} failed&quot;
                  %span.s2 &quot;configure.log&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 package_build
              %p builds the package source (eg. make)
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Makefile will be generated for a standard package extension.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if building fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_build
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_build
                  %span.o ()
                  %span.o {
                  = succeed "_command" do
                    %span.nb local
                  %span.k if
                  %span.o [[
                  \-n
                  %span.k ${
                  %span.nv make_command
                  %span.k :-}
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _command
                  %span.o =
                  %span.s2 &quot;${make_command}&quot;
                  %span.k else
                  %span.k                   %span.nv _command
                  %span.o =
                  = succeed "-j" do
                    %span.s2 &quot;make ${make_flags[@]:-&quot;
                  = succeed "os_cpu_count" do
                    %span.k $(
                  %span.k )
                  %span.s2 &quot;}&quot;
                  %span.k fi
                  %span.k if
                  %span.nb eval
                  %span.s2 &quot;${_command}&quot;
                  \&gt; make.log 2&gt;&amp;1
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "package_error" do
                    %span.k                   %span.s2 &quot;Compilation of ${package_name} ${package_version} failed! &quot;
                  %span.s2 &quot;make.log&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                package
                %em> make
                install
              %p make install  the package source (eg. make)
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Installation files will be installed to the install_path.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if make install fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p
                user$ package
                %em> make
                install
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_make_install
                  %span.o ()
                  %span.o {
                  = succeed "_command" do
                    %span.nb local
                  %span.k if
                  %span.o [[
                  \-n
                  %span.k ${
                  %span.nv make_install_command
                  %span.k :-}
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _command
                  %span.o =
                  %span.s2 &quot;${make_install_command}&quot;
                  %span.k else
                  %span.k                   %span.nv _command
                  %span.o =
                  %span.s2 &quot;make ${make_install_flags[@]:-install}&quot;
                  %span.k fi
                  %span.k if
                  %span.k ${
                  %span.nv _command
                  %span.k }
                  \&gt; make.install.log 2&gt;&amp;1
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "package_error" do
                    %span.k                   %span.s2 &quot;Installation of ${package_name} ${package_version} failed! &quot;
                  %span.s2 &quot;make.install.log&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 package_activate
              %p activates the package
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Symlink will be created to the active version in the package install path.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if activateing fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_activate
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_activate
                  %span.o ()
                  %span.o {
          %tr
            %td.docs
              %p TODO: Switch package activation to
            %td.code
              .highlight
                %pre
                  %span.nb local
                  %span.nv _package
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.nv _version
                  %span.o =
                  %span.s2 &quot;${2:-}&quot;
                  variables_must_be_nonempty _package _version
                  = succeed "symlink_exists" do
                    %span.k if
                  %span.s2 &quot;${packages_path}/${_package}/active&quot;
                  %span.k then
                  = succeed "package_deactivate" do
                    %span.k                   %span.s2 &quot;${_package}&quot;
                  %span.k fi
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${install_path}&quot;
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Activating ${_package} ${_version}&quot;
                  = succeed "command_exists" do
                    %span.k if
                  rsync
                  %span.k then
                  = succeed "rsync" do
                    %span.k                   \-a
                  %span.s2 &quot;${install_path}/&quot;
                  %span.s2 &quot;${active_path}/&quot;
                  %span.k else
                  = succeed "cp" do
                    %span.k                   \-Rf
                  %span.s2 &quot;${install_path}/&quot;
                  %span.s2 &quot;${active_path}&quot;
                  %span.k fi
                  = succeed "link" do
                    %span.k                   \--force
                  %span.s2 &quot;${packages_path}/${_package}/${_version}&quot;
                  %span.se \
                  to
                  %span.s2 &quot;${packages_path}/${_package}/active&quot;
                  %span.k else
                  = succeed "warn" do
                    %span.k                   %span.s2 &quot;Skipping activation of ${_package} ${_version} &quot;
                  %span.se \
                  %span.s2 &quot;as '${install_path}' does not exist.&quot;
                  %span.k fi
                  = succeed "package_setup" do
                    %span.k                   %span.s2 &quot;${_package}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 package_setup
              %p Sets up the package
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p
                ldconfig, profile.d and service (init.d / conf.d) files will be put in place
                on the system.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if setup fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_setup
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_setup
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _package
                  %span.o =
                  %span.s2 &quot;${1:-${package_name}}&quot;
                  package_ldconfig
                  %span.s2 &quot;${_package}&quot;
                  package_profile_d
                  %span.s2 &quot;${_package}&quot;
                  = succeed "module_is_loaded" do
                    %span.k if
                  %span.s2 &quot;service&quot;
                  %span.k then
                  = succeed "service_setup" do
                    %span.k                   %span.s2 &quot;${_package}&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 package_deactivate
              %p deactivates the package
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Active symlinks will be removed from the filesystem.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if deactivating fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_deactivate
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_deactivate
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _package
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _file _files
                  
                  variables_must_be_nonempty _package
                  
                  log
                  %span.s2 &quot;Deactivating ${_package}&quot;
                  %span.o (
                  enter
                  %span.s2 &quot;${install_path}&quot;
                  %span.nv directories
                  %span.o =(
                  = succeed "find" do
                    %span.k $(
                  \. -type d
                  %span.k )
                  %span.o )
                  %span.nv files
                  %span.o =(
                  = succeed "find" do
                    %span.k $(
                  \. -type f
                  %span.k )
                  %span.o )
                  = succeed "file" do
                    %span.k for
                  in
                  %span.s2 &quot;${files[@]}&quot;
                  %span.k do
                  = succeed "rm" do
                    %span.k                   \-f
                  %span.s2 &quot;${active_path}/${file#.\/}&quot;
                  %span.k done
                  %span.o )
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;/etc/ld.so.profile.d/${_package}.conf&quot;
                  %span.s2 &quot;/etc/profile.d/${_package}.sh&quot;
                  %span.s2 &quot;${packages_path}/${_package}/active&quot;
                  %span.o )
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 $&quot;${_files[@]}&quot;
                  %span.k do
                  = succeed "file_exists" do
                    %span.k if
                  %span.s2 &quot;${_file}&quot;
                  %span.k then
                  = succeed "remove_files" do
                    %span.k                   %span.s2 &quot;${_file}&quot;
                  %span.k fi
                  %span.k done
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;${_package} deactivated&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                package
                %em> activate
                if_first
              %p
                Activates the package version , if another package version has not yet been
                activated.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p
                Active symlinks will be added to the filesystem if it is the first version
                installed.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if deactivating fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p
                user$ package
                %em> activate
                if_first
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_activate_if_first
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _package
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.nv _version
                  %span.o =
                  %span.s2 &quot;${2:-}&quot;
                  variables_must_be_nonempty _package _version
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${install_path}&quot;
                  %span.k then
                  = succeed "symlink_exists" do
                    %span.k                   %span.s2 &quot;${packages_path}/${_package}/active&quot;
                  %span.o ||
                  package_activate
                  %span.s2 &quot;${_package}&quot;
                  %span.s2 &quot;${_version}&quot;
                  %span.k else
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;'${install_path}' not found, skipping activation.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 package_ldconfig
              %p Sets up system level ldconfigs for the package libraries.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Adjusts ldconfig configuration and runs ldconfig (on linux).
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if deactivating fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_ldconfig
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_ldconfig
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _package
                  %span.o =
                  %span.s2 &quot;${1:-${package_name}}&quot;
                  _path _files
                  
                  variables_must_be_nonempty _package
                  
                  directory_exists
                  %span.s2 &quot;${packages_path}/${_package}/active/lib&quot;
                  %span.o ||
                  = succeed "0" do
                    %span.k return
                  %span.c # no lib/ directory for activated package, no need to update ldconfig
          %tr
            %td.docs
              %p TODO: Figure out if solaris and freebsd have an analog to this?
            %td.code
              .highlight
                %pre
                  %span.k> if
                  user_is_root
                  %span.k then
                  = succeed "os_is_linux" do
                    %span.k if
                  %span.k then
                  = succeed "ensure_paths_exist" do
                    %span.k                   %span.s2 &quot;/etc/ld.so.conf.d&quot;
                  %span.k if
                  \! file_exists
                  %span.s2 &quot;/etc/ld.so.conf.d/bdsm.conf&quot;
                  %span.k then
                  %span.k                   %span.nb printf
                  %span.s2 &quot;%s\n&quot;
                  %span.s2 &quot;${active_path}/lib&quot;
                  \&gt;
                  %span.s2 &quot;/etc/ld.so.conf.d/bdsm.conf&quot;
                  chmod_files 0644
                  %span.s2 &quot;/etc/ld.so.conf.d/bdsm.conf&quot;
                  %span.k fi
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Updating ldconfig for ${_package}&quot;
                  ldconfig
                  = succeed "os_is_darwin" do
                    %span.k elif
                  %span.k then
                  %span.c # Cluster Fuck.
                  %span.nb true
          %tr
            %td.docs
              %p
                This should be handled by the profile.d?
                %em> files=($(find "${packages
                path}/${
                %em>
                  package}/active" -mindepth 1 -maxdepth 1 -type d))
                  (( ${#
                files[@]} > 0 )) &amp;&amp; copy
                %em> files to "${packages
                path}" "${_files[@]}"
            %td.code
              .highlight
                %pre
                  %span.k fi
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                package
                %em> profile
                d
              %p Sets up system level profile_d configuration for the package
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Updates profile_d configuration for the given package
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if profile_d setup fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p
                user$ package
                %em> profile
                d
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_profile_d
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _package
                  %span.o =
                  %span.s2 &quot;${1:-${package_name}}&quot;
                  variables_must_be_nonempty _package
                  = succeed "template_exists" do
                    %span.k if
                  %span.s2 &quot;profile.d.template&quot;
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Updating shell profile for ${_package}&quot;
                  ensure_paths_exist
                  %span.s2 &quot;${profile_d_path}&quot;
                  ensure_files_exist
                  %span.s2 &quot;${profile_path}&quot;
                  install_template
                  %span.s2 &quot;profile.d&quot;
                  to
                  %span.s2 &quot;${profile_d_path}/${_package}.sh&quot;
                  mode 0755
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 package_uninstall
              %p Uninstalls the package
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Uninstalls the package install effects from the system.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if uninstall fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_uninstall
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_uninstall
                  %span.o ()
                  %span.o {
                  variables_must_be_nonempty package_name package_version archive_format
                  = succeed "package_is_active" do
                    %span.k if
                  %span.s2 &quot;${package_name}&quot;
                  %span.s2 &quot;${package_version}&quot;
                  %span.k then
                  %span.c # Deactivate the package if active.
                  package_deactivate
                  %span.s2 &quot;${package_name}&quot;
                  %span.k fi
                  = succeed "remove_paths" do
                    %span.k                   %span.s2 &quot;${install_path}&quot;
                  = succeed "module_is_loaded" do
                    %span.k if
                  service
                  %span.k then
                  %span.c # Remove any service reminants.
                  service_uninstall
                  %span.k fi
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;${package_name} ${package_version} has been uninstalled.&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 package_patch
              %p Applies any patches found for the current package.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Updates the source code directory for the package with any patches found.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if patching fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_patch
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_patch
                  %span.o ()
                  %span.o {
                  = succeed "_patches" do
                    %span.nb local
                  _patch
                  %span.k if
                  \! directory_exists
                  %span.s2 &quot;${extension_patches_path}&quot;
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k fi
          %tr
            %td.docs
              %p
                TODO: Three level hierarchy based on patches/{OS}/{version},
                root level as 'global' always installed.
            %td.code
              .highlight
                %pre
                  :preserve
                    
                    
          %tr
            %td.docs
              %p TODO: Test each dir for existence and skip if missing
            %td.code
              .highlight
                %pre
                  %span.nv _patches
                  %span.o =(
                  = succeed "find" do
                    %span.k $(
                  %span.s2 &quot;${extension_patches_path}&quot;
                  \-mindepth 1 -maxdepth 1 -iname
                  %span.s1 '*.patch'
                  \-type f
                  %span.k )
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _patches
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k fi
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Applying patches for ${package_name} ${package_version}&quot;
                  package_apply_patches
                  %span.s2 &quot;${_patches[@]}&quot;
                  %span.k if
                  \! directory_exists
                  %span.s2 &quot;${extension_patches_path}/$(os_type)&quot;
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k fi
                  %span.k                   %span.nv _patches
                  %span.o =(
                  = succeed "find" do
                    %span.k $(
                  %span.s2 &quot;${extension_patches_path}/$(os_type)&quot;
                  \-mindepth 1 -maxdepth 1 -iname
                  %span.s1 '*.patch'
                  \-type f
                  %span.k )
                  %span.o )
                  package_apply_patches
                  %span.s2 &quot;${_patches[@]}&quot;
                  %span.k if
                  \! directory_exists
                  %span.s2 &quot;${extension_patches_path}/$(os_type)/${package_version}&quot;
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k fi
                  %span.k                   %span.nv _patches
                  %span.o =(
                  = succeed "find" do
                    %span.k $(
                  %span.s2 &quot;${extension_patches_path}/$(os_type)/${package_version}&quot;
                  \-mindepth 1 -maxdepth 1 -iname
                  %span.s1 '*.patch'
                  \-type f
                  %span.k )
                  %span.o )
                  package_apply_patches
                  %span.s2 &quot;${_patches[@]}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                package
                %em> apply
                patches
              %p Applies patches found
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Applies any patches found for the current package.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if apply_patches fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p
                user$ package
                %em> apply
                patches
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_apply_patches
                  %span.o ()
                  %span.o {
                  = succeed "_patch" do
                    %span.nb local
                  %span.nv _patches
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _patches
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot apply patches as no patches were given.&quot;
                  %span.k fi
                  = succeed "_patch" do
                    %span.k for
                  in
                  %span.s2 &quot;${_patches[@]}&quot;
                  %span.k do
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;TODO: patch application is NIY&quot;
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 package_usage
              %p Sets up system level usage configuration for the package
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Updates usage configuration for the given package
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if usage setup fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_usage
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_usage
                  %span.o ()
                  %span.o {
                  %span.nb printf
                  %span.s2 &quot;
                  %span.s2 Usage:
                  %span.s2 $0 [options]
                  %span.s2 options:
                  %span.s2 --prefix   - specify prefix path
                  %span.s2 --src)     - specify source directory
                  %span.s2 --data)    - specify data directory
                  %span.s2 --user)    - specify user to install as
                  %span.s2 --version) - specify version to install
                  %span.s2 --licence) - view licence
                  %span.s2 --help)    - view this usage information
                  %span.s2 &quot;
                  = succeed "0" do
                    %span.k return
                  %span.o }
          %tr
            %td.docs
              %h2 package_cli
              %p Parses package CLI arguments
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Updates cli configuration for the given package
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if cli setup fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_cli
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_cli
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _ignored_args
                  %span.o =()
                  %span.nv number_of_args
                  %span.o =
                  %span.k ${#
                  %span.nv extension_args
                  %span.p [@]
                  %span.k }
                  %span.k for
                  %span.o ((
                  %span.nv index
                  = succeed "0" do
                    %span.o =
                  ; index &lt;
                  %span.nv $number_of_args
                  ; index++
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;${extension_args[$index]}&quot;
                  %span.k case
                  %span.s2 &quot;$token&quot;
                  in
                  \--prefix
                  %span.o )
                  %span.nv packages_path
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--src
                  %span.o )
                  %span.nv src_path
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--data
                  %span.o )
                  %span.nv data_path
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--user
                  %span.o )
                  %span.nv package_user
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--version
                  %span.o )
                  %span.nv package_version
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--base_url
                  %span.o )
                  %span.nv package_base_url
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--file
                  %span.o )
                  %span.nv package_file
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--directory
                  %span.o )
                  %span.nv package_directory
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--archive_format
                  %span.o )
                  %span.nv archive_format
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--activate|activate
                  %span.o )
          %tr
            %td.docs
              %p TODO: Throw error if parameter is not specified.
            %td.code
              .highlight
                %pre
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv extension_args
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "package_activate" do
                    %span.k                   %span.s2 &quot;${extension}&quot;
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot activate ${extension}, no version was given.&quot;
                  %span.k fi
                  ;;
                  \--deactivate|deactivate
                  %span.o )
                  package_deactivate
                  %span.s2 &quot;${extension}&quot;
                  ;;
                  \--md5
                  %span.o )
                  %span.nv package_md5
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--licence
                  %span.o )
                  extension_license
                  = succeed "0" do
                    %span.nb exit
                  ;;
                  \--help
                  %span.o )
                  package_usage
                  = succeed "0" do
                    %span.nb exit
                  ;;
                  \--trace
                  %span.o )
                  %span.nb set
                  \-o xtrace
                  ;;
                  *
                  %span.o )
                  _ignored_args+
                  %span.o =(
                  %span.s2 &quot;${token}&quot;
                  %span.o )
                  ;;
                  %span.k esac
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _ignored_args
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nv extension_args
                  %span.o =(
                  %span.s2 &quot;${_ignored_args[@]}&quot;
                  %span.o )
                  %span.k fi
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 package_active
              %p Parses package active arguments
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Updates active configuration for the given package
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if active setup fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_active
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_is_active
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _name
                  %span.o =
                  %span.s2 &quot;${1:-${package_name}}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_name}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Can not query if a package is active as no package name was given or name is empty.&quot;
                  %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${packages_path}/${_name}&quot;
                  %span.k if
                  %span.o [[
                  \-L
                  %span.s2 &quot;${_path}/active&quot;
                  %span.o &amp;&amp;
                  \-d
                  = succeed "readlink" do
                    %span.k $(
                  %span.s2 &quot;${_path}/active&quot;
                  %span.k )
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 package_must be
              %p Parses package must be arguments
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Updates must be configuration for the given package
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if must be setup fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_must be
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_must_be_active
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _name
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_name}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Can not ensure that package is active as no package name was given or name is empty.&quot;
                  %span.k fi
                  = succeed "package_is_active" do
                    %span.k if
                  %span.s2 &quot;${_name}&quot;
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Install/activate the node package extension before installing ${_name}.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                packages
                %em> must
                be_active
              %p
                Parses package must
                %em> be
                active arguments
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p
                Updates must
                %em> be
                active configuration for the given package
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Errors halting program if must
                %em> be
                active setup fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p
                user$ packages
                %em> must
                be_active
              %h3 Notes
            %td.code
              .highlight
                %pre
                  packages_must_be_active
                  %span.o ()
                  %span.o {
                  = succeed "_package" do
                    %span.nb local
                  %span.nv _packages
                  %span.o =
                  %span.s2 &quot;$@&quot;
                  %span.k if
                  %span.o ((
                  %span.s2 &quot;${#@}&quot;
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Can not ensure that packages are active as no packages were given.&quot;
                  %span.k fi
                  = succeed "_package" do
                    %span.k for
                  in
                  %span.s2 &quot;${_packages[@]}&quot;
                  %span.k do
                  = succeed "package_must_be_active" do
                    %span.k                   %span.s2 &quot;${_package}&quot;
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 package_docs
              %p
                Opens package documentation website either in the web browser (if able) or via
                curl through PAGER (defaulting to less).
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None if can open web browser or website docs in PAGER otherwise.
              %h3 Environmental effects
              %p Web browser will open with documentation url if able.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Error if package
                %em> docs
                url has not been set.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_docs
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_docs
                  %span.o ()
                  %span.o {
          %tr
            %td.docs
              %p TODO: move this logic into a core dsl function.
            %td.code
              .highlight
                %pre
                  %span.k> if
                  os_is_darwin
                  %span.k then
                  = succeed "open" do
                    %span.k                   %span.nv $package_docs_url
                  = succeed "command_exists" do
                    %span.k elif
                  xdg-open
                  %span.k then
                  = succeed "xdg-open" do
                    %span.k                   %span.nv $package_docs_url
                  = succeed "command_exists" do
                    %span.k elif
                  lynx
                  %span.k then
                  = succeed "lynx" do
                    %span.k                   %span.nv $package_docs_url
                  = succeed "command_exists" do
                    %span.k elif
                  links
                  %span.k then
                  = succeed "links" do
                    %span.k                   %span.nv $package_docs_url
                  %span.k else
                  = succeed "curl" do
                    %span.k                   \-s -L
                  %span.nv $package_docs_url
                  \-o /tmp/
                  %span.k ${
                  %span.nv package_name
                  = succeed "-" do
                    %span.k }
                  %span.k ${
                  %span.nv package_version
                  = succeed ".docs" do
                    %span.k }
                  %span.k ${
                  %span.nv EDITOR
                  %span.k :-
                  %span.p /bin/less
                  %span.k }
                  \/tmp/
                  %span.k ${
                  %span.nv package_name
                  = succeed "-" do
                    %span.k }
                  %span.k ${
                  %span.nv package_version
                  = succeed ".docs" do
                    %span.k }
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 package_website
              %p
                Opens package documentation website either in the web browser (if able) or via
                curl through PAGER (defaulting to less).
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None if can open web browser or website website in PAGER otherwise.
              %h3 Environmental effects
              %p Web browser will open with documentation url if able.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Error if package
                %em> website
                url has not been set.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_website
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_website
                  %span.o ()
                  %span.o {
          %tr
            %td.docs
              %p TODO: move this logic into a core dsl function.
            %td.code
              .highlight
                %pre
                  %span.k> if
                  os_is_darwin
                  %span.k then
                  = succeed "open" do
                    %span.k                   %span.nv $package_website_url
                  = succeed "command_exists" do
                    %span.k elif
                  xdg-open
                  %span.k then
                  = succeed "xdg-open" do
                    %span.k                   %span.nv $package_website_url
                  = succeed "command_exists" do
                    %span.k elif
                  lynx
                  %span.k then
                  = succeed "lynx" do
                    %span.k                   %span.nv $package_website_url
                  = succeed "command_exists" do
                    %span.k elif
                  links
                  %span.k then
                  = succeed "links" do
                    %span.k                   %span.nv $package_website_url
                  %span.k else
                  = succeed "curl" do
                    %span.k                   \-s -L
                  %span.nv $package_website_url
                  \-o /tmp/
                  %span.k ${
                  %span.nv package_name
                  = succeed "-" do
                    %span.k }
                  %span.k ${
                  %span.nv package_version
                  = succeed ".website" do
                    %span.k }
                  %span.k ${
                  %span.nv EDITOR
                  %span.k :-
                  %span.p /bin/less
                  %span.k }
                  \/tmp/
                  %span.k ${
                  %span.nv package_name
                  = succeed "-" do
                    %span.k }
                  %span.k ${
                  %span.nv package_version
                  = succeed ".website" do
                    %span.k }
                  %span.k fi
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h1 General Services functions.
              %h2 services_list()
              %p
                List installed services. These are extensions that have loaded the service
                module.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                A list of available services to install are printed to STDOUT of
                the calling environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                NIY
                No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ services_avilable
                    Available service listing has not yet been implemented.
                    This feature has not yet been implemented.
              %h1 General Services functions.
              %h2 services_list()
              %p
                List installed services. These are extensions that have loaded the service
                module.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                A list of available services to install are printed to STDOUT of
                the calling environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                NIY
                No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ services_avilable
                    Available service listing has not yet been implemented.
                    This feature has not yet been implemented.
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  services_avilable
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;Available service listing has not yet been implemented.&quot;
                  NIY
                  services_installed
                  %span.o }
          %tr
            %td.docs
              %h2 services_installed()
              %p
                List installed services. These are extensions that have loaded the service
                module.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                A list of installed extensions that load the service module are printed
                to the STDOUT of the calling environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                NIY
                No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ services_installed
                    nginx unicorn redis postgresql
            %td.code
              .highlight
                %pre
                  services_installed
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;Installed services has not yet been implemented.&quot;
                  NIY
                  %span.o }
          %tr
            %td.docs
              %h2 services_available()
              %p List available services. These are extensions that load the service module.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                A list of available extensions that load the service module are printed to
                STDOUT of the calling environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                NIY
                No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ services_available
                    nginx redis postgresql mongodb ...
            %td.code
              .highlight
                %pre
                  services_available
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;Installed services has not yet been implemented.&quot;
                  NIY
                  %span.o }
          %tr
            %td.docs
              %h1 Single Service functions.
              %h2 service_setup()
              %p Service setup and configuration.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                Creates a system service user with the same name as the service.
                Sets up the service init_d file from template, if it exists.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_setup
                    ...
            %td.code
              .highlight
                %pre
                  service_setup
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;#creating paths for ${service} ${package_version}...&quot;
                  ensure_paths_exist
                  %span.s2 &quot;${service_paths[@]}&quot;
                  %span.s2 &quot;${install_path}&quot;
                  chown_paths_recursively
                  %span.s2 &quot;${service_user}:${service_user}&quot;
                  %span.s2 &quot;${service_paths[@]}&quot;
                  chown_paths_recursively
                  %span.s2 &quot;${service_user}:${service_user}&quot;
                  %span.se \
                  %span.s2 &quot;${service_root_paths[@]}&quot;
                  = succeed "user_is_root" do
                    %span.k if
                  %span.k then
          %tr
            %td.docs
              %p TODO: create an 'user_exists' function and use it here.
            %td.code
              .highlight
                %pre
                  user_create_if_missing
                  %span.s2 &quot;${service_user}&quot;
                  %span.se \
                  with group
                  %span.s2 &quot;${service_user}&quot;
                  2&gt;/dev/null
                  
                  ensure_paths_exist
                  %span.s2 &quot;${service_root_paths[@]}&quot;
                  chown_paths_recursively
                  %span.s2 &quot;${service_user}:${service_user}&quot;
                  %span.se \
                  %span.s2 &quot;${service_root_paths[@]}&quot;
                  %span.k fi
                  = succeed "service_install_init_d" do
                    %span.k                   %span.s2 &quot;${service}&quot;
                  %span.o }
          %tr
            %td.docs
              %h1 Single Service functions.
              %h2 service_uninstall()
              %p Service uninstall and configuration.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                Creates a system service user with the same name as the service.
                Sets up the service init_d file from template, if it exists.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_uninstall
                    ...
            %td.code
              .highlight
                %pre
                  service_uninstall
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;TODO: service_uninstall is NIY&quot;
          %tr
            %td.docs
              %ol
                %li Remove init scripts
                %li Unload OS service hooks
                %li
                  Deactivate database path.
            %td.code
              .highlight
                %pre
                  %span.o }
          %tr
            %td.docs
              %h2 service_start()
              %p Starts the given service using init scripts.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Whatever stream output comes from the called init script.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if extension was not set.
                Fails if the init script is missing or not executable.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ extension=redis
                    user$ service_start
                    ...
            %td.code
              .highlight
                %pre
                  service_start
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${service}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;In order to start a service the 'service' variable must be set.&quot;
                  %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${service}_start&quot;
                  %span.k then
                  %span.s2 &quot;${service}_start&quot;
                  %span.k else
                  = succeed "file_is_executable" do
                    %span.k if
                  %span.s2 &quot;${init_scripts_path}/${service}&quot;
                  %span.k then
                  = succeed "service_init_start" do
                    %span.k                   %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;${init_scripts_path}/${service} is missing or not executable.&quot;
                  %span.k fi
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 service_stop()
              %p stops the given service using init scripts.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Whatever stream output comes from the called init script.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if service was not set.
                Fails if the init script is missing or not executable.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_stop
                    ...
            %td.code
              .highlight
                %pre
                  service_stop
                  %span.o ()
                  %span.o {
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${service}_stop&quot;
                  %span.k then
                  %span.s2 &quot;${service}_stop&quot;
                  %span.k else
                  = succeed "file_is_executable" do
                    %span.k if
                  %span.s2 &quot;${init_scripts_path}/${service}&quot;
                  %span.k then
                  = succeed "service_init_stop" do
                    %span.k                   %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;${init_scripts_path}/${service} is missing or not executable.&quot;
                  %span.k fi
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 service_reload()
              %p reloads the given service using init scripts.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Whatever stream output comes from the called init script.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if service was not set.
                Fails if the init script is missing or not executable.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_reload
                    ...
            %td.code
              .highlight
                %pre
                  service_reload
                  %span.o ()
                  %span.o {
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${service}_reload&quot;
                  %span.k then
                  %span.s2 &quot;${service}_reload&quot;
                  %span.k else
                  = succeed "file_is_executable" do
                    %span.k if
                  %span.s2 &quot;${init_scripts_path}/${service}&quot;
                  %span.k then
                  = succeed "service_init_reload" do
                    %span.k                   %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;${init_scripts_path}/${service} is missing or not executable.&quot;
                  %span.k fi
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 service_restart()
              %p restarts the given service using init scripts.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Whatever stream output comes from the called init script.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if service was not set.
                Fails if the init script is missing or not executable.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_restart
                    ...
            %td.code
              .highlight
                %pre
                  service_restart
                  %span.o ()
                  %span.o {
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${service}_restart&quot;
                  %span.k then
                  %span.s2 &quot;${service}_restart&quot;
                  %span.k else
                  = succeed "file_is_executable" do
                    %span.k if
                  %span.s2 &quot;${init_scripts_path}/${service}&quot;
                  %span.k then
                  = succeed "service_init_stop" do
                    %span.k                   service_init_start
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;${init_scripts_path}/${service} is missing or not executable.&quot;
                  %span.k fi
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 service_status()
              %p statuss the given service using init scripts.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Whatever stream output comes from the called init script.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if service was not set.
                Fails if the init script is missing or not executable.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_status
                    ...
            %td.code
              .highlight
                %pre
                  service_status
                  %span.o ()
                  %span.o {
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${service}_status&quot;
                  %span.k then
                  %span.s2 &quot;${service}_status&quot;
                  %span.k else
                  = succeed "file_is_executable" do
                    %span.k if
                  %span.s2 &quot;${init_scripts_path}/${service}&quot;
                  %span.k then
                  = succeed "service_init_status" do
                    %span.k                   %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;${init_scripts_path}/${service} is missing or not executable.&quot;
                  %span.k fi
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 service_logtail()
              %p logtails the given service using init scripts.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Whatever stream output comes from the called init script.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if service was not set.
                Fails if the init script is missing or not executable.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_logtail
                    ...
            %td.code
              .highlight
                %pre
                  service_logtail
                  %span.o ()
                  %span.o {
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${service}_logtail&quot;
                  %span.k then
                  %span.s2 &quot;${service}_logtail&quot;
                  %span.k else
                  = succeed "file_is_executable" do
                    %span.k if
                  %span.s2 &quot;${init_scripts_path}/${service}&quot;
                  %span.k then
                  = succeed "service_init_logtail" do
                    %span.k                   %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;${init_scripts_path}/${service} is missing or not executable.&quot;
                  %span.k fi
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 service_info()
              %p infos the given service using init scripts.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Whatever stream output comes from the called init script.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if service was not set.
                Fails if the init script is missing or not executable.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_info
                    ...
            %td.code
              .highlight
                %pre
                  service_info
                  %span.o ()
                  %span.o {
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${service}_info&quot;
                  %span.k then
                  %span.s2 &quot;${service}_info&quot;
                  %span.k else
                  = succeed "file_is_executable" do
                    %span.k if
                  %span.s2 &quot;${init_scripts_path}/${service}&quot;
                  %span.k then
                  = succeed "service_init_info" do
                    %span.k                   %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;${init_scripts_path}/${service} is missing or not executable.&quot;
                  %span.k fi
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 service_configcheck()
              %p configchecks the given service using init scripts.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Whatever stream output comes from the called init script.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if service was not set.
                Fails if the init script is missing or not executable.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_configcheck
                    ...
            %td.code
              .highlight
                %pre
                  service_configcheck
                  %span.o ()
                  %span.o {
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${service}_configcheck&quot;
                  %span.k then
                  %span.s2 &quot;${service}_configcheck&quot;
                  %span.k else
                  = succeed "file_is_executable" do
                    %span.k                   %span.s2 &quot;${init_scripts_path}/${service}&quot;
                  %span.o ||
                  fail
                  %span.s2 &quot;${init_scripts_path}/${service} is missing or not executable.&quot;
                  %span.s2 &quot;${init_scripts_path}/${service}&quot;
                  configcheck
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 service_usage()
              %p usages the given service using init scripts.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Whatever stream output comes from the called init script.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if service was not set.
                Fails if the init script is missing or not executable.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_usage
                    ...
            %td.code
              .highlight
                %pre
                  service_usage
                  %span.o ()
                  %span.o {
          %tr
            %td.docs
              %p TODO: Update this for service specific items.
            %td.code
              .highlight
                %pre
                  %span.nb printf
                  %span.s2 &quot;
                  %span.s2 Usage:
                  %span.s2 $0 [options]
                  %span.s2 Options:
                  %span.s2 --prefix   - specify prefix path
                  %span.s2 --src)     - specify source directory
                  %span.s2 --data)    - specify data directory
                  %span.s2 --user)    - specify user to install as
                  %span.s2 --version) - specify version to install
                  %span.s2 --licence) - view licence
                  %span.s2 --help)    - view this usage information
                  %span.s2 &quot;
                  = succeed "0" do
                    %span.k return
                  %span.o }
          %tr
            %td.docs
              %h2 service_cli()
              %p clis the given service using init scripts.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Whatever stream output comes from the called init script.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if service was not set.
                Fails if the init script is missing or not executable.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_cli
                    ...
            %td.code
              .highlight
                %pre
                  service_cli
                  %span.o ()
                  %span.o {
          %tr
            %td.docs
              %p TODO: Update this for service specific items.
            %td.code
              .highlight
                %pre
                  %span.nb local
                  %span.nv _ignored_args
                  %span.o =()
                  %span.nv number_of_args
                  %span.o =
                  %span.k ${#
                  %span.nv extension_args
                  %span.p [@]
                  %span.k }
                  %span.k for
                  %span.o ((
                  %span.nv index
                  = succeed "0" do
                    %span.o =
                  ; index &lt;
                  %span.nv $number_of_args
                  ; index++
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;${extension_args[$index]}&quot;
                  %span.k case
                  %span.s2 &quot;$token&quot;
                  in
                  \--prefix
                  %span.o )
                  %span.nv prefix_path
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--src
                  %span.o )
                  %span.nv src_path
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--data
                  %span.o )
                  %span.nv data_path
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--user
                  %span.o )
                  %span.nv service_user
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--version
                  %span.o )
                  %span.nv service_version
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--base_url
                  %span.o )
                  %span.nv service_base_url
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--file
                  %span.o )
                  %span.nv service_file
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--directory
                  %span.o )
                  %span.nv service_directory
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--archive_format
                  %span.o )
                  %span.nv archive_format
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--activate|activate
                  %span.o )
          %tr
            %td.docs
              %p TODO: Throw error if parameter is not specified.
            %td.code
              .highlight
                %pre
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv extension_args
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "service_activate" do
                    %span.k                   %span.s2 &quot;${service}&quot;
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot activate ${service}, no version was given.&quot;
                  %span.k fi
                  ;;
                  \--deactivate|deactivate
                  %span.o )
                  service_deactivate
                  %span.s2 &quot;${service}&quot;
                  ;;
                  \--md5
                  %span.o )
                  %span.nv service_md5
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--help
                  %span.o )
                  service_usage
                  = succeed "0" do
                    %span.nb exit
                  ;;
                  \--trace
                  %span.o )
                  %span.nb set
                  \-o xtrace
                  ;;
                  *
                  %span.o )
                  _ignored_args+
                  %span.o =(
                  %span.s2 &quot;${token}&quot;
                  %span.o )
                  ;;
                  %span.k esac
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _ignored_args
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nv extension_args
                  %span.o =(
                  %span.s2 &quot;${_ignored_args[@]}&quot;
                  %span.o )
                  %span.k fi
                  %span.k done
                  = succeed "service_init_path" do
                    %span.k                   %span.o }
          %tr
            %td.docs
              %h2 service_pid()
              %p
                List installed services. These are extensions that have loaded the service
                module.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                A list of extensions that load the service module are printed to STDOUT of
                the calling environment.
              %h3 Environmental effects
              %p Sets the variable 'service_pid' to contain the pid of the process or 0.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p None currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    root# service=redis
                    root# service_pid
                    root# echo $service_pid
                    0
            %td.code
              .highlight
                %pre
                  service_pid
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  = succeed "/var/run" do
                    %span.s2 &quot;${run_path:=&quot;
                  %span.s2 &quot;}/${service}&quot;
                  %span.nb local
                  %span.nv _pid
                  = succeed "0" do
                    %span.o =
                  ensure_paths_exist
                  %span.s2 &quot;${_path}&quot;
                  = succeed "file_is_nonempty" do
                    %span.k if
                  %span.s2 &quot;${_path}/${service}.pid&quot;
                  %span.k then
                  %span.k                   %span.nb read
                  \-r _pid &lt;
                  %span.s2 &quot;${_path}/${service}.pid&quot;
                  = succeed "os_is_linux" do
                    %span.k if
                  %span.k then
                  %span.c # Sanity check.
                  %span.k if
                  \! directory_exists
                  %span.s2 &quot;/proc/${pid}&quot;
                  %span.k then
                  %span.k                   %span.nv _pid
                  = succeed "0" do
                    %span.o =
                  rm -f
                  %span.s2 &quot;${_path}/${service}.pid&quot;
                  %span.k fi
                  %span.k fi
                  %span.k fi
                  %span.k                   %span.nv service_pid
                  %span.o =
                  %span.k ${
                  %span.nv _pid
                  %span.k }
                  = succeed "0" do
                    %span.k return
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> load
                conf_d()
              %p
                Load the /etc/conf.d/{service}.conf configuration file into the calling
                environment.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None, unless the configuration file contains any print statements.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_load_conf_d
            %td.code
              .highlight
                %pre
                  service_load_conf_d
                  %span.o ()
                  %span.o {
                  source_files
                  %span.s2 &quot;${confd_path}/${service}.conf&quot;
                  %span.o }
          %tr
            %td.docs
              %h1 Service init functions.
              %h2
                service
                %em> install
                init_d()
              %p Installs the BDSM service module init.d script for the current extension.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging messages informing the end user of what is occurring.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service_install_init_d
            %td.code
              .highlight
                %pre
                  service_install_init_d
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _service
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.nv _version
                  %span.o =
                  %span.s2 &quot;${2:-${package_version}}&quot;
                  variables_must_be_nonempty _service
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${init_scripts_path}&quot;
                  %span.k then
                  = succeed "user_is_root" do
                    %span.k if
                  %span.k then
                  = succeed "ensure_paths_exist" do
                    %span.k                   %span.s2 &quot;/etc/conf.d&quot;
                  %span.s2 &quot;${init_scripts_path}&quot;
                  log
                  %span.s2 &quot;Installing init scripts for ${_service}&quot;
          %tr
            %td.docs
              %p TODO: Install the service init script...
            %td.code
              .highlight
                %pre
                  %span.k> if
                  template_exists
                  %span.s2 &quot;${_service}&quot;
                  %span.k then
                  = succeed "install_template" do
                    %span.k                   %span.s2 &quot;${_service}&quot;
                  to
                  %span.s2 &quot;${init_scripts_path}/${_service}&quot;
                  %span.se \
                  mode 0755
                  %span.k else
          %tr
            %td.docs
              %p Use core srv init.d template
            %td.code
              .highlight
                %pre
                  install_template
                  %span.s2 &quot;init.d&quot;
                  %span.se \
                  from
                  %span.s2 &quot;${extensions_path}/srv/templates&quot;
                  %span.se \
                  to
                  %span.s2 &quot;${init_scripts_path}/${_service}&quot;
                  mode 0755
                  
                  seed_template
                  %span.s2 &quot;${init_scripts_path}/${_service}&quot;
                  %span.se \
                  modules_path
                  %span.s2 &quot;${modules_path}&quot;
                  %span.se \
                  service
                  %span.s2 &quot;${service}&quot;
                  %span.se \
                  service_user
                  %span.s2 &quot;${service_user}&quot;
                  %span.k fi
                  = succeed "service_activate" do
                    %span.k                   %span.s2 &quot;${service}&quot;
                  %span.s2 &quot;${package_version}&quot;
          %tr
            %td.docs
              %p
                TODO: Replace this with install
                %em> template + seed
                template
            %td.code
              .highlight
                %pre
                  log
                  %span.s2 &quot;%s\n&quot;
                  %span.s2 &quot;[ -d \&quot;${prefix_path}/${_service}/active/bin\&quot; ] &amp;&amp; &quot;
                  %span.se \
                  to
                  %span.s2 &quot;/etc/profile.d/${_service}.sh&quot;
                  log
                  %span.s2 &quot;%s\n&quot;
                  %span.s2 &quot;PATH=\&quot;\$PATH:${prefix_path}/${_service}/active/bin\&quot; ; export PATH; &quot;
                  %span.se \
                  append to
                  %span.s2 &quot;/etc/profile.d/${_service}.sh&quot;
                  chmod_files 0755
                  %span.s2 &quot;/etc/profile.d/${_service}.sh&quot;
                  %span.k fi
                  %span.k else
                  = succeed "0" do
                    %span.k return
                  %span.c # No bin/ dir, no need for it to be in the path.
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> init
                path()
              %p Sets the PATH explicitely for purposes of the current service extension.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p Alters the PATH variable.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service_init_path
            %td.code
              .highlight
                %pre
                  service_init_path
                  %span.o ()
                  %span.o {
                  %span.nv PATH
                  %span.o =
                  %span.s2 &quot;${prefix_path}/bin:/bin:/usr/bin:/usr/local/bin:/sbin:/usr/sbin:/usr/local/sbin:${PATH}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> init
                start()
              %p This is the generalized service init start function.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging telling the end user what is happening.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service_init_start
            %td.code
              .highlight
                %pre
                  service_init_start
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;Starting ${service}...&quot;
                  service_init_path
                  %span.nb local
                  %span.nv _result
                  = succeed "0" do
                    %span.o =
                  %span.nv _command
                  %span.o =(
                  %span.s2 &quot;${service_binary}&quot;
                  %span.o )
                  = succeed "array_is_nonempty" do
                    %span.k if
                  service_start_flags
                  %span.k then
                  = succeed "_command+" do
                    %span.k                   %span.o =(
                  %span.s2 &quot;${service_start_flags[@]}&quot;
                  %span.o )
                  %span.k fi
                  = succeed "array_is_nonempty" do
                    %span.k if
                  service_flags
                  %span.k then
                  = succeed "_command+" do
                    %span.k                   %span.o =(
                  %span.s2 &quot;${service_flags[@]}&quot;
                  %span.o )
                  %span.k fi
                  %span.k if
                  %span.o ((
                  %span.nv service_run_as_root_flag
                  %span.o ==
                  1
                  %span.o ))
                  %span.k then
                  %span.k if
                  %span.k ${
                  %span.nv _command
                  %span.p [*]
                  %span.k }
                  %span.k then
                  %span.k                   %span.nb true
                  %span.nb                   %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;${service} failed to start.&quot;
                  %span.k fi
                  %span.k else
                  %span.k if
                  \! user_run_as
                  %span.s2 &quot;${service_user}&quot;
                  %span.s2 &quot;${_command[*]}&quot;
                  %span.k then
                  %span.k                   %span.nb true
                  %span.nb                   %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;${service} failed to start.&quot;
                  %span.k fi
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> init
                stop()
              %p This is the generalized service init stop function.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging telling the end user what is happening.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service_init_stop
            %td.code
              .highlight
                %pre
                  service_init_stop
                  %span.o ()
                  %span.o {
                  service_init_path
                  %span.k if
                  %span.o ((
                  service_pid &gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Stopping ${service}...&quot;
                  %span.k if
                  %span.nb kill
                  \-QUIT
                  %span.s2 &quot;${service_pid}&quot;
                  %span.k then
                  = succeed "rm" do
                    %span.k                   \-f
                  %span.s2 &quot;$service_pid_file&quot;
                  %span.k else
                  %span.k return
                  %span.nv $?
                  %span.k fi
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Service pid has not been set or is zero.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> init
                status()
              %p This is the generalized service init status function.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging telling the end user what is happening.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service_init_status
            %td.code
              .highlight
                %pre
                  service_init_status
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;statusing ${service}...&quot;
                  service_init_path
                  %span.nb local
                  %span.nv _command
                  %span.o =(
                  %span.s2 &quot;${service_binary}&quot;
                  %span.o )
                  = succeed "array_is_nonempty" do
                    %span.k if
                  service_status_flags
                  %span.k then
                  = succeed "_command+" do
                    %span.k                   %span.o =(
                  %span.s2 &quot;${service_status_flags[@]}&quot;
                  %span.o )
                  %span.k fi
                  = succeed "array_is_nonempty" do
                    %span.k if
                  service_flags
                  %span.k then
                  = succeed "_command+" do
                    %span.k                   %span.o =(
                  %span.s2 &quot;${service_flags[@]}&quot;
                  %span.o )
                  %span.k fi
                  = succeed "user_run_as" do
                    %span.k if
                  %span.s2 &quot;${service_user}&quot;
                  %span.s2 &quot;${_command[*]}&quot;
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "touch" do
                    %span.k                   %span.s2 &quot;$service_pid_file&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> init
                reload()
              %p This is the generalized service init reload function.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging telling the end user what is happening.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service_init_reload
            %td.code
              .highlight
                %pre
                  service_init_reload
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;reloading ${service}...&quot;
                  service_init_path
                  %span.nb local
                  %span.nv _command
                  %span.o =(
                  %span.s2 &quot;${service_binary}&quot;
                  %span.o )
                  = succeed "array_is_nonempty" do
                    %span.k if
                  service_reload_flags
                  %span.k then
                  = succeed "_command+" do
                    %span.k                   %span.o =(
                  %span.s2 &quot;${service_reload_flags[@]}&quot;
                  %span.o )
                  %span.k fi
                  = succeed "array_is_nonempty" do
                    %span.k if
                  service_flags
                  %span.k then
                  = succeed "_command+" do
                    %span.k                   %span.o =(
                  %span.s2 &quot;${service_flags[@]}&quot;
                  %span.o )
                  %span.k fi
                  = succeed "user_run_as" do
                    %span.k if
                  %span.s2 &quot;${service_user}&quot;
                  %span.s2 &quot;${_command[*]}&quot;
                  %span.k then
                  = succeed "touch" do
                    %span.k                   %span.s2 &quot;$service_pid_file&quot;
                  %span.k else
                  %span.k return
                  %span.nv $?
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> init
                usage()
              %p This is the generalized service init usage function.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging telling the end user what is happening.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service_init_usage
            %td.code
              .highlight
                %pre
                  service_init_usage
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;Usage:\n\n  $0 {start|stop|restart|status|info|logtail}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> init
                logtail()
              %p This is the generalized service init logtail function.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging telling the end user what is happening.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service_init_logtail
            %td.code
              .highlight
                %pre
                  service_init_logtail
                  %span.o ()
                  %span.o {
          %tr
            %td.docs
              %p TODO: Adjust this to allow for parameter passing.
            %td.code
              .highlight
                %pre
                  %span.nb> exec
                  tail -n 10
                  %span.s2 &quot;${service_log_file}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> init
                info()
              %p This is the generalized service init info function.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Outputs information about the service (version, etc...).
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service_init_info
            %td.code
              .highlight
                %pre
                  service_init_info
                  %span.o ()
                  %span.o {
                  NIY
                  %span.s2 &quot;service_init_info has not yet been implemented for the service module.&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> conf
                d()
              %p Installs the conf.d template for the service, if it exists.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging updates to inform the user what is happening.
              %h3 Environmental effects
              %p
                Once completed a conf.d file should be in place.
                For example /etc/conf.d/redis.conf for the redis service.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_conf_d
            %td.code
              .highlight
                %pre
                  service_conf_d
                  %span.o ()
                  %span.o {
          %tr
            %td.docs
              %p TODO: Install a default conf.d template if extension does not define one.
            %td.code
              .highlight
                %pre
                  %span.k> if
                  template_exists
                  %span.s2 &quot;conf.d&quot;
                  %span.k then
                  = succeed "install_template" do
                    %span.k                   %span.s2 &quot;conf.d.template&quot;
                  to
                  %span.s2 &quot;/etc/conf.d/${service}.conf&quot;
                  %span.se \
                  mode 0644 owner
                  %span.s2 &quot;${service_user}:${service_user}&quot;
                  = succeed "template_exists" do
                    %span.k if
                  %span.s2 &quot;/etc/conf.d/${service}.conf&quot;
                  %span.k then
                  = succeed "seed_template" do
                    %span.k                   %span.s2 &quot;/etc/conf.d/${service}.conf&quot;
                  %span.se \
                  prefix_path
                  %span.s2 &quot;${prefix_path}&quot;
                  %span.se \
                  init_scripts_path
                  %span.s2 &quot;${init_scripts_path}&quot;
                  %span.se \
                  modules_path
                  %span.s2 &quot;${modules_path}&quot;
                  %span.se \
                  data_path
                  %span.s2 &quot;${data_path}&quot;
                  %span.se \
                  confd_path
                  %span.s2 &quot;${confd_path}&quot;
                  %span.se \
                  extension
                  %span.s2 &quot;${service}&quot;
                  %span.se \
                  service
                  %span.s2 &quot;${service}&quot;
                  %span.k fi
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> init
                start()
              %p This is the generalized service init start function.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging telling the end user what is happening.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service_init_action start
            %td.code
              .highlight
                %pre
                  service_init_action
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _action
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  service_load_conf_d
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${service}_${action}&quot;
                  %span.k then
                  %span.s2 &quot;${service}_${action}&quot;
                  %span.k else
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;${service_actions[*]}&quot;
                  %span.o =
                  *
                  %span.o> [[
                  \:space:
                  %span.o ]]
                  %span.k ${
                  %span.nv action
                  %span.k }
                  = succeed ":space:" do
                    %span.o [[
                  = succeed "*" do
                    %span.o ]]
                  %span.o ]]
                  %span.k then
                  = succeed "service_init_" do
                    %span.k                   %span.k ${
                  %span.nv action
                  %span.k }
                  %span.k else
                  = succeed "service_init_usage" do
                    %span.k                   %span.k fi
                  %span.k fi
                  %span.k return
                  %span.nv $?
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> init
                d()
              %p The main logic for generalized service init.d scripts.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging updates to inform the user what is happening.
              %h3 Environmental effects
              %p May alter the runstate of the service extension.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_init_d
            %td.code
              .highlight
                %pre
                  service_init_d
                  %span.o ()
                  %span.o {
                  enable_backtrace
                  %span.c # Enable backtrace on script error.
                  service_load_conf_d
                  %span.c # Load the configuration file.
          %tr
            %td.docs
              %p Sanity checks go here.
            %td.code
              .highlight
                %pre
                  %span.k> if
                  file_is_executable
                  %span.s2 &quot;${service_binary}&quot;
                  %span.k then
                  = succeed "service_pid" do
                    %span.k                   service_cli
                  %span.c # Parse the script arguments and take action accordingly.
                  service_init_action
                  %span.s2 &quot;${service_action}&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Could not find ${service_binary} or ${service_binary} is not executable.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 service_deactivate()
              %p Deactivates the named service or
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging updates to inform the user what is happening.
              %h3 Environmental effects
              %p Changes the current or named service's init script to be nonexecutable.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_deactivate
            %td.code
              .highlight
                %pre
                  service_deactivate
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _service
                  %span.o =
                  %span.s2 &quot;${1:-&quot;
                  %span.k ${
                  %span.nv service
                  %span.k }
                  %span.s2 &quot;}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_service}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;a service name must be set or passed in in order to deactivate a service.&quot;
                  %span.k fi
                  = succeed "file_exists" do
                    %span.k if
                  %span.s2 &quot;${init_scripts_path}/${_service}&quot;
                  %span.k then
                  = succeed "chmod_files" do
                    %span.k                   0644
                  %span.s2 &quot;${init_scripts_path}/${_service}&quot;
                  = succeed "user_is_root" do
                    %span.k if
                  %span.k then
                  %span.c # Add service to system startup
                  = succeed "command_exists" do
                    %span.k if
                  rc-update
                  %span.k then
                  = succeed "rc-update" do
                    %span.k                   add
                  %span.k ${
                  %span.nv service
                  %span.k }
                  default
                  = succeed "command_exists" do
                    %span.k elif
                  chkconfig
                  %span.k then
                  = succeed "chkconfig" do
                    %span.k                   %span.k ${
                  %span.nv service
                  %span.k }
                  on
                  %span.c #elif command_exists svc
                  %span.c #then
          %tr
            %td.docs
              %p svc ${service} on # TODO: daemontools start on boot
            %td.code
              .highlight
                %pre
                  %span.k else
                  %span.c # Fall back on rc.local to start redis at system startup.
                  %span.k if
                  \! file_contains
                  %span.s2 &quot;/etc/rc.local&quot;
                  %span.s2 &quot;${service} start&quot;
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;${init_scripts_path}/${service} start&quot;
                  %span.se \
                  append to /etc/rc.local
                  %span.k fi
                  %span.k fi
                  %span.k fi
                  %span.k fi
          %tr
            %td.docs
              %p TDOO: hook into system's paths.
            %td.code
              .highlight
                %pre
                  %span.o }
          %tr
            %td.docs
              %h2 service_activate()
              %p Activates the named service or
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging updates to inform the user what is happening.
              %h3 Environmental effects
              %p Changes the current or named service's init script to be nonexecutable.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_deactivate
            %td.code
              .highlight
                %pre
                  service_activate
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _service
                  %span.o =
                  %span.s2 &quot;${1:-&quot;
                  %span.k ${
                  %span.nv service
                  %span.k }
                  %span.s2 &quot;}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_service}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;the service name must be set or passed in in order to activate a service.&quot;
                  %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _version
                  %span.o =
                  %span.s2 &quot;${2:-${package_version}}&quot;
                  variables_must_be_nonempty _service _version
                  = succeed "symlink_exists" do
                    %span.k if
                  %span.s2 &quot;${service_db_path}/active&quot;
                  %span.k then
                  = succeed "service_deactivate" do
                    %span.k                   %span.s2 &quot;${_service}&quot;
                  %span.k fi
                  %span.k if
                  \! directory_exists
                  %span.s2 &quot;${service_db_path}/${_version}&quot;
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Skipping activation of ${_service} ${_version} as '${install_path}' does not exist.&quot;
                  %span.k fi
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Activating service ${_service} version ${_version}&quot;
                  link --force
                  %span.s2 &quot;${service_db_path}/${_version}&quot;
                  to
                  %span.s2 &quot;${service_db_path}/active&quot;
                  = succeed "file_exists" do
                    %span.k if
                  %span.s2 &quot;${init_scripts_path}/${service}&quot;
                  %span.k then
                  = succeed "chmod_files" do
                    %span.k                   0755
                  %span.s2 &quot;${init_scripts_path}/${service}&quot;
                  = succeed "os_is_linux" do
                    %span.k if
                  %span.k then
                  = succeed "user_is_root" do
                    %span.k if
                  %span.k then
                  %span.c # Add service to system startup
                  = succeed "command_exists" do
                    %span.k if
                  rc-update
                  %span.k then
                  = succeed "rc-update" do
                    %span.k                   remove
                  %span.k ${
                  %span.nv service
                  %span.k }
                  default
                  = succeed "command_exists" do
                    %span.k elif
                  chkconfig
                  %span.k then
                  = succeed "chkconfig" do
                    %span.k                   %span.k ${
                  %span.nv service
                  %span.k }
                  off
                  %span.c #elif command_exists svc
                  %span.c #then
          %tr
            %td.docs
              %p
                svc ${service} off
                TODO: daemontools remove start on boot
            %td.code
              .highlight
                %pre
                  %span.k else
                  %span.c # Fall back on rc.local to start redis at system startup.
                  %span.k if
                  \! file_contains
                  %span.s2 &quot;/etc/rc.local&quot;
                  %span.s2 &quot;${service} start&quot;
                  %span.k then
                  = succeed "sed" do
                    %span.k                   \-i -e
                  %span.s2 &quot;d#${init_scripts_path}/${service} start#&quot;
                  \/etc/rc.local
                  %span.k fi
                  %span.k fi
                  %span.k fi
                  = succeed "os_is_darwin" do
                    %span.k elif
                  %span.k then
                  %span.k                   %span.nb true
                  %span.c # TODO: launchctl
                  %span.k else
                  %span.c # ::shrug::
                  %span.k if
                  \! file_contains
                  %span.s2 &quot;/etc/rc.local&quot;
                  %span.s2 &quot;${service} start&quot;
                  %span.k then
                  = succeed "sed" do
                    %span.k                   \-i -e
                  %span.s2 &quot;d#${init_scripts_path}/${service} start#&quot;
                  \/etc/rc.local
                  %span.k fi
                  %span.k fi
                  %span.k fi
                  %span.o }
                  service_status
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;${service}:&quot;
                  %span.k if
                  %span.o [[
                  \-s
                  %span.s2 &quot;${service_pid_file}&quot;
                  %span.o ]]
                  %span.o &amp;&amp;
                  %span.o ((
                  = succeed "head" do
                    %span.k $(
                  \-1
                  %span.k ${
                  %span.nv service_pid_file
                  %span.k })
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nb local
                  %span.nv pid
                  %span.o =
                  = succeed "head" do
                    %span.k $(
                  \-1
                  %span.k ${
                  %span.nv service_pid_file
                  %span.k })
                  %span.nb local
                  %span.nv ps
                  %span.o =
                  = succeed "ps" do
                    %span.k $(
                  \-p
                  %span.k ${
                  %span.nv pid
                  %span.k }
                  \-ostate,sgi_rss,vsize | tail -1
                  %span.k )
                  log
                  %span.s2 &quot;  status: running&quot;
                  log
                  %span.s2 &quot;  version: ${service_version}&quot;
                  log
                  %span.s2 &quot;  process: &quot;
                  log
                  %span.s2 &quot;    pid: ${pid}&quot;
                  = succeed "os_is_linux" do
                    %span.k if
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;    parent_pid: $(awk  '/^PPid:/{print $2}' /proc/${pid}/status)&quot;
                  log
                  %span.s2 &quot;    state: $(printf &quot;
                  %span.nv $ps
                  %span.s2 &quot; | awk '{print $1}')&quot;
                  log
                  %span.s2 &quot;    rss: $(printf &quot;
                  %span.nv $ps
                  %span.s2 &quot; | awk '{print $2}')&quot;
                  log
                  %span.s2 &quot;    vsz: $(printf &quot;
                  %span.nv $ps
                  %span.s2 &quot; | awk '{print $3}')&quot;
                  %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  lsof
                  %span.k then
                  %span.k                   %span.nb local
                  %span.nv cwd
                  %span.o =
                  %span.nv binary
                  %span.o =
                  %span.nv libraries
                  %span.o =()
                  %span.nv tcp_ports
                  %span.o =()
                  %span.nv udp_ports
                  %span.o =()
                  %span.nv sockets
                  %span.o =()
                  %span.nv logs
                  %span.o =()
                  string
                  %span.k while
                  %span.nb read
                  \-r line
                  %span.k do
                  %span.k case
                  %span.s2 &quot;$line&quot;
                  in
                  = succeed "*" do
                    %span.o (
                  = succeed ":space:" do
                    %span.o [[
                  = succeed "cwd" do
                    %span.o ]]
                  = succeed ":space:" do
                    %span.o [[
                  = succeed "*" do
                    %span.o ]]
                  %span.o )
                  %span.nv cwd
                  %span.o =
                  %span.s2 &quot;${line##* }&quot;
                  ;;
                  = succeed "*" do
                    %span.o (
                  = succeed ":space:" do
                    %span.o [[
                  = succeed "txt" do
                    %span.o ]]
                  = succeed ":space:" do
                    %span.o [[
                  = succeed "*" do
                    %span.o ]]
                  %span.o )
                  %span.nv binary
                  %span.o =
                  %span.s2 &quot;${line##* }&quot;
                  ;;
                  = succeed "*/lib/*" do
                    %span.o (
                  %span.o )
                  %span.nv string
                  %span.o =
                  %span.s2 &quot;${line%% (*}&quot;
                  libraries+
                  %span.o =(
                  %span.s2 &quot;${string##* }&quot;
                  %span.o )
                  ;;
                  = succeed "*.log*" do
                    %span.o (
                  %span.o )
                  logs+
                  %span.o =(
                  %span.s2 &quot;${line##* }&quot;
                  %span.o )
                  ;;
                  = succeed "*.sock*" do
                    %span.o (
                  %span.o )
                  sockets+
                  %span.o =(
                  %span.s2 &quot;${line##* }&quot;
                  %span.o )
                  ;;
                  = succeed "*TCP*" do
                    %span.o (
                  %span.o )
                  %span.nv string
                  %span.o =
                  %span.s2 &quot;${line%% (*}&quot;
                  tcp_ports+
                  %span.o =(
                  %span.s2 &quot;${string##* }&quot;
                  %span.o )
                  ;;
                  = succeed "*" do
                    %span.o (
                  %span.o )
                  %span.nb true
                  %span.c # ignore
                  ;;
                  %span.k esac
                  %span.k done
                  \&lt; &lt;
                  %span.o> (
                  lsof -U -p
                  %span.k ${
                  %span.nv pid
                  %span.k }
                  %span.o )
                  log
                  %span.s2 &quot;    cwd: ${cwd}&quot;
                  log
                  %span.s2 &quot;    binary: ${binary}&quot;
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv logs
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;    logs:&quot;
                  array_sort_asc logs
                  array_unique logs
                  = succeed "log" do
                    %span.k for
                  in
                  %span.s2 &quot;${logs[@]}&quot;
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot;      - %s\n&quot;
                  %span.s2 &quot;${log}&quot;
                  %span.k done
                  %span.k fi
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv libraries
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;    libraries:&quot;
                  array_sort_asc libraries
                  array_unique libraries
                  = succeed "library" do
                    %span.k for
                  in
                  %span.s2 &quot;${libraries[@]}&quot;
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot;      - %s\n&quot;
                  %span.s2 &quot;${library}&quot;
                  %span.k done
                  %span.k fi
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv tcp_ports
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;    tcp_ports:&quot;
                  array_sort_asc tcp_ports
                  array_unique tcp_ports
                  = succeed "tcp_port" do
                    %span.k for
                  in
                  %span.s2 &quot;${tcp_ports[@]}&quot;
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot;      - %s\n&quot;
                  %span.s2 &quot;${tcp_port}&quot;
                  %span.k done
                  %span.k fi
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv sockets
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;    sockets:&quot;
                  array_sort_asc sockets
                  array_unique sockets
                  = succeed "socket" do
                    %span.k for
                  in
                  %span.s2 &quot;${sockets[@]}&quot;
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot;      - %s\n&quot;
                  %span.s2 &quot;${socket}&quot;
                  %span.k done
                  %span.k fi
                  %span.k fi
                  %span.k else
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;  status: not running&quot;
                  %span.k fi
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h1 Filesystem Module
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
          %tr
            %td.docs
              %h2 source_files
              %p Safely source files only if they exists and are nonempty.
              %h3 Input Parameters
              %p One or more files.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p Nonempty files given will be sourced into the calling environment.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no files are given to sources.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ source_files "$HOME/.dotfiles/scripts/functions"
            %td.code
              .highlight
                %pre
                  source_files
                  %span.o ()
                  %span.o {
                  = succeed "_file" do
                    %span.nb local
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  %span.k                   %span.nv _file
                  %span.o =
                  %span.k ${
                  %span.nv _file
                  %span.p /\~\//
                  %span.nv $HOME
                  %span.p \/
                  %span.k }
                  %span.c # Expand ~/ to full value of $HOME
                  = succeed "file_is_nonempty" do
                    %span.k if
                  %span.s2 &quot;${_file}&quot;
                  %span.k then
                  %span.k                   %span.nb source
                  %span.s2 &quot;${_file}&quot;
          %tr
            %td.docs
              %p
                TODO: figure out how to see if 'source' itself failed or simply
                returning nonzero code.
                || fail "Failed to source ${_file}."
            %td.code
              .highlight
                %pre
                  %span.k fi
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot source files as no files were given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 nonempty_files
              %p Outputs a subset of the named files that are nonempty.
              %h3 Input Parameters
              %p One or more files.
              %h3 Stream Outputs
              %p
                Each nonempty filename parameter will be printed to STDOUT of the calling
                environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no file names are given as arguments.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ nonempty_files a $HOME/.bdmsrc c
                    /Users/wayneeseguin/.bdsmrc
            %td.code
              .highlight
                %pre
                  nonempty_files
                  %span.o ()
                  %span.o {
                  = succeed "_file" do
                    %span.nb local
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  = succeed "file_is_nonempty" do
                    %span.k if
                  %span.s2 &quot;${_file}&quot;
                  %span.k then
                  %span.k                   %span.nb printf
                  %span.s2 &quot;${_file}\n&quot;
                  %span.k fi
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot return nonempty files as no files were given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                ensure
                %em> paths
                exist
              %p
                Iterates over the list of given paths, creates the directory if it
                does not exist.
              %h3 Input Parameters
              %p A list of paths to create if missing.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p Paths that were given but do not exist will be created.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no paths were given to.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ ls -a
                    . ..
                    user$ ensure_paths_exist a b c
                    user$ ls -a
                    . .. a b c
            %td.code
              .highlight
                %pre
                  ensure_paths_exist
                  %span.o ()
                  %span.o {
                  = succeed "_path" do
                    %span.nb local
                  %span.nv _paths
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _paths
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_path" do
                    %span.k for
                  in
                  %span.s2 &quot;${_paths[@]}&quot;
                  %span.k do
                  %span.k if
                  \! directory_exists
                  %span.s2 &quot;${_path}&quot;
                  %span.k then
                  = succeed "mkdir" do
                    %span.k                   \-p
                  %span.s2 &quot;${_path}&quot;
                  %span.k fi
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot ensure paths exist as no paths were given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 remove_files
              %p Removes the given files, if they exist.
              %h3 Input Parameters
              %p One or more file names/paths.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                The named files will no longer exist on the system, if they existed to begin
                with.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no files were named.
                Fails if a named file is a directory.
                Fails if a named file exists but is not a file.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ touch a b c
                    user$ ls -a
                    . .. a b c
                    user$ remove_files a b c
                    user$ ls
                    . ..
            %td.code
              .highlight
                %pre
                  remove_files
                  %span.o ()
                  %span.o {
                  = succeed "_file" do
                    %span.nb local
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  %span.k if
                  %span.o [[
                  \-f
                  %span.s2 &quot;${_file}&quot;
                  %span.o ||
                  \-L
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "rm" do
                    %span.k                   \-f
                  %span.s2 &quot;${_file}&quot;
                  %span.k elif
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot remove the file ${_file} as it is a directory.&quot;
                  %span.k elif
                  %span.o [[
                  \-e
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Unknown filesystem entity type located at ${_file}, cannot remove.&quot;
                  %span.k else
                  %span.k                   %span.nb true
                  %span.c # already gone
                  %span.k fi
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot remove files as no files were given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 remove
              %p Removes the given entries, if they exist.
              %h3 Input Parameters
              %p One or more file, directory or symlink names/paths.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                The named files will no longer exist on the system, if they existed to begin
                with.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no files were named.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ touch a
                    user$ mkdir b
                    user$ ln -s b c
                    user$ ls -a
                    . .. a b c
                    user$ remove a b c
                    user$ ls
                    . ..
            %td.code
              .highlight
                %pre
                  remove
                  %span.o ()
                  %span.o {
                  = succeed "_file" do
                    %span.nb local
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  %span.k if
                  %span.o [[
                  \-f
                  %span.s2 &quot;${_file}&quot;
                  %span.o ||
                  \-L
                  %span.s2 &quot;${_file}&quot;
                  %span.o ||
                  \-d
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "rm" do
                    %span.k                   \-rf
                  %span.s2 &quot;${_file}&quot;
                  %span.k elif
                  %span.o [[
                  \-e
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Unhandled filesystem entity type located at ${_file}, cannot remove. (File, link and directory types are handled)&quot;
                  %span.k fi
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot remove files as no files were given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 remove_paths
              %p Function Description
              %h3 Input Parameters
              %p Positional Parameter listing and descriptions.
              %h3 Stream Outputs
              %p What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
              %h3 Environmental effects
              %p What, if any, environmental side effects this function causes. 'None.' for none.
              %h3 Return Codes
              %p
                0 if ...
                1 if ...
              %h3 Failure Scenarios
              %p Fails if ...
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ {{ setup the scenario }}
                    user$ function_name {{ parameters }}
                    user$ {{ demonstrate the results}}
            %td.code
              .highlight
                %pre
                  remove_paths
                  %span.o ()
                  %span.o {
                  = succeed "_path" do
                    %span.nb local
                  %span.nv _paths
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _paths
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_path" do
                    %span.k for
                  in
                  %span.s2 &quot;${_paths[@]}&quot;
                  %span.k do
                  %span.k if
                  %span.o [[
                  \-f
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot remove the path '${_path}' as it is a file.&quot;
                  %span.k elif
                  %span.o [[
                  \-L
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "rm" do
                    %span.k                   \-f
                  %span.s2 &quot;${_path}&quot;
                  %span.k elif
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "rm" do
                    %span.k                   \-rf
                  %span.s2 &quot;${_path}&quot;
                  %span.k elif
                  %span.o [[
                  \-e
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Unknown filesystem entity type at ${_path}, cannot remove.&quot;
                  %span.k else
                  %span.k                   %span.nb true
                  %span.c # already gone
                  %span.k fi
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot remove paths as no paths were given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                ensure
                %em> files
                exist
              %p
                Iterates over the list of given files, creates the directory if it
                does not exist.
              %h3 Input Parameters
              %p A list of files to create if missing.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p files that were given but do not exist will be created.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no files were given to.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ ls -a
                    . ..
                    user$ ensure_files_exist a b c
                    user$ ls -a
                    . .. a b c
            %td.code
              .highlight
                %pre
                  ensure_files_exist
                  %span.o ()
                  %span.o {
                  = succeed "_file" do
                    %span.nb local
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  _path
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  %span.k                   %span.nv _path
                  %span.o =
                  %span.s2 &quot;${_file%\/*}&quot;
                  %span.k if
                  %span.o [[
                  \! -d
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "mkdir" do
                    %span.k                   \-p
                  %span.s2 &quot;${_path}&quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  \! -e
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "touch" do
                    %span.k                   %span.s2 &quot;${_file}&quot;
                  %span.k fi
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot ensure files exist as no files were given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                ensure
                %em> files
                are_executable
              %p Sets the executable bits on a file if it is not executable.
              %h3 Input Parameters
              %p One or more file name/paths
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p Files that were given and not executable will have their execute bits set.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if no files were given as parameters.
                Fails if one of the files given was a directory.
                Fails if one of the files given does not exist.
                Fails if one of the files paths does not exist.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ ensure_files_are_executable /etc/rc.d/postgresql
              %p
                TODO: change this to be a  fail function if one is not
                make this into make
                %em> files
                executable or some such
            %td.code
              .highlight
                %pre
                  ensure_files_are_executable
                  %span.o ()
                  %span.o {
                  = succeed "_file" do
                    %span.nb local
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  _path
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot make the file '${_file}' executable as it is a directory.&quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  \! -f
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot make the file '${_file}' executable as the file does not exist.&quot;
                  %span.k fi
                  %span.k                   %span.nv _path
                  %span.o =
                  %span.s2 &quot;${_file%\/*}&quot;
                  %span.k if
                  \!
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_path}&quot;
                  %span.o &amp;&amp;
                  \! -d
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot make the file '${_file} executable as '${_path}' does not even exist.&quot;
                  %span.k fi
                  = succeed "chmod" do
                    %span.k                   +x
                  %span.s2 &quot;${_file}&quot;
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot ensure files are executable as no files were given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 link
              %p Create a symlink from source to target.
              %h3 Input Parameters
              %p
                First parameter is the source
                Second parameter is the target
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p Symlink is created if no failure conditions are triggered.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if target exists and is a file.
                Fails if target exists and is a directory.
              %h3 Usage Examples
              %p The following usages are equivalent
              %pre
                %code
                  :preserve
                    user$ link from /home/user/.vim/vimrc to /home/user/.vimrc
                    user$ link /home/user/.vim/vimrc to /home/user/.vimrc
                    user$ link /home/user/.vim/vimrc /home/user/.vimrc
            %td.code
              .highlight
                %pre
                  link
                  %span.o ()
                  %span.o {
                  = succeed "token" do
                    %span.nb local
                  _source _target
                  %span.nv _force_flag
                  = succeed "0" do
                    %span.o =
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${token}&quot;
                  in
                  to
                  %span.o )
                  %span.nv _target
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  from
                  %span.o )
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  \--force
                  %span.o )
                  %span.nv _force_flag
                  = succeed "1" do
                    %span.o =
                  ;;
                  *
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_source}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _source
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.k elif
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _target
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.k fi
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o ((
                  %span.nv _force_flag
                  %span.o ==
                  1
                  %span.o ))
                  %span.k then
                  = succeed "remove" do
                    %span.k                   %span.s2 &quot;${_target}&quot;
                  %span.k fi
          %tr
            %td.docs
              %p TODO: What should we do if files already exist?
            %td.code
              .highlight
                %pre
                  %span.k if
                  %span.o [[
                  \-f
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot link ${_source} to ${_target} exists and is a file!&quot;
                  %span.k elif
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot link ${_source} to ${_target} exists and is a directory&quot;
                  %span.k else
                  = succeed "ensure_paths_exist" do
                    %span.k                   %span.s2 &quot;${_target%\/*}&quot;
                  ln -fs
                  %span.s2 &quot;${_source}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 move_directory
              %p
                Moves a directory from one location to another.
                (This is also used to rename a directory.)
              %h3 Input Parameters
              %p
                The first parameter is the source directory name
                The second parameter is the target directory name
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p If successful, a directory is renamed (moved).
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if the source directory is not specified.
                Fails if the target directory is not specified.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ move_directory "freetds-0.91rc"* to "freetds-0.91"
            %td.code
              .highlight
                %pre
                  move_directory
                  %span.o ()
                  %span.o {
                  = succeed "_source" do
                    %span.nb local
                  _target _mode _owner
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  ;
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  ;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${token}&quot;
                  in
                  to
                  %span.o )
                  %span.nv _target
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  
                  from
                  %span.o )
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  
                  mode
                  %span.o )
                  %span.nv _mode
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  
                  owner
                  %span.o )
                  %span.nv _owner
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  
                  *
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_source}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _source
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.k elif
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _target
                  %span.o =
                  %span.s2 &quot;$token&quot;
          %tr
            %td.docs
              %p When we have a target we are done.
            %td.code
              .highlight
                %pre
                  %span.nb break
                  %span.nb                   %span.k fi
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_source}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot move file as the source and target must be specified. &quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot move file as the source and target must be specified. &quot;
                  %span.k fi
                  = succeed "mv" do
                    %span.k                   %span.s2 &quot;${_source}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_mode:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "chmod" do
                    %span.k                   \-R
                  %span.s2 &quot;${_mode}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_owner:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "chown" do
                    %span.k                   \-R
                  %span.s2 &quot;${_owner}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 move_file
              %p
                Moves a file from one location to another.
                (This is also used to rename a file.)
              %h3 Input Parameters
              %p
                The first parameter is the source file name
                The second parameter is the target file name
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p If successful, a file is renamed (moved).
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if the source file is not specified.
                Fails if the target file is not specified.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ move_file "$HOME/.bashrc" to "$HOME/.bashrc.orig"
            %td.code
              .highlight
                %pre
                  move_file
                  %span.o ()
                  %span.o {
                  = succeed "_source" do
                    %span.nb local
                  _target _mode _owner
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  ;
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  ;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${token}&quot;
                  in
                  to
                  %span.o )
                  %span.nv _target
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  from
                  %span.o )
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  mode
                  %span.o )
                  %span.nv _mode
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  owner
                  %span.o )
                  %span.nv _owner
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  
                  *
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_source}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _source
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.k elif
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _target
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.nb break
                  %span.nb                   %span.k fi
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_source}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot move file as the source and target must be specified. &quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot move file as the source and target must be specified. &quot;
                  %span.k fi
                  = succeed "mv" do
                    %span.k                   %span.s2 &quot;${_source}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_mode:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "chmod" do
                    %span.k                   %span.s2 &quot;${_mode}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_owner:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "chown" do
                    %span.k                   %span.s2 &quot;${_owner}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 copy_file
              %p
                Copys a file from one location to another.
                (This is also used to rename a file.)
              %h3 Input Parameters
              %p
                The first parameter is the source file name
                The second parameter is the target file name
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p If successful, a file is renamed (copyd).
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if the source file is not specified.
                Fails if the target file is not specified.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ copy_file "$HOME/.bashrc" to "$HOME/.bashrc.orig"
            %td.code
              .highlight
                %pre
                  copy_file
                  %span.o ()
                  %span.o {
                  = succeed "_source" do
                    %span.nb local
                  _target
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  ;
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${token}&quot;
                  in
                  to
                  %span.o )
                  %span.nv _target
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  from
                  %span.o )
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  mode
                  %span.o )
                  %span.nv _mode
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  owner
                  %span.o )
                  %span.nv _owner
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  *
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_source:-}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _source
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.nb shift
                  %span.nb                   %span.k elif
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_target:-}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _target
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.nb break
                  %span.nb                   %span.k fi
                  ;;
                  %span.k esac
                  %span.k done
                  = succeed "cp" do
                    %span.k                   %span.s2 &quot;${_source}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_mode:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "chmod" do
                    %span.k                   %span.s2 &quot;${_mode}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_owner:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "chown" do
                    %span.k                   %span.s2 &quot;${_owner}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                copy
                %em> files
                to
              %p depreciated, please use copy_files with the 'to' specifier instead
            %td.code
              .highlight
                %pre
                  copy_files_to
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _file
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Path was not given as the first parameter.&quot;
                  %span.k else
                  %span.k                   %span.nb shift
                  %span.nb                   %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;No files were given in order to copy them into ${_path}.&quot;
                  %span.k fi
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;copy_files_to is depreciated, please use copy_files with the 'to' specifier instead&quot;
                  ensure_paths_exist
                  %span.s2 &quot;${_path}&quot;
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  = succeed "file_is_missing" do
                    %span.k if
                  %span.s2 &quot;${_file}&quot;
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot copy file ${_file} to ${_path} as the file does not exist.&quot;
                  %span.k else
                  = succeed "cp" do
                    %span.k                   %span.s2 &quot;${_file}&quot;
                  %span.s2 &quot;${_path}/${_file}&quot;
                  %span.k fi
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 copy_files
              %p Copys a given list of files into the named path.
              %h3 Input Parameters
              %p
                The first parameter is the path to copy the files into.
                Remaining parameters are the file name/path list.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p If successful, all named files are copied into the target path.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if no target path is given.
                Fails if no files are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ copy_files "$HOME/.bashrc" "$HOME/.bash_profile" \
                            to "$HOME/backup"
            %td.code
              .highlight
                %pre
                  copy_files
                  %span.o ()
                  %span.o {
                  = succeed "_source" do
                    %span.nb local
                  _target _file
                  %span.nv _force_flag
                  = succeed "0" do
                    %span.o =
                  %span.nv _files
                  %span.o =()
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${token}&quot;
                  in
                  to
                  %span.o )
                  %span.nv _target
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  from
                  %span.o )
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  \--force
                  %span.o )
                  %span.nv _force_flag
                  = succeed "1" do
                    %span.o =
                  ;;
                  
                  *
                  %span.o )
                  _files+
                  %span.o =(
                  %span.s2 &quot;${token}&quot;
                  %span.o )
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot copy files as no target path was given (eg. copy_files ... to {path}).&quot;
                  %span.k fi
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot copy files as no files were given to copy.&quot;
                  %span.k fi
                  = succeed "ensure_paths_exist" do
                    %span.k                   %span.s2 &quot;${_target}&quot;
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  = succeed "file_is_missing" do
                    %span.k if
                  %span.s2 &quot;${_file}&quot;
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot copy file ${_file} to ${_target} as the file does not exist.&quot;
                  %span.k else
                  %span.k if
                  %span.o ((
                  %span.nv _force_flag
                  %span.o ==
                  1
                  %span.o ))
                  %span.k then
                  = succeed "cp" do
                    %span.k                   \-f
                  %span.s2 &quot;${_file}&quot;
                  %span.s2 &quot;${_target}/${_file//*\/}&quot;
                  %span.k else
                  = succeed "cp" do
                    %span.k                   %span.s2 &quot;${_file}&quot;
                  %span.s2 &quot;${_target}/${_file//*\/}&quot;
                  %span.k fi
                  %span.k fi
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2
                copy
                %em> directories
                to
              %p Copys a given list of directories into the named path.
              %h3 Input Parameters
              %p
                The first parameter is the path to copy the directorys into.
                Remaining parameters are the directory name/path list.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p If successful, all named directories are copied into the target path.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if no target path is given.
                Fails if no directories are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ copy_directories_to "$HOME/backup/" "$HOME/bin" "$HOME/projects"
            %td.code
              .highlight
                %pre
                  copy_directories_to
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _directory
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Path was not given as the first parameter.&quot;
                  %span.k else
                  %span.k                   %span.nb shift
                  %span.nb                   %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _directories
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _directories
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;No directories were given in order to copy them into ${_path}.&quot;
                  %span.k fi
                  = succeed "ensure_paths_exist" do
                    %span.k                   %span.s2 &quot;${_path}&quot;
                  = succeed "_directory" do
                    %span.k for
                  in
                  %span.s2 &quot;${_directories[@]}&quot;
                  %span.k do
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${_directory}&quot;
                  %span.k then
                  = succeed "cp" do
                    %span.k                   \-Rf
                  %span.s2 &quot;${_directory}&quot;
                  %span.s2 &quot;${_path}/&quot;
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot copy directory ${_directory} to ${_path} as the directory '${_directory}' does not exist (in '$PWD').&quot;
                  %span.k fi
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 copy_directories to
              %p Copys a given list of directories into the named path.
              %h3 Input Parameters
              %p
                The first parameter is the path to copy the directorys into.
                Remaining parameters are the directory name/path list.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p If successful, all named directories are copied into the target path.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if no target path is given.
                Fails if no directories are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ copy_directories to "$HOME/backup/" "$HOME/bin" "$HOME/projects"
            %td.code
              .highlight
                %pre
                  copy_directories
                  %span.o ()
                  %span.o {
                  = succeed "_source" do
                    %span.nb local
                  _target _directory
                  %span.nv _force_flag
                  = succeed "0" do
                    %span.o =
                  %span.nv _directories
                  %span.o =()
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${token}&quot;
                  in
                  to
                  %span.o )
                  %span.nv _target
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  from
                  %span.o )
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  \--force
                  %span.o )
                  %span.nv _force_flag
                  = succeed "1" do
                    %span.o =
                  ;;
                  
                  *
                  %span.o )
                  _directories+
                  %span.o =(
                  %span.s2 &quot;${token}&quot;
                  %span.o )
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot copy directories as no target path was given (eg. copy_directories ... to {path}).&quot;
                  %span.k fi
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _directories
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot copy directories as no directories were given to copy.&quot;
                  %span.k fi
                  = succeed "ensure_paths_exist" do
                    %span.k                   %span.s2 &quot;${_target}&quot;
                  = succeed "_directory" do
                    %span.k for
                  in
                  %span.s2 &quot;${_directories[@]}&quot;
                  %span.k do
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${_directory}&quot;
                  %span.k then
                  = succeed "cp" do
                    %span.k                   \-Rf
                  %span.s2 &quot;${_directory}&quot;
                  %span.s2 &quot;${_target}/&quot;
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot copy directory ${_directory} to ${_target} as the directory '${_directory}' does not exist (in '$PWD').&quot;
                  %span.k fi
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 copy_directory
              %p
                Copys a directory from one location to another.
                (This is also used to rename a directory.)
              %h3 Input Parameters
              %p
                The first parameter is the source directory name
                The second parameter is the target directory name
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p If successful, a directory is renamed (copyd).
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if the source directory is not specified.
                Fails if the target directory is not specified.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ copy_directory "freetds-0.91rc"* to "freetds-0.91"
            %td.code
              .highlight
                %pre
                  copy_directory
                  %span.o ()
                  %span.o {
                  = succeed "_source" do
                    %span.nb local
                  _target
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${token}&quot;
                  in
                  to
                  %span.o )
                  %span.nv _target
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  from
                  %span.o )
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  *
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_source}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _source
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.nb shift
                  %span.nb                   %span.k elif
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _target
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.nb break
                  %span.nb                   %span.k fi
                  ;;
                  %span.k esac
                  %span.k done
                  = succeed "cp" do
                    %span.k                   \-Rf
                  %span.s2 &quot;${_source}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                move
                %em> files
                to
              %p Moves a given list of files into the named path.
              %h3 Input Parameters
              %p
                The first parameter is the path to move the files into.
                Remaining parameters are the file name/path list.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p If successful, all named files are copied into the target path.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if no target path is given.
                Fails if no files are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ move_files_to "$HOME/backup" "$HOME/.bashrc" "$HOME/.bash_profile"
            %td.code
              .highlight
                %pre
                  move_files_to
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _file
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Path was not given as the first parameter.&quot;
                  %span.k else
                  %span.k                   %span.nb shift
                  %span.nb                   %span.k fi
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;DEPRECIATED, use 'move_files ... to _path' instead&quot;
                  %span.nb local
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;No files given in order to chmod ${_permissions} them.&quot;
                  %span.k fi
                  = succeed "ensure_paths_exist" do
                    %span.k                   %span.s2 &quot;${_path}&quot;
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  = succeed "file_exists" do
                    %span.k if
                  %span.s2 &quot;${_file}&quot;
                  %span.k then
                  = succeed "mv" do
                    %span.k                   %span.s2 &quot;${_file}&quot;
                  %span.s2 &quot;${_path}/${_file}&quot;
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot move file ${_file} to ${_path} as the file does not exist.&quot;
                  %span.k fi
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 move_files
              %p Moves a given list of files into the named path.
              %h3 Input Parameters
              %p
                Parameters are file name/path for one or more files
                Target directory is specified as 'to {{path}}'
                Optional source directory is specified as 'from {{path}}'
                Optional force flag '--force' may be specified
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p If successful, all named files are copied into the target path.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if no target path is given.
                Fails if no files are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$
              %p Alternatively,
              %pre
                %code
                  :preserve
                    user$ move_files ".bashrc" ".bash_profile" from "$HOME" to "$HOME/backup"
            %td.code
              .highlight
                %pre
                  move_files
                  %span.o ()
                  %span.o {
                  = succeed "_source" do
                    %span.nb local
                  _target _file
                  %span.nv _force_flag
                  = succeed "0" do
                    %span.o =
                  %span.nv _files
                  %span.o =()
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${token}&quot;
                  in
                  to
                  %span.o )
                  %span.nv _target
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  from
                  %span.o )
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  \--force
                  %span.o )
                  %span.nv _force_flag
                  = succeed "1" do
                    %span.o =
                  ;;
                  
                  *
                  %span.o )
                  _files+
                  %span.o =(
                  %span.s2 &quot;${token}&quot;
                  %span.o )
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_source}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _file
                  %span.o =
                  %span.s2 &quot;${_source}/${_file}&quot;
                  %span.k fi
                  = succeed "file_exists" do
                    %span.k if
                  %span.s2 &quot;${_file}&quot;
                  %span.k then
                  %span.k if
                  %span.o ((
                  %span.nv _force_flag
                  %span.o ==
                  1
                  %span.o ))
                  %span.k then
                  = succeed "mv" do
                    %span.k                   \-f
                  %span.s2 &quot;${_file}&quot;
                  %span.s2 &quot;${_target}/${_file//*\/}&quot;
                  %span.k else
                  = succeed "mv" do
                    %span.k                   %span.s2 &quot;${_file}&quot;
                  %span.s2 &quot;${_target}/${_file//*\/}&quot;
                  %span.k fi
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot move file ${_file} to ${_path} as the file does not exist.&quot;
                  %span.k fi
                  %span.k done
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot move files to '${_target}' as the directory does not exist&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot move files as no files were given to move.&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot move files as no target path was given (eg. move_files ... to {path}).&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 chown_files
              %p Change ownership of a list of files.
              %h3 Input Parameters
              %p
                First parameter is the new owner[:group] of the files.
                Remaining parameters are the file names/paths.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no new owner[:group] was specified.
                Fails if no list of files was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ chown_files $USER "$HOME/.bashrc" "$HOME/.bash_profile"
            %td.code
              .highlight
                %pre
                  chown_files
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _identity
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _file
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_identity}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;user[:group] not given as the first parameter.&quot;
                  %span.k else
                  %span.k                   %span.nb shift
                  %span.nb                   %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;No paths given to chmod ${_permissions}.&quot;
                  %span.k fi
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  = succeed "file_exists" do
                    %span.k if
                  %span.s2 &quot;${_file}&quot;
                  %span.k then
                  = succeed "chown" do
                    %span.k                   \-R
                  %span.k ${
                  %span.nv _identity
                  %span.k }
                  %span.s2 &quot;${_file}&quot;
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot chown file ${_file} to ${_identity} as the file does not exist.&quot;
                  %span.k fi
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 chown_paths
              %p Change ownership of a list of paths.
              %h3 Input Parameters
              %p
                First parameter is the new owner[:group] of the paths.
                Remaining parameters are the path names/paths.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no new owner[:group] was specified.
                Fails if no list of paths was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ chown_paths $USER "$HOME" "/usr/local"
            %td.code
              .highlight
                %pre
                  chown_paths
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _identity
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _path
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_identity}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;user[:group] not given as the first parameter.&quot;
                  %span.k else
                  %span.k                   %span.nb shift
                  %span.nb                   %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _paths
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _paths
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;No paths given to chmod ${_permissions}.&quot;
                  %span.k fi
                  = succeed "_path" do
                    %span.k for
                  in
                  %span.s2 &quot;${_paths[@]}&quot;
                  %span.k do
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${_path}&quot;
                  %span.k then
                  = succeed "chown" do
                    %span.k                   %span.k ${
                  %span.nv _identity
                  %span.k }
                  %span.s2 &quot;${_path}&quot;
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot chown path ${_path} to ${_identity} as the directory does not exist.&quot;
                  %span.k fi
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2
                chown
                %em> paths
                recursively
              %p Change ownership of a list of paths, recursively.
              %h3 Input Parameters
              %p
                First parameter is the new owner[:group] of the paths.
                Remaining parameters are the path names/paths.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no new owner[:group] was specified.
                Fails if no list of paths was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ chown_paths_recursively $USER "$HOME" "/usr/local"
            %td.code
              .highlight
                %pre
                  chown_paths_recursively
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _identity
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _path
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_identity}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;user[:group] not given as the first parameter!!&quot;
                  %span.k else
                  %span.k                   %span.nb shift
                  %span.nb                   %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _paths
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _paths
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;No paths given to chmod ${_permissions}.&quot;
                  %span.k fi
                  = succeed "_path" do
                    %span.k for
                  in
                  %span.s2 &quot;${_paths[@]}&quot;
                  %span.k do
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${_path}&quot;
                  %span.k then
                  = succeed "chown" do
                    %span.k                   \-R
                  %span.k ${
                  %span.nv _identity
                  %span.k }
                  %span.s2 &quot;${_path}&quot;
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot recursively chown ${_path} to ${_identity} as the directory does not exist.&quot;
                  %span.k fi
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 chmod_files
              %p Change ownership of a list of files.
              %h3 Input Parameters
              %p
                First parameter is the new owner[:group] of the files.
                Remaining parameters are the file names/files.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no new owner[:group] was specified.
                Fails if no list of files was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ chmod_files $USER "$HOME" "/usr/local"
            %td.code
              .highlight
                %pre
                  chmod_files
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _permissions
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _file _message
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_permissions}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb local
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  = succeed "file_exists" do
                    %span.k if
                  %span.s2 &quot;${_file}&quot;
                  %span.k then
                  = succeed "chmod" do
                    %span.k                   %span.k ${
                  %span.nv _permissions
                  %span.k }
                  %span.s2 &quot;${_file}&quot;
                  %span.k else
                  %span.k                   %span.nv _message
                  %span.o =(
                  %span.s2 &quot;Cannot chmod file ${_file} to ${_permissions}&quot;
                  %span.s2 &quot; as the file does not exist.&quot;
                  %span.o )
                  error
                  %span.s2 &quot;${_message[*]}&quot;
                  %span.k fi
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;No files given to chmod ${_permissions}.&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Permissions not given as the first parameter!!&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 chmod_paths
              %p Change ownership of a list of paths.
              %h3 Input Parameters
              %p
                First parameter is the new owner[:group] of the paths.
                Remaining parameters are the path names/paths.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no new owner[:group] was specified.
                Fails if no list of paths was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ chmod_paths $USER "$HOME" "/usr/local"
            %td.code
              .highlight
                %pre
                  chmod_paths
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _permissions
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  _path _message
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_permissions}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb local
                  %span.nv _paths
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _paths
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_path" do
                    %span.k for
                  in
                  %span.s2 &quot;${_paths[@]}&quot;
                  %span.k do
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${_path}&quot;
                  %span.k then
                  = succeed "chmod" do
                    %span.k                   %span.k ${
                  %span.nv _permissions
                  %span.k }
                  %span.s2 &quot;${_path}&quot;
                  %span.k else
                  %span.k                   %span.nv _message
                  %span.o =(
                  %span.s2 &quot;Cannot chmod directory ${_path} to ${_permissions}&quot;
                  %span.s2 &quot; as the directory does not exist.&quot;
                  %span.o )
                  error
                  %span.s2 &quot;${_message[*]}&quot;
                  %span.k fi
                  %span.k done
                  %span.k else
                  %span.k                   %span.nv _message
                  %span.o =(
                  %span.s2 &quot;Cannot chmod_paths as no paths were given in &quot;
                  %span.s2 &quot;order to change permissions to ${_permissions}.&quot;
                  %span.o )
                  fail
                  %span.s2 &quot;${_message[*]}&quot;
                  %span.k fi
                  %span.k else
                  %span.k                   %span.nv _message
                  %span.o =(
                  %span.s2 &quot;Cannot chmod_paths as the permissions were &quot;
                  %span.s2 &quot;not given as the first parameter!!&quot;
                  %span.o )
                  fail
                  %span.s2 &quot;${_message[*]}&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                chmod
                %em> paths
                recursively
              %p Change ownership of a list of paths, recursively.
              %h3 Input Parameters
              %p
                First parameter is the new owner[:group] of the paths.
                Remaining parameters are the path names/paths.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no new owner[:group] was specified.
                Fails if no list of paths was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ chmod_paths_recursively $USER "$HOME" "/usr/local"
            %td.code
              .highlight
                %pre
                  chmod_paths_recursively
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _permissions
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _path _message
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_permissions}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb local
                  %span.nv _paths
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _paths
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_path" do
                    %span.k for
                  in
                  %span.s2 &quot;${_paths[@]}&quot;
                  %span.k do
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${_path}&quot;
                  %span.k then
                  = succeed "chmod" do
                    %span.k                   \-R
                  %span.k ${
                  %span.nv _permissions
                  %span.k }
                  %span.s2 &quot;${_path}&quot;
                  %span.k else
                  %span.k                   %span.nv _message
                  %span.o =(
                  %span.s2 &quot;Cannot chmod directory ${_path} to ${_permissions} &quot;
                  %span.s2 &quot;as the directory does not exist.&quot;
                  %span.o )
                  error
                  %span.s2 &quot;${_message[*]}&quot;
                  %span.k fi
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;No paths given to chmod ${_permissions}.&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Permissions not given as the first parameter!!&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 enter
              %p
                Changes the current working directory ($PWD) to the given directory with
                sanity checks.
              %h3 Input Parameters
              %p First parameter is the directory to change into.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                The current working directory (PWD) will become the given directory if
                successful.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no directory was given.
                Fails if the given directory does not exist.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ enter "/usr/local/src"
            %td.code
              .highlight
                %pre
                  enter
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  \!
                  %span.nb builtin cd
                  %span.s2 &quot;${_path}&quot;
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;There was an error ($?) while entering the directory '${_path}'.&quot;
                  %span.k fi
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot enter the directory '${_path}' as it does not exist.&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot enter a directory as no directory was given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 hash_file
              %p Set and get key/value pairs from a given has file.
              %h3 Input Parameters
              %p
                The first parameter is the file name/path for the hash file.
                The second parameter is the key name.
                The third (optional) parameter is the value to assign to the given key.
              %h3 Stream Outputs
              %p The value of the key retrieved is printed if no value parameter was given.
              %h3 Environmental effects
              %p
                If a value parameter was given the key=value pair is written to the named
                hash file.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no file name/path was provided.
                Fails if no key name was given.
                Fails if the file path does not exist.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ hash_file /usr/local/bdsm/extensions/core/config/defaults website_url
                    https://bdsm.beginrescueend.com/
            %td.code
              .highlight
                %pre
                  hash_file
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _message
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;File path/name not given.\n =&gt; Usage: $0 &lt;filename&gt; &lt;key&gt; [value]&quot;
                  %span.k else
                  %span.k                   %span.nb shift
                  %span.nb                   %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _key
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_key}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Key not given.\n =&gt; Usage: $0 &lt;filename&gt; &lt;key&gt; [value]&quot;
                  %span.k else
                  %span.k                   %span.nb shift
                  %span.nb                   %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _path
                  %span.o =
                  = succeed "dirname" do
                    %span.k $(
                  %span.s2 &quot;${_file}&quot;
                  %span.k )
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "ensure_files_exist" do
                    %span.k                   %span.s2 &quot;$_file&quot;
                  %span.k else
                  %span.k                   %span.nv _message
                  %span.o =(
                  %span.s2 &quot;Cannot access the database file '${_file}' &quot;
                  %span.s2 &quot;as the directory '${_file%\/*}' does not exist.&quot;
                  %span.o )
                  error
                  %span.s2 &quot;{$_message[*]}&quot;
                  %span.k fi
                  %span.k                   %span.nv value
                  %span.o =
                  %span.s2 &quot;$*&quot;
                  %span.k case
                  %span.s2 &quot;$value&quot;
                  in
                  = succeed "|delete" do
                    %span.nb unset
                  %span.o )
                  sed -i.tmp
                  %span.s2 &quot;s#^${_key}=.*\$##&quot;
                  %span.s2 &quot;${_file}&quot;
                  ;;
                  *
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${value}&quot;
                  %span.o ]]
                  %span.k then
                  %span.c # get
                  awk -F
                  %span.o =
                  %span.s1 '/^'
                  %span.s2 &quot;${_key}&quot;
                  %span.s1 '=/{print $2}'
                  %span.s2 &quot;$_file&quot;
                  %span.k else
                  %span.c # set
                  %span.k if
                  \! awk -F
                  %span.o =
                  %span.s2 &quot;/^'&quot;
                  %span.k ${
                  %span.nv _key
                  %span.k }
                  %span.s2 &quot;'=/{print $2}&quot;
                  %span.s2 &quot;${_file}&quot;
                  \&gt;/dev/null 2&gt;&amp;1
                  %span.k then
                  %span.k                   %span.nb echo
                  %span.s2 &quot;${_key}=$value&quot;
                  \&gt;&gt;
                  %span.s2 &quot;${_file}&quot;
                  %span.k else
                  %span.c # overwrite
                  sed -i.tmp
                  %span.s2 &quot;s#^${_key}=.*\$#${_key}=$value#&quot;
                  %span.s2 &quot;${_file}&quot;
                  %span.k fi
                  %span.k fi
                  ;;
                  %span.k esac
                  %span.o }
          %tr
            %td.docs
              %h2
                file
                %em> is
                executable
              %p Check if a file name/path is executable.
              %h3 Input Parameters
              %p First parameter is a file name/path.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the named file is executable.
                1 if the named file is not executable or does not exist.
              %h3 Failure Scenarios
              %p Fails if no file name/path was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ file_is_executable /bin/bash
                    user$ echo $?
                    0
                    
                    user$ file_is_executable /bin/asdfasdf
                    user$ echo $?
                    1
            %td.code
              .highlight
                %pre
                  file_is_executable
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-x
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check if a file is executable as no file path/name was given&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 file_exists
              %p Check if a file name/path exists.
              %h3 Input Parameters
              %p First parameter is a file name/path.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the named file exists.
                1 if the named file does not exist or does not exist.
              %h3 Failure Scenarios
              %p Fails if no file name/path was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ file_exists /bin/bash
                    user$ echo $?
                    0
                    
                    user$ file_exists /bin/asdfasdf
                    user$ echo $?
                    1
            %td.code
              .highlight
                %pre
                  file_exists
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-f
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check to see if a file exists as no file name/path was given&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                file
                %em> is
                nonempty
              %p Check if a file name/path is nonempty.
              %h3 Input Parameters
              %p First parameter is a file name/path.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the named file is nonempty.
                1 if the named file is empty or does not exist.
              %h3 Failure Scenarios
              %p Fails if no file name/path was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ file_is_nonempty /bin/bash
                    user$ echo $?
                    0
                    
                    user$ file_is_nonempty /bin/asdfasdf
                    user$ echo $?
                    1
            %td.code
              .highlight
                %pre
                  file_is_nonempty
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;When checking whether the file '${_file}' is nonempty, a directory was found in its place.&quot;
                  %span.k else
                  %span.k if
                  %span.o [[
                  \-s
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check if file is nonempty as no file path/name was given&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                file
                %em> is
                empty
              %p Check if a file name/path is empty.
              %h3 Input Parameters
              %p First parameter is a file name/path.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the named file is empty.
                1 if the named file is not empty or does not exist.
              %h3 Failure Scenarios
              %p Fails if no file name/path was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ file_is_empty /bin/bash
                    user$ echo $?
                    1
                    
                    user$ file_is_empty /bin/asdfasdf
                    user$ echo $?
                    0
            %td.code
              .highlight
                %pre
                  file_is_empty
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-f
                  %span.s2 &quot;${_file}&quot;
                  %span.o &amp;&amp;
                  \! -s
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check if a file is empty as no file path/name was given&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                file
                %em> is
                missing
              %p Check if a file name/path is missing.
              %h3 Input Parameters
              %p First parameter is a file name/path.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the named file is missing.
                1 if the named file is not missing or does not exist.
              %h3 Failure Scenarios
              %p Fails if no file name/path was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ file_is_missing /bin/bash
                    user$ echo $?
                    1
                    
                    user$ file_is_missing /bin/asdfasdf
                    user$ echo $?
                    0
            %td.code
              .highlight
                %pre
                  file_is_missing
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \! -f
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check if file is missing as no file path/name was given&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                file
                %em> is
                empty
                %em> or
                missing
              %p Check if a file name/path is empty or missing.
              %h3 Input Parameters
              %p First parameter is a file name/path.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the named file is empty or missing.
                1 if the named file exists or is nonempty.
              %h3 Failure Scenarios
              %p Fails if no file name/path was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ file_is_missing /bin/bash
                    user$ echo $?
                    1
                    
                    user$ file_is_missing /bin/asdfasdf
                    user$ echo $?
                    0
            %td.code
              .highlight
                %pre
                  file_is_empty_or_missing
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \! -f
                  %span.s2 &quot;${_file}&quot;
                  %span.o ||
                  \! -s
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check if file is empty or missing as no file path/name was given&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 file_contains()
              %p Checks if a named file contains a given string/unix regexp pattern.
              %h3 Input Parameters
              %p
                First parameter is the file name/path.
                Second parameter is the pattern to match.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the given file contains the given pattern.
                1 if the given file does not contain the given pattern.
              %h3 Failure Scenarios
              %p
                Fails if the file path/name was not given
                Fails if the pattern is not given.
                Fails if the file path/name given either does not exist or is not a file.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat "$HOME/test"
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    
                    modules filesystem
                    
                    if file_contains "$HOME/.bdsmrc" ".*w00t.*"
                    then
                      echo "w00t! "
                    else
                      echo "no w00t :("
                    fi
            %td.code
              .highlight
                %pre
                  file_contains
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _message
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb local
                  %span.nv _pattern
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_pattern}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-f
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "grep" do
                    %span.k if
                  %span.s2 &quot;${_pattern}&quot;
                  %span.s2 &quot;${_file}&quot;
                  \&gt;/dev/null 2&gt;&amp;1
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  %span.k                   %span.nv _message
                  %span.o =(
                  %span.s2 &quot;First parameter must be a file, '${_file}'&quot;
                  %span.s2 &quot; does not appear to be a file.&quot;
                  %span.o )
                  fail
                  %span.s2 &quot;${_message[*]}&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;String pattern for search was not given!&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;File path/name was not given!&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 symlink_exists
              %p Check if a symlink name/path exists.
              %h3 Input Parameters
              %p First parameter is a symlink name/path.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the named symlink exists.
                1 if the named symlink does not exist or does not exist.
              %h3 Failure Scenarios
              %p Fails if no symlink name/path was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ symlink_exists /usr/local/bin/bdsm
                    user$ echo $?
                    0
                    
                    user$ symlink_exists /bin/asdfasdf
                    user$ echo $?
                    1
            %td.code
              .highlight
                %pre
                  symlink_exists
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-L
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check if symlink exists as no path/name was given&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 directory_exists
              %p Check if a directory name/path exists.
              %h3 Input Parameters
              %p First parameter is a directory name/path.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the named directory exists.
                1 if the named directory does not exist or does not exist.
              %h3 Failure Scenarios
              %p Fails if no directory name/path was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ directory_exists /usr/local/bin/bdsm
                    user$ echo $?
                    0
                    
                    user$ directory_exists /bin/asdfasdf
                    user$ echo $?
                    1
            %td.code
              .highlight
                %pre
                  directory_exists
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _directory
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_directory}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;$_directory&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check if directory exists as no name/path was given&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 function_name
              %p Function Description
              %h3 Input Parameters
              %p Positional Parameter listing and descriptions.
              %h3 Stream Outputs
              %p What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
              %h3 Environmental effects
              %p What, if any, environmental side effects this function causes. 'None.' for none.
              %h3 Return Codes
              %p
                0 if ...
                1 if ...
              %h3 Failure Scenarios
              %p Fails if ...
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ {{ setup the scenario }}
                    user$ function_name {{ parameters }}
                    user$ {{ demonstrate the results}}
            %td.code
              .highlight
                %pre
                  directories_in
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "find" do
                    %span.k if
                  %span.s2 &quot;${_path}&quot;
                  \-mindepth 1 -maxdepth 1 -type d
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;'${_path}' is not a directory!&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Directory name/path was not given!&quot;
                  %span.k fi
                  %span.o }
                  directories_in_matching
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.nv _pattern
                  %span.o =
                  %span.s2 &quot;${2:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_pattern}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "find" do
                    %span.k if
                  %span.s2 &quot;${_path}&quot;
                  \-mindepth 1 -maxdepth 1 -type d
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;'${_path}' is not a directory!&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;'${_path}' is not a directory!&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Directory name/path was not given!&quot;
                  %span.k fi
                  %span.o }
                  directories_under
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "find" do
                    %span.k if
                  %span.s2 &quot;${_path}&quot;
                  \-mindepth 1 -type d
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;'${_path}' is not a directory!&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Directory name/path was not given!&quot;
                  %span.k fi
                  %span.o }
                  directories_under_matching
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb local
                  %span.nv _pattern
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_pattern}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "find" do
                    %span.k if
                  %span.s2 &quot;${_path}&quot;
                  \-mindepth 1 -iname
                  %span.s2 &quot;${_pattern}&quot;
                  \-type d
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;'${_path}' is not a directory!&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;'${_path}' is not a directory!&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Directory name/path was not given!&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 function_name
              %p Function Description
              %h3 Input Parameters
              %p Positional Parameter listing and descriptions.
              %h3 Stream Outputs
              %p What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
              %h3 Environmental effects
              %p What, if any, environmental side effects this function causes. 'None.' for none.
              %h3 Return Codes
              %p
                0 if ...
                1 if ...
              %h3 Failure Scenarios
              %p Fails if ...
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ {{ setup the scenario }}
                    user$ function_name {{ parameters }}
                    user$ {{ demonstrate the results}}
            %td.code
              .highlight
                %pre
                  files_in
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "find" do
                    %span.k if
                  %span.s2 &quot;${_path}&quot;
                  \-mindepth 1 -maxdepth 1 -type f
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;'${_path}' is not a directory!&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Directory name/path was not given!&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 function_name
              %p Function Description
              %h3 Input Parameters
              %p Positional Parameter listing and descriptions.
              %h3 Stream Outputs
              %p What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
              %h3 Environmental effects
              %p What, if any, environmental side effects this function causes. 'None.' for none.
              %h3 Return Codes
              %p
                0 if ...
                1 if ...
              %h3 Failure Scenarios
              %p Fails if ...
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ {{ setup the scenario }}
                    user$ function_name {{ parameters }}
                    user$ {{ demonstrate the results}}
            %td.code
              .highlight
                %pre
                  files_under
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "find" do
                    %span.k if
                  %span.s2 &quot;${_path}&quot;
                  \-mindepth 1 -type f
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;'${_path}' is not a directory!&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Directory name/path was not given!&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                files
                %em> in
                path_matching
              %p Find all files in given path matching a given name glob pattern.
              %h3 Input Parameters
              %p
                First parameter is the path to search in
                Second parameter is the pattern to match in
              %h3 Stream Outputs
              %p What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
              %h3 Environmental effects
              %p What, if any, environmental side effects this function causes. 'None.' for none.
              %h3 Return Codes
              %p
                0 if ...
                1 if ...
              %h3 Failure Scenarios
              %p Fails if ...
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ files_in_path_matching ...
            %td.code
              .highlight
                %pre
                  files_in_path_matching
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb                   %span.nv _pattern
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb                   %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_pattern}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "find" do
                    %span.k if
                  %span.s2 &quot;${_path}&quot;
                  \-mindepth 1 -iname
                  %span.s2 &quot;${_pattern}&quot;
                  \-type f
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot find files as a filename or pattern was not given.&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;'${_path}' is not a directory!&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Directory name/path was not given!&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 replace_content
              %p
                Replaces a given (sed compatable) pattern with given replacement text in a
                file.
              %h3 Input Parameters
              %p
                First parameter is the pattern
                [optional 'with']
                Second parameter is the replacement content
                [optional 'in']
                Third parameter is the file name/path
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                The pattern will be matched against the file name/path content and the
                replacement text will be put in place.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no pattern was given
                Fails if replacement content was not given
                Fails if filename was not given
                Fails if the file does not exist
              %h3 Usage Examples
              %h1 Replace contents in a file with a given (sed) regex pattern.
              %pre
                %code
                  :preserve
                    replace_content "^PREFIX =.*" with "${install_path}" in Makefile
            %td.code
              .highlight
                %pre
                  replace_content
                  %span.o ()
                  %span.o {
                  = succeed "_token" do
                    %span.nb local
                  _pattern _content _file _message
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv _token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${_token}&quot;
                  in
                  = succeed "with" do
                    %span.o (
                  %span.o )
                  %span.nv _content
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.nb shift
                  ;;
                  = succeed "in" do
                    %span.o (
                  %span.o )
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  = succeed "*" do
                    %span.o (
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_pattern}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _pattern
                  %span.o =
                  %span.s2 &quot;${_token}&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Unknown token '${_token}' passed as a parameter.'&quot;
                  %span.k fi
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_pattern:-}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_content:-}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file:-}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-f
                  %span.s2 &quot;${_file:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "sed" do
                    %span.k if
                  \-i -e
                  %span.s2 &quot;s#${_pattern//\#/\\#}#${_content//\#/\\#}#g&quot;
                  %span.s2 &quot;${_file}&quot;
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Can not replace file content as the file does not exist.&quot;
                  %span.k fi
                  %span.k else
                  %span.k                   %span.nv _message
                  %span.o =(
                  %span.s2 &quot;Can not file content as the filename was not given,&quot;
                  %span.s2 &quot; specify by 'in \&quot;/path/to/filename\&quot;'&quot;
                  %span.o )
                  fail
                  %span.s2 &quot;${_message[*]}&quot;
                  %span.k fi
                  %span.k else
                  %span.k                   %span.nv _message
                  %span.o =(
                  %span.s2 &quot;Cannot replace content as the replacement content was not given, &quot;
                  %span.s2 &quot;specify by 'with \&quot;replacement text\&quot;'.&quot;
                  %span.o )
                  fail
                  %span.s2 &quot;${_message[*]}&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot replace content as not even a pattern was given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                file
                %em> matches
                md5
              %p Checks to see if the given file matches the given md5 sum.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the file matches the md5sum
                1 if the file does not match the md5sum
                1 if the file is empty or missing
              %h3 Failure Scenarios
              %p
                Fails if no file name/path was given.
                Fails if no md5 string was given.
              %h3 Usage Examples
              %p Example Usage:
              %p
                user$ file
                %em> matches
                md5
              %h3 Notes
            %td.code
              .highlight
                %pre
                  file_matches_md5
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nv _md5
                  %span.o =
                  %span.s2 &quot;$2&quot;
                  _file_md5
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_md5}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-s
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _file_md5
                  %span.o =
                  %span.s2 &quot;$(file_md5 &quot;
                  %span.k ${
                  %span.nv _file
                  %span.k }
                  %span.s2 &quot;)&quot;
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;${_file_md5// *}&quot;
                  %span.o =
                  %span.s2 &quot;$_md5&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot determine if file matches md5 as no md5 was given.&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot determine if file matches md5 as no file was given.&quot;
                  %span.k fi
                  %span.o }
                  extract_archive
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _archive
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_archive}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k case
                  %span.s2 &quot;${_archive}&quot;
                  in
                  *.tar.gz|*.tgz
                  %span.o )
                  %span.c # gzip
                  %span.k if
                  \! tar zxf
                  %span.s2 &quot;${_archive}&quot;
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;There was an error while extracting the archive '${_archive}'&quot;
                  %span.k fi
                  ;;
                  *tar.xz
                  %span.o )
                  %span.c # LZMA
          %tr
            %td.docs
              %p TODO: if 'xz' command exists, use that, otherwise use tar J
            %td.code
              .highlight
                %pre
                  %span.k if
                  \! tar Jxf
                  %span.s2 &quot;${_archive}&quot;
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;There was an error while extracting the archive '${_archive}'&quot;
                  %span.k fi
                  ;;
                  *.tar.bz2
                  %span.o )
                  %span.c # bzip
                  %span.k if
                  \! tar jxf
                  %span.s2 &quot;${_archive}&quot;
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;There was an error while extracting the archive '${_archive}'&quot;
                  %span.k fi
                  ;;
                  *.zip
                  %span.o )
                  %span.k if
                  \! unzip
                  %span.s2 &quot;${_archive}&quot;
                  \-d
                  %span.s2 &quot;${_path:-}&quot;
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;There was an error while extracting the archive '${_archive}'&quot;
                  %span.k fi
                  ;;
                  *
                  %span.o )
                  error
                  %span.s2 &quot;Unknown archive format for ${_archive}&quot;
                  ;;
                  %span.k esac
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot extract an archive to target location as no archive was given.&quot;
                  %span.k fi
                  %span.o }
                  file_md5
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _command _md5
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "os_is_darwin" do
                    %span.k if
                  %span.k then
                  %span.k                   %span.nv _command
                  %span.o =
                  %span.s2 &quot;/sbin/md5 -q&quot;
                  %span.k else
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;md5sum&quot;
                  %span.k then
                  %span.k                   %span.nv _command
                  %span.o =
                  %span.s2 &quot;md5sum&quot;
                  = succeed "command_exists" do
                    %span.k elif
                  md5
                  %span.k then
                  %span.k                   %span.nv _command
                  %span.o =
                  %span.s2 &quot;md5&quot;
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Could not find a suitable md5 command in the path.&quot;
                  %span.k fi
                  %span.k fi
                  %span.k if
                  %span.nv _md5
                  %span.o =
                  %span.s2 &quot;$(${_command} &quot;
                  %span.nv $_file
                  %span.s2 &quot; 2&gt;/dev/null)&quot;
                  %span.k then
                  %span.k                   %span.nb printf
                  %span.s2 &quot;${_md5// *}&quot;
                  %span.k else
                  %span.c # Should this be error ?
                  warn
                  %span.s2 &quot;There was an unknown error computing the md5&quot;
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot calculate md5 of a file as no file name/path was given.&quot;
                  %span.k fi
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 lockfile_lock()
              %p
                If the current process is the first to write to the lockfile then the process
                continues processing past the line calling lockfile_lock "{file path/name}"
              %p
                Otherwise lockfile_lock causes the process to exit with a message and status
                code 0.
              %p If the lock is obtained then lockfile_lock ensures that
              %p Usage Examples:
              %p
                lockfile
                %em> lock /var/run/my
                script.pid
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  lockfile_lock
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _lockfile
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_lockfile}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot lock onto a lockfile as no lockfile was specified as the first parameter.&quot;
                  %span.k fi
          %tr
            %td.docs
              %p The first instance that successfully writes it's pid to the lockfile 'wins'
            %td.code
              .highlight
                %pre
                  %span.nb printf
                  %span.s2 &quot;$$&quot;
                  \&gt;&gt;
                  %span.s2 &quot;${_lockfile}&quot;
                  %span.nb read
                  \-r _pid &lt;
                  %span.s2 &quot;${_lockfile}&quot;
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;${_pid}&quot;
                  %span.o ==
                  %span.s2 &quot;$$&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "on_exit" do
                    %span.k                   %span.s2 &quot;rm -f ${_lockfile}&quot;
          %tr
            %td.docs
              %p Ensure the lockfile is released on exit while preserving existing EXIT traps.
            %td.code
              .highlight
                %pre
                  %span.nb trap
                  = succeed "s#" do
                    %span.s2 &quot;rm -f ${_lockfile};$(trap | awk '/EXIT/' | sed -e &quot;
                  %span.s1 ' EXIT##&quot; -e &quot;s#.*'
                  %span.c ##&quot;)&quot; EXIT
                  = succeed "0" do
                    %span.k return
                  %span.c # The lock has been obtained! Proceed with nefarious things!
                  %span.k else
                  %span.c # Question: Should this be an error exit code or ?
                  succeed
                  %span.s2 &quot;Another process already owns the lockfile, exiting.&quot;
                  %span.k fi
                  %span.o }
                  on_exit
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _commands
                  %span.o =
                  %span.s2 &quot;$*&quot;
                  %span.nb local
                  %span.nv _on_exit_code
                  %span.o =
                  = succeed "s#" do
                    %span.s2 &quot;$(trap | awk '/EXIT/' | sed -e &quot;
                  %span.s1 ' EXIT##&quot; -e &quot;s#.*'
                  %span.c ##&quot;)&quot;
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;${_on_exit_code}&quot;
                  \!
                  %span.o =
                  *on_exit*
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb trap
                  %span.s2 &quot;on_exit_commands;${_on_exit_code}&quot;
                  EXIT
                  %span.k fi
                  = succeed "on_exit_commands+" do
                    %span.k                   %span.o =(
                  %span.s2 &quot;${_commands}&quot;
                  %span.o )
                  %span.o }
                  on_exit_commands
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _result
                  %span.o =
                  %span.s2 &quot;$?&quot;
                  %span.c # Preserve actual exit code.
                  = succeed "_command" do
                    %span.nb local
                  = succeed "_command" do
                    %span.k for
                  in
                  %span.s2 &quot;${on_exit_commands[@]}&quot;
                  %span.k do
                  %span.k if
                  \!
                  %span.nb eval
                  %span.s2 &quot;${_command}&quot;
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;On Exit Command Failed: ${_command}&quot;
                  %span.k fi
                  %span.k done
                  %span.k return
                  %span.s2 &quot;${_result}&quot;
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2
                shell
                %em> is
                interactive()
              %p Test if the current shell is an interactive shell.
              %p Usage Examples:
              %pre
                %code
                  :preserve
                    if shell_is_interactive
                    then
                      ${PAGER} somefile
                    else
                      cat -v somefile
                    fi
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  shell_is_interactive
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o [[
                  \-t 0
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
                  = succeed "shell_is_interactive" do
                    %span.k if
                  %span.k then
                  %span.k                   %span.nb true
                  %span.c # Interactive functions will be loaded here, only if shell is interactive.
                  %span.k fi
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 command_exists()
              %p Checks to see whether a command exists within the current environment and PATH
              %h3 Input Parameters
              %p First parameter is a command name.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p none.
              %h3 return codes
              %p
                0 if the command was found in the current environment
                1 if the command was not found in the current environment
              %h3 failure scenarios
              %p Fails if no command name was given.
              %h3 usage examples
              %pre
                %code
                  :preserve
                    user$ command_exists adsf
                    user$ echo $?
                    1
                    
                    user$ command_exists ls
                    user$ echo $?
                    0
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  command_exists
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _name
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_name}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.nb command
                  \-v
                  %span.s2 &quot;${_name}&quot;
                  \&gt; /dev/null 2&gt;&amp;1
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot test if command exists as no command name was given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                is
                %em> a
                function()
              %p Checks to see whether a named function exists within the current environment
              %h3 Input Parameters
              %p First parameter is a function name.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p none.
              %h3 return codes
              %p
                0 if the function exists
                1 if the function does not exist
              %h3 failure scenarios
              %p Fails if no function name was given.
              %h3 usage examples
              %pre
                %code
                  :preserve
                    user$ is_a_function rvm
                    user$ echo $?
                    0
                    
                    user$ is_a_function asdf
                    user$ echo $?
                    1
                    
                    user$ is_a_function ls
                    user$ echo $?
                    1
            %td.code
              .highlight
                %pre
                  is_a_function
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _name
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_name}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.nb declare
                  \-f
                  %span.s2 &quot;${_name}&quot;
                  \&gt;/dev/null 2&gt;&amp;1
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot test if function exists as no function name was given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                shell
                %em> is
                interactive()
              %p Checks if the currently running shell is interactive (user controlled).
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p none.
              %h3 return codes
              %p
                0 if the shell is interactive (user controlled)
                1 if the shell is not interactive
              %h3 failure scenarios
              %p None currently.
              %h3 usage examples
              %p user$ cat $HOME/test
              %h1 !/usr/bin/env bash
              %p
                source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                modules environment # Load the trace module.
              %p
                if shell
                %em> is
                interactive
                then
                echo "Shell is Interactive! "
                else
                echo "Shell is Not Interactive! "
                fi
              %p
                user$ "$HOME/test"
                Shell is Not Interactive!
              %p
                user$ source "$HOME/test"
                Shell is Interactive!
            %td.code
              .highlight
                %pre
                  shell_is_interactive
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;$-&quot;
                  %span.o =
                  *i*
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 timestamp_set()
              %p Sets the variable named 'timestamp' to the current timestamp.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p Sets the variable named 'timestamp' to the current timestamp.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat ./test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules trace time # Load the trace module.
                    
                    timestamp_set
                    echo $timestamp
                    
                    user$ $PWD/test
                    2011-04-24T22:28:16
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  timestamp_set
                  %span.o ()
                  %span.o {
                  %span.nv timestamp
                  %span.o =
                  = succeed "timestamp" do
                    %span.k $(
                  %span.k )
                  %span.o }
          %tr
            %td.docs
              %h2 timestamp()
              %p Prints out the current timestamp.
              %h3 Input Parameters
              %p
                None required. The first parameter may optionally specify the format to output
                the time string in. See 'man 1 date' for formatting options.
              %h3 Stream Outputs
              %p
                Prints the current timestamp as a formatted datetime string to the STDOUT of
                the calling environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat ./test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules trace time # Load the trace module.
                    
                    timestamp
                    echo
                    
                    user$ $PWD/test
                    2011-04-24T22:31:54
            %td.code
              .highlight
                %pre
                  timestamp
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _format
                  %span.o =
                  = succeed "%Y-%m-%dT%H:%M:%S" do
                    %span.s2 &quot;${1:-&quot;
                  %span.s2 &quot;}&quot;
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;$(date +&quot;
                  %span.k ${
                  %span.nv _format
                  %span.k }
                  %span.s2 &quot;)&quot;
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 rvm_install()
              %p Install the latest release version of RVM.
              %h3 Input Parameters
              %p First parameter is an optional version number of RVM to install.
              %h3 Stream Outputs
              %p
                Output from rvm-installer will be printed to the enclosing environment's
                STDOUT as well as curl output.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ rvm_install
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  rvm_install
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _version
                  %span.o =
                  %span.k ${
                  %span.nv 1
                  %span.k :-
                  %span.nv latest
                  %span.k }
                  %span.nv _result
                  = succeed "0" do
                    %span.o =
                  %span.nb local
                  %span.nv url
                  %span.o =
                  %span.s2 &quot;https://rvm.beginrescueend.com/install/rvm&quot;
                  %span.o (
                  %span.nb set
                  \-o errexit
                  curl -s
                  %span.s2 &quot;$url&quot;
                  \-o rvm-installer
                  ensure_files_are_executable
                  %span.s2 &quot;rvm-installer&quot;
                  \./rvm-installer --version
                  %span.k ${
                  %span.nv _version
                  %span.k }
                  remove_files
                  %span.s2 &quot;rvm-installer&quot;
                  %span.o )
                  %span.o ||
                  %span.nv _result
                  %span.o =
                  %span.nv $?
                  %span.k return
                  %span.nv $_result
                  %span.o }
          %tr
            %td.docs
              %h2 install_gem()
              %p installs the named gem(s) with --no-rdoc --no-ri flags
              %h3 Input Parameters
              %p One or more gem names
              %h3 Stream Outputs
              %p
                The output of the gem install command will be printed to the calling
                environments streams.
              %h3 Environmental effects
              %p Ruby gem(s) will be installed on the system, potentially enabling new commands.
              %h3 Return Codes
              %p
                0 if gem install was successful
                1 if gem install was not successful
              %h3 Failure Scenarios
              %p Fails if ...
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ {{ setup the scenario }}
                    user$ function_name {{ parameters }}
                    user$ {{ demonstrate the results}}
            %td.code
              .highlight
                %pre
                  install_gem
                  %span.o ()
                  %span.o {
                  = succeed "gem" do
                    %span.k if
                  install --no-rdoc --no-ri -q
                  %span.s2 &quot;$*&quot;
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 install_gems()
              %p Installs listed gems using the install_gem function.
              %h3 Input Parameters
              %p One or more rubygems names
              %h3 Stream Outputs
              %p
                Output from underlying gem install will be printed to the calling environments
                streams.
              %h3 Environmental effects
              %p One or more new commands may become available.
              %h3 Return Codes
              %p
                0 if all gem installs were successful
                n where n is the number of unsuccessful gem installs otherwise.
              %h3 Failure Scenarios
              %p Fails if no gems were given to install.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ install_gems rake rack
            %td.code
              .highlight
                %pre
                  install_gems
                  %span.o ()
                  %span.o {
                  = succeed "_gem" do
                    %span.nb local
                  %span.nv _gems
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.nv _result
                  = succeed "0" do
                    %span.o =
                  %span.o ((
                  %span.k ${#
                  %span.nv _gems
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.o ||
                  fail
                  %span.s2 &quot;Cannot install gems as no gem names were given!&quot;
                  = succeed "_gem" do
                    %span.k for
                  in
                  %span.s2 &quot;${_gems[@]}&quot;
                  %span.k do
                  = succeed "install_gem" do
                    %span.k                   %span.k ${
                  %span.nv _gem
                  %span.k }
                  %span.o ||
                  %span.o ((
                  _result++
                  %span.o ))
                  %span.k done
                  %span.k return
                  %span.nv $_result
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 project_initialize()
              %p Initializes paths and environment for the logical concept of a 'project'.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                Environmental variable settings, such as {shared,release}_path, environment,
                etc...
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ project_initialize
                    user$ echo $environment
                    production
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  project_initialize
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${project_path}&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  \:
                  %span.se \
                  %span.s2 &quot;${shared_path:=${project_path}/shared}&quot;
                  %span.se \
                  %span.s2 &quot;${release_path:=${project_path}/current}&quot;
                  %span.se \
                  = succeed "production" do
                    %span.s2 &quot;${environment:=&quot;
                  %span.s2 &quot;}&quot;
                  \:
                  %span.se \
                  %span.s2 &quot;${vcs:=$(vcs &quot;
                  %span.k ${
                  %span.nv shared_path
                  = succeed "/" do
                    %span.k }
                  %span.k ${
                  %span.nv project
                  %span.k }
                  %span.s2 &quot;)}&quot;
                  %span.nv log_path
                  %span.o =
                  %span.s2 &quot;$shared_path/log&quot;
                  %span.c # Override default BDSM log path.
                  %span.nv extension_log_path
                  %span.o =
                  %span.s2 &quot;${log_path}&quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${project}&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  %span.k                   %span.nv database_name
                  %span.o =
                  %span.s2 &quot;${database_name:-&quot;
                  %span.k ${
                  %span.nv project
                  = succeed "_" do
                    %span.k }
                  %span.k ${
                  %span.nv environment
                  %span.k }
                  %span.s2 &quot;}&quot;
                  source_files
                  %span.s2 &quot;.${project}rc&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 vcs()
              %p Detect and set the vcs, if any, for the current project.
              %h3 Input Parameters
              %p First parameter must be the path to a repository for determining the VCS.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                The environment variable 'vcs' will be set to the VCS detected, or 'git' by
                default.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no repository path is given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ vcs /home/appuser/shared/appuser
                    user$ echo $vcs
                    git
            %td.code
              .highlight
                %pre
                  vcs
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.o ||
                  fail
                  %span.s2 &quot;Repository path must be given in order to detect the VCS used.&quot;
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}/.git&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  %span.k                   %span.nv vcs
                  %span.o =
                  %span.s2 &quot;git&quot;
                  %span.k elif
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}/.svn&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  %span.k                   %span.nv vcs
                  %span.o =
                  %span.s2 &quot;svn&quot;
                  %span.k elif
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}/.hg&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  %span.k                   %span.nv vcs
                  %span.o =
                  %span.s2 &quot;hg&quot;
          %tr
            %td.docs
              %p
                TODO:
                elif [[ ... ]] ; then
                vcs="fossil"
            %td.code
              .highlight
                %pre
                  %span.k else
                  %span.k                   %span.nv vcs
                  %span.o =
                  %span.s2 &quot;git&quot;
                  %span.c # default
                  %span.k fi
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 read_default()
              %p Reads default values from an extension's config/defaults file.
              %h3 Input Parameters
              %p
                First parameter is the defaults file key to read (key=value).
                Second parameter is the variable name to store the retrieved value in.
                Remaining parameters are parsed out as token, value and prefix
                into|as
                %variable{:name => ""}
                  prefix
                  %name
                    %variable # If no specifier.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                A variable will be set to the value, if the value is nonempty. If no variable
                name is specified the variable will be assigned the same name as the key.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Fails if no arguments are passed in, at least need to specify a key.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ read_default "version" prefix "package" # extension is nginx for example
                    user$ echo $package_version
                    1.0.0
              %h3 Notes
              %p read_default respects a tiered default file scheme,
              %p
                "/etc/bdsm/${extension}/defaults"
                "$HOME/.bdsm/${extension}/defaults"
                "${extension
                %em> config
                path}/defaults"
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  read_default
                  %span.o ()
                  %span.o {
                  = succeed "key" do
                    %span.nb local
                  variable token value prefix _file _files _temp
                  %span.nv key
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${key}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;$extension $action read_default() no arguments passed! &quot;
                  %span.k else
                  %span.k                   %span.nb shift
                  %span.nb                   %span.k fi
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;$token&quot;
                  in
                  into|as
                  %span.o )
                  %span.nv variable
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  ;;
                  prefix
                  %span.o )
                  %span.nv prefix
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  ;;
                  *
                  %span.o )
                  %span.nv variable
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.nb break
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${variable:-}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${prefix:-}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb true
                  %span.s2 &quot;${variable:=&quot;
                  %span.k ${
                  %span.nv prefix
                  = succeed "_" do
                    %span.k :-}
                  %span.nv $key
                  %span.s2 &quot;}&quot;
                  %span.k else
                  %span.k                   %span.nb true
                  %span.s2 &quot;${variable:=&quot;
                  %span.nv $key
                  %span.s2 &quot;}&quot;
                  %span.k fi
                  %span.k fi
                  %span.k                   %span.nv _files
                  %span.o =(
                  %span.s2 &quot;/etc/bdsm/${extension}/defaults&quot;
                  %span.s2 &quot;$HOME/.bdsm/${extension}/defaults&quot;
                  %span.s2 &quot;${extension_config_path}/defaults&quot;
                  %span.o )
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  = succeed "file_is_nonempty" do
                    %span.k if
                  %span.s2 &quot;${_file}&quot;
                  %span.k then
                  %span.k                   %span.nv _temp
                  %span.o =
                  %span.s2 &quot;$(hash_file &quot;
                  %span.k ${
                  %span.nv _file
                  %span.k }
                  %span.s2 &quot; &quot;
                  %span.k ${
                  %span.nv key
                  %span.k }
                  %span.s2 &quot;)&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_temp}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv value
                  %span.o =
                  %span.s2 &quot;${_temp}&quot;
                  %span.k fi
                  %span.k fi
                  %span.k done
                  %span.k                   %span.nb eval
                  %span.s2 &quot;${variable}=\&quot;${value}\&quot;&quot;
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 bdsm_exports()
              %p
                Exports bdsm framework relevant environment variables for extension action
                processes.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ bdsm_exports
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  bdsm_exports
                  %span.o ()
                  %span.o {
                  %span.c # TODO: Filter this list of exports down.
                  = succeed "action" do
                    %span.nb export
                  archives_path bdsm_path branch config_path database database_name debug_flag environment error_message extension extension_action extension_args extension_bin_path extension_config_path extension_modules_path extension_path extension_templates_path extensions_path flags framework head_flag hooks_flag keep_releases modules_path old_releases parse_break paths prefix_path previous_path project project_path release_path remote repository result revision shared_path src_path templates_path timestamp tmp_path trace_flag user extension_log_path
                  %span.o }
          %tr
            %td.docs
              %h2 bdsm_version()
              %p Reads the currently installed bdsm version into the variable 'bdsm_version'.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p The variable 'bdsm_version' will be set after the function is executed.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ bdsm_version
                    user$ echo $bdsm_version
                    69.69.69
            %td.code
              .highlight
                %pre
                  bdsm_version
                  %span.o ()
                  %span.o {
                  = succeed "file_is_nonempty" do
                    %span.k if
                  %span.s2 &quot;$bdsm_path/VERSION&quot;
                  %span.k then
                  %span.k                   %span.nb read
                  \-r bdsm_version &lt;
                  %span.s2 &quot;$bdsm_path/VERSION&quot;
                  %span.k else
                  %span.k                   %span.nv bdsm_version
                  %span.o =
                  %span.s2 &quot;?.?.?&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 NIY()
              %p
                Prints a failure message and backtrace to the screen letting the caller know
                that the requested feature has not yet been implemented.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                Prints "This feature has not yet been implemented." to STDERR of the calling
                environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p None, only exit is through failure.
              %h3 Failure Scenarios
              %p Fails always.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat $HOME/test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    NIY
                    
                    user$ $HOME/test
                    ERROR: This feature has not yet been implemented.
                    Backtrace:
                       Trace   Line Function             File
                          3.    262 fail()               /usr/local/bdsm/modules/bash/logging/dsl
                          2.      5 NIY()                /usr/local/bdsm/modules/bash/extensions/dsl
                          1.      5 main()               /Users/wayneeseguin/test
                     &gt; modules/bash/logging/dsl fail() 263 $ exit 1
            %td.code
              .highlight
                %pre
                  NIY
                  %span.o ()
                  %span.o {
                  fail
                  %span.s2 &quot;This feature has not yet been implemented.\n${*:-}&quot;
                  %span.o }
          %tr
            %td.docs
              %p Allow for method_missing when a command is not found during lookup.
            %td.code
              .highlight
                %pre
                  %span.k if
                  %span.o ((
                  %span.k ${
                  %span.nv BASH_VERSINFO
                  %span.p [0]
                  %span.k }
                  \&gt; 3
                  %span.o ))
                  %span.k then
                  = succeed "command_not_found" do
                    %span.k                   %span.o ()
                  %span.o {
                  %span.nb echo
                  %span.s2 &quot;bash: $1: command not found ($*)&quot;
                  \&gt;&amp;2
                  = succeed "127" do
                    %span.k return
                  %span.o }
                  command_not_found_handle
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${MC_SID}&quot;
                  %span.o ||
                  \! -t 1
                  %span.o ]]
                  %span.k then
                  %span.c # do not run when inside Midnight Commander or within a Pipe
                  command_not_found
                  %span.s2 &quot;$@&quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  %span.nv $MACHTYPE
                  %span.o =
                  *linux*
                  %span.o ]]
                  %span.k then
                  %span.c # do not run when within a subshell, Linux version.
                  = succeed "cmd" do
                    %span.nb local
                  state remainder
                  %span.nb local
                  \-i pid ppid pgrp session tty_nr tpgid
                  = succeed "pid" do
                    %span.nb read
                  cmd state ppid pgrp session tty_nr tpgid remainder &lt; /proc/self/stat
                  %span.k if
                  %span.o ((
                  %span.nv $$
                  %span.o ==
                  %span.k ${
                  %span.nv tpgid
                  %span.k }
                  %span.o ))
                  %span.k then
                  = succeed "command_not_found" do
                    %span.k                   %span.s2 &quot;$@&quot;
                  %span.k fi
                  %span.k fi
                  %span.k if
                  %span.nb command
                  \-v method_missing
                  %span.k then
                  %span.c # Pass to method_missing.
                  method_missing
                  %span.s2 &quot;$@&quot;
                  %span.k else
                  %span.c # Default behavior.
                  command_not_found
                  %span.s2 &quot;$@&quot;
                  %span.k fi
                  %span.o }
                  %span.k fi
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %p TODO: Use git cli instead of awking it :)
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  scm_fetch
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _url
                  %span.o =
                  %span.s2 &quot;${1:-${extension_url:-}}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_url}&quot;
                  %span.o ]]
                  %span.k then
                  fail
                  %span.s2 &quot;Cannot fetch an extension from a url as no url was given&quot;
                  %span.k fi
                  %span.nb local
                  %span.nv _identifier
                  %span.o =
                  %span.s2 &quot;${_url//\//_}&quot;
                  %span.c # Convert '/' to an invalid url component '_'
                  %span.nb local
                  %span.nv repo_path
                  %span.o =
                  %span.s2 &quot;${repos_path}/${_identifier}&quot;
                  ensure_paths_exist
                  %span.s2 &quot;${repos_path}&quot;
                  %span.k case
                  %span.s2 &quot;${_url}&quot;
                  in
                  *git*
                  %span.o )
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${repo_path}/.git&quot;
                  %span.k then
                  %span.nb true
                  %span.c # already fetched!
                  %span.k else
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${repo_path}&quot;
                  %span.k then
                  remove_paths
                  %span.s2 &quot;${repo_path}&quot;
                  %span.k fi
                  %span.k if
                  \! git clone --depth 1
                  %span.k ${
                  %span.nv _url
                  %span.k }
                  %span.s2 &quot;${repo_path}&quot;
                  %span.k then
                  error
                  %span.s2 &quot;There was an error while cloning the repository from the url '${_url}'&quot;
                  %span.k fi
                  %span.k fi
                  ;;
                  *svn*
                  %span.o )
                  NIY
                  ;;
                  *hg*
                  %span.o )
                  NIY
                  ;;
                  *fossil*
                  %span.o )
                  NIY
                  ;;
                  *
                  %span.o )
                  ;;
                  %span.k esac
                  %span.o }
                  scm_update
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _url
                  %span.o =
                  %span.s2 &quot;${1:-${extension_url:-}}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_url}&quot;
                  %span.o ]]
                  %span.k then
                  fail
                  %span.s2 &quot;Cannot fetch an extension from a url as no url was given&quot;
                  %span.k fi
                  %span.nb local
                  %span.nv _identifier
                  %span.o =
                  %span.s2 &quot;${_url//\//_}&quot;
                  %span.c # Convert '/' to an invalid url component '_'
                  %span.nb local
                  %span.nv repo_path
                  %span.o =
                  %span.s2 &quot;${repos_path}/${_identifier}&quot;
                  %span.k case
                  %span.s2 &quot;${_url}&quot;
                  in
                  *git*
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-z
                  = succeed "/" do
                    %span.s2 &quot;$(git branch | awk &quot;
                  %span.k ${
                  %span.nv branch
                  %span.p :=master
                  %span.k }
                  %span.nv $/
                  %span.s2 &quot;)&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  \!
                  %span.o (
                  %span.nb builtin cd
                  = succeed ";" do
                    %span.s2 &quot;${repo_path}&quot;
                  git checkout -b
                  %span.s2 &quot;$branch&quot;
                  \--track
                  %span.s2 &quot;$remote/$branch&quot;
                  2&gt;/dev/null
                  %span.o )
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;$remote $branch remote branch not found. Halting.&quot;
                  %span.k fi
                  %span.k elif
                  %span.o [[
                  \-z
                  = succeed "/" do
                    %span.s2 &quot;$(git branch | awk &quot;
                  %span.se \*
                  %span.nv $branch$/
                  = succeed "print" do
                    %span.o {
                  = succeed "2" do
                    %span.se \$
                  %span.o }
                  %span.s2 &quot;)&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  \!
                  %span.o (
                  %span.nb builtin cd
                  = succeed ";" do
                    %span.s2 &quot;${repo_path}&quot;
                  git checkout
                  %span.nv $branch
                  2&gt;/dev/null
                  %span.o )
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Unable to checkout $branch.\nCould not get head. Halting.&quot;
                  %span.k fi
                  %span.k fi
                  %span.k if
                  \!
                  %span.o (
                  %span.nb builtin cd
                  %span.s2 &quot;${repo_path}&quot;
                  ;
                  git pull --rebase origin
                  %span.nv $branch
                  %span.o )
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Git pull failed. Halting.&quot;
                  %span.k fi
                  ;;
                  *svn*
                  %span.o )
                  NIY
                  %span.s2 &quot;Subversion scm_update&quot;
                  ;;
                  *hg*
                  %span.o )
                  NIY
                  %span.s2 &quot;hg scm_update&quot;
                  ;;
                  *fossil*
                  %span.o )
                  NIY
                  %span.s2 &quot;fossil scm_update&quot;
                  ;;
                  *
                  %span.o )
                  error
                  %span.s2 &quot;Unknownn SCM for url '${_url}'&quot;
                  ;;
                  %span.k esac
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 first()
              %p Returns the first parameter.
              %h3 Input Parameters
              %p One or more parameters.
              %h3 Stream Outputs
              %p Prints the first positional parameter to STDOUT of the calling environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no parameters are passed.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ first one two three
                    one
                    
                    user$ array=($(ls $HOME))
                    user$ first ${array[@]}
                    Desktop
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  first
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _array
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;${_array[0]}&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;No parameters given, cannot return the first one.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 last()
              %p Returns the last parameter.
              %h3 Input Parameters
              %p One or more parameters.
              %h3 Stream Outputs
              %p Prints the last positional parameter to STDOUT of the calling environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no parameters are passed.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ last one two three
                    one
                    
                    user$ array=($(ls $HOME))
                    user$ last ${array[@]}
                    tmp
            %td.code
              .highlight
                %pre
                  last
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _array
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;${_array[$((${#_array[@]} - 1))]}&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;No parameters given, cannot return the last one.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 match()
              %p Tests to see if a value matches a given regex (shell extended glob pattern).
              %h3 Input Parameters
              %p Positional Parameter listing and descriptions.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the value matches the regex (shell extended glob pattern)
                1 if the value does not match the regex (shell extended glob pattern)
              %h3 Failure Scenarios
              %p
                Fails if no value is given
                Fails if no regex is given
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ match "The quick brown fox jumped over the lazy dog." "*fox*"
                    user$ echo $?
                    0
                    
                    user$ match "The quick brown fox jumped over the lazy dog." "*smurf*"
                    user$ echo $?
                    1
            %td.code
              .highlight
                %pre
                  match
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _value
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_value}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb local
                  %span.nv _regex
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_value}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb shopt
                  \-s extglob
                  %span.k case
                  %span.s2 &quot;${_value}&quot;
                  in
                  %span.o (
                  %span.k ${
                  %span.nv _regex
                  %span.k }
                  %span.o )
                  = succeed "0" do
                    %span.k return
                  ;;
                  = succeed "*" do
                    %span.o (
                  %span.o )
                  = succeed "1" do
                    %span.k return
                  ;;
                  %span.k esac
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;A regex must be specified in order to match ${_value} against it.&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;A value and regex must be specified in order to match.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                variables
                %em> must
                be_nonempty()
              %p
                Halts the program with a fail message if any of the named variables are empty
                or undefined.
              %h3 Input Parameters
              %p One or more parameters specifying the names of variables.
              %h3 Stream Outputs
              %p None if all are
              %h3 Environmental effects
              %p What, if any, environmental side effects this function causes. 'None.' for none.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no varaible names were given.
                Fails if any of the named variables are empty.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules trace variables # Load the trace module.
                    unset HOME
                    variables_must_be_nonempty HOME
                    
                    user$ $PWD/test
                    ERROR: Required variable 'HOME' is not set.
                    ERROR: A command has returned an unhandled error code (nonzero return value).
                    Backtrace:
                       Trace   Line Function             File
                          3.     37 fail()               /usr/local/bdsm/modules/bash/logging/dsl
                          2.    192 variables_must_be_nonempty() /usr/local/bdsm/modules/bash/variables/dsl
                          1.      6 main()               /Users/wayneeseguin/test
                     &gt; modules/bash/logging/dsl fail() 38 $ exit 1
            %td.code
              .highlight
                %pre
                  variables_must_be_nonempty
                  %span.o ()
                  %span.o {
                  = succeed "_variable" do
                    %span.nb local
                  %span.nv _variables
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _variables
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_variable" do
                    %span.k for
                  in
                  %span.s2 &quot;${_variables}&quot;
                  %span.k do
                  %span.k if
                  %span.nb eval
                  %span.s2 &quot;[[ -n \&quot;\${${_variable}}\&quot; ]]&quot;
                  %span.k then
                  %span.k continue
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Required variable '$_variable' is not set.&quot;
                  %span.k fi
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot ensure variables are nonempty as no variables were given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                variable
                %em> is
                nonempty()
              %p Test to see if a variable is empty.
              %h3 Input Parameters
              %p First parameter is a string containing a variable name.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Fails if no variable name was given as the first argument.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ variable_is_nonempty asdf
                    user$ echo $?
                    1
                    
                    user$ asdf="w00t! "
                    user$ variable_is_nonempty asdf
                    user$ echo $?
                    0
            %td.code
              .highlight
                %pre
                  variable_is_nonempty
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _variable
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_variable}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.nb eval
                  %span.s2 &quot;[[ -n \&quot;\${${_variable}:-}\&quot; ]]&quot;
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check if variable is nonempty, no variable was given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                variable
                %em> is
                empty()
              %p Test to see if a variable is empty.
              %h3 Input Parameters
              %p First parameter is a string containing a variable name.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Fails if no variable name was given as the first argument.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ variable_is_empty asdf
                    user$ echo $?
                    1
                    
                    user$ asdf="w00t! "
                    user$ variable_is_empty asdf
                    user$ echo $?
                    0
            %td.code
              .highlight
                %pre
                  variable_is_empty
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _variable
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_variable}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.nb eval
                  %span.s2 &quot;[[ -z \&quot;\${${_variable}:-}\&quot; ]]&quot;
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check if variable is empty as no variable was given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                variables
                %em> are
                nonempty()
              %p Test to see if any of a given list of variables are empty.
              %h3 Input Parameters
              %p First parameter is a string containing a variable name.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if all variables given are nonempty.
                1 if any variable given is nonempty.
              %h3 Failure Scenarios
              %p Fails if no variable names were given as arguments.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ variables_are_nonempty BASH_VERSION asdf
                    user$ echo $?
                    1
                    
                    user$ asdf="w00t! "
                    user$ variables_are_nonempty BASH_VERSION asdf
                    user$ echo $?
                    0
            %td.code
              .highlight
                %pre
                  variables_are_nonempty
                  %span.o ()
                  %span.o {
                  = succeed "_variable" do
                    %span.nb local
                  %span.nv _variables
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.s2 &quot;${#_variables[@]}&quot;
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_variable" do
                    %span.k for
                  in
                  %span.s2 &quot;${_variables}&quot;
                  %span.k do
                  %span.k if
                  %span.nb eval
                  %span.s2 &quot;[[ -z \&quot;\${${_variable}:-}\&quot; ]]&quot;
                  %span.k then
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k done
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check if variables are nonempty as no variables were given.&quot;
                  %span.k fi
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 template_exists()
              %p
                Checks if a named template file exists in the extension
                %em> templates
                path
              %h3 Input Parameters
              %p First parameter must be the name of a template file, eg. a string.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p
                0 if the named template file exists and is nonempty.
                1 if the named template file does not exist or is empty.
              %h3 Failure Scenarios
              %p Fails if no template name is given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ {{ setup the scenario }}
                    user$ function_name {{ parameters }}
                    user$ {{ demonstrate the results}}
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  template_exists
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${1:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check if a template exists as no template name was given.&quot;
                  %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _template
                  %span.o =
                  %span.s2 &quot;${extension_templates_path}/${1}.template&quot;
                  %span.k if
                  %span.o [[
                  \-s
                  %span.s2 &quot;${_template}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 install_template()
              %p Installs a named template to a given location.
              %h3 Input Parameters
              %p
                The first parameter should be the template name.
                Remaining parameters specify the target, mode and owner:
                owner "&lt;
                %user
                  >[:&lt;
                  %group
                    >]"
                    mode 0755
                    to "/path/to/new/file"
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p
                0 if successful
                1 otherwise
              %h3 Failure Scenarios
              %p
                Fails if no template name was given.
                Fails if the template name given is a directory.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ install_template "nginx.conf" \
                          to "${nginx_path}/nginx.conf" \
                          mode 0644 owner "${nginx_user}"
            %td.code
              .highlight
                %pre
                  install_template
                  %span.o ()
                  %span.o {
                  = succeed "_template" do
                    %span.nb local
                  _name _target
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;${extension_templates_path}&quot;
                  %span.nv _mode
                  = succeed "0644" do
                    %span.o =
                  %span.nv _owner
                  %span.o =
                  %span.nv $USER
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  ;
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  ;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${token}&quot;
                  in
                  to
                  %span.o )
                  %span.nv _target
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  ;
                  %span.nb shift
                  ;;
                  
                  mode
                  %span.o )
                  %span.nv _mode
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  ;
                  %span.nb shift
                  ;;
                  
                  owner
                  %span.o )
                  %span.nv _owner
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  ;
                  %span.nb shift
                  ;;
                  
                  from
                  %span.o )
                  %span.c # TODO: finish this part.
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  ;
                  %span.nb shift
                  ;;
                  
                  *
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_name}&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  %span.k                   %span.nv _name
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.k elif
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  %span.k                   %span.nv _target
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.nb break
                  %span.c # When we have a target we are done.
          %tr
            %td.docs
              %p
                An alternative idea would be to allow an array of multiple targets
                to symlink to...
            %td.code
              .highlight
                %pre
                  %span.k fi
                  ;;
                  %span.k esac
                  %span.k done
                  = succeed "file_exists" do
                    %span.k if
                  %span.s2 &quot;${_name}&quot;
                  %span.k then
                  %span.k                   %span.nv _template
                  %span.o =
                  %span.s2 &quot;${_name}&quot;
                  = succeed "file_exists" do
                    %span.k elif
                  %span.s2 &quot;${_source}/${_name}&quot;
                  %span.k then
                  %span.k                   %span.nv _template
                  %span.o =
                  %span.s2 &quot;${_source}/${_name}&quot;
                  %span.k else
                  %span.k                   %span.nv _template
                  %span.o =
                  %span.s2 &quot;${_source}/${_name}.template&quot;
                  %span.k fi
                  = succeed "ensure_paths_exist" do
                    %span.k                   %span.s2 &quot;$(dirname &quot;
                  %span.k ${
                  %span.nv _target
                  %span.k }
                  %span.s2 &quot;)&quot;
                  %span.k if
                  %span.o [[
                  \-f
                  %span.s2 &quot;${_template}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_target}/${_name}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot install the template '${_template}' to ${_target}/${_name} &quot;
                  %span.se \
                  %span.s2 &quot; as it is a directory&quot;
                  %span.k else
                  = succeed "cp" do
                    %span.k                   \-f
                  %span.s2 &quot;${_template}&quot;
                  %span.s2 &quot;${_target}/${_name}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_mode:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "chmod" do
                    %span.k                   %span.s2 &quot;${_mode}&quot;
                  %span.s2 &quot;${_target}/${_name}&quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_owner:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "chown" do
                    %span.k                   %span.s2 &quot;${_owner}&quot;
                  %span.s2 &quot;${_target}/${_name}&quot;
                  %span.k fi
                  %span.k fi
                  %span.k else
                  = succeed "cp" do
                    %span.k                   \-f
                  %span.s2 &quot;${_template}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_mode:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "chmod" do
                    %span.k                   %span.s2 &quot;${_mode}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_owner:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "chown" do
                    %span.k                   %span.s2 &quot;${_owner}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k fi
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot install template as the template file '${_template}' is missing.'&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 seed_template()
              %p Seed a template file replacing all given keys with given values.
              %h3 Input Parameters
              %p
                First parameter must be the template filename to seed.
                Remaining parameters must come in pairs, the first of each pair specifies
                the key to search and replace in the template file and the second is the
                value to replace {{$key}} with.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no template filename is given.
                Fails if the template given does not exist.
                Fails if no key/value pairs are given.
                Fails if for every key there is no associated value.
                Fails if the intermediate template file does not exist...
              %h3 Usage Examples
              %p
                user$ seed
                %em>
                  template "/etc/conf.d/${extension}.conf" \
                  prefix
                path "${prefix
                %em>
                  path}" \
                  init
                scripts
                %em> path "${init
                scripts
                %em>
                  path}" \
                  modules
                path "${modules
                %em>
                  path}" \
                  data
                path "${data
                %em>
                  path}" \
                  confd
                path "${confd_path}" \
                extension "${extension}"
            %td.code
              .highlight
                %pre
                  seed_template
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _template
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_template}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb local
                  %span.nv _args
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.nv _strings
                  %span.o =()
                  %span.k if
                  %span.o [[
                  \-f
                  %span.s2 &quot;${_template}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _args
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot seed template '${_template}' as no replacement keys were&quot;
                  %span.se \
                  %span.s2 &quot;specified&quot;
                  %span.k else
                  %span.k if
                  %span.o ((
                  %span.o (
                  %span.k ${#
                  %span.nv _args
                  %span.p [@]
                  %span.k }
                  \% 2
                  %span.o )
                  %span.o ==
                  1
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Every replacement key must have a replacement value.&quot;
                  %span.k fi
                  %span.k fi
                  = succeed "warn" do
                    %span.k                   %span.s2 &quot;Template Seeding (replacing defaults) has not yet fully implemented.&quot;
          %tr
            %td.docs
              %p Aggregate the replacement strings.
            %td.code
              .highlight
                %pre
                  %span.k for
                  %span.o ((
                  %span.nv index
                  = succeed "0" do
                    %span.o =
                  ; index &lt;
                  %span.k ${#
                  %span.nv _args
                  %span.p [@]
                  %span.k }
                  ; index++
                  %span.o ))
                  %span.k do
                  = succeed "_strings+" do
                    %span.k                   %span.o =(
                  %span.s2 &quot; -e 's#${_args[${index}]}#${_args[$((++index))]}#g' &quot;
                  %span.o )
                  %span.k done
          %tr
            %td.docs
              %p Filter the template with the replacments.
            %td.code
              .highlight
                %pre
                  sed
                  %span.k ${
                  %span.nv _strings
                  %span.p [@]
                  %span.k }
                  %span.k ${
                  %span.nv _template
                  %span.k }
                  \&gt;&gt;
                  %span.k ${
                  %span.nv _template
                  = succeed "." do
                    %span.k }
                  %span.k ${
                  %span.nv timestamp
                  %span.k }
                  = succeed "file_exists" do
                    %span.k if
                  %span.s2 &quot;${_template}.${timestamp}&quot;
                  %span.k then
                  = succeed "mv" do
                    %span.k                   \-f
                  %span.s2 &quot;${_template}.${timestamp}&quot;
                  %span.s2 &quot;${_template}&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Something went horribly wrong, the template intermediate file &quot;
                  %span.se \
                  %span.s2 &quot;'${_template}.${timestamp}' does not exist.&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Can not seed template template file '${_template}' does not exist.&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Can not install template as no template was given.&quot;
                  %span.k fi
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 log()
              %p Log arguments to the calling environments STDOUT.
              %h3 Input Parameters
              %p Strings to be logged.
              %h3 Stream Outputs
              %p
                Prints arguments passed in to the calling environments STDOUT with a newline
                character appended.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no arguments are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ log "Hello there! "
                    Hello there!
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  log
                  %span.o ()
                  %span.o {
                  = succeed "_token" do
                    %span.nb local
                  _file _message
                  %span.nv _append_flag
                  = succeed "0" do
                    %span.o =
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv _token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${_token}&quot;
                  in
                  = succeed "append|--append" do
                    %span.o (
                  %span.o )
                  %span.nv _append_flag
                  = succeed "1" do
                    %span.o =
                  ;;
                  = succeed "to" do
                    %span.o (
                  %span.o )
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  = succeed "*" do
                    %span.o (
                  %span.o )
                  %span.nv _message
                  %span.o =
                  %span.s2 &quot;${_token}&quot;
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_message:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot log a message as no message was given.&quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o ((
                  %span.nv _append_flag
                  %span.o ==
                  1
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nb printf
                  %span.s2 &quot;${_message}\n&quot;
                  \&gt;&gt;
                  %span.s2 &quot;${_file}&quot;
                  %span.k else
                  %span.k                   %span.nb printf
                  %span.s2 &quot;${_message}\n&quot;
                  \&gt;
                  %span.s2 &quot;${_file}&quot;
                  %span.k fi
                  %span.k else
                  %span.k                   %span.nb printf
                  %span.s2 &quot;${_message}\n&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 info()
              %p Log arguments to the calling environments STDOUT preceeded by 'INFO .
              %h3 Input Parameters
              %p Strings to be logged.
              %h3 Stream Outputs
              %p
                Prints arguments passed in to the calling environments STDOUT with a newline
                character appended and 'INFO ' prepended.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no arguments are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ info "Hello there! "
                    INFO Hello there!
            %td.code
              .highlight
                %pre
                  info
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;INFO: $*&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 warn()
              %p Log arguments to the calling environments STDOUT preceeded by 'WARNING .
              %h3 Input Parameters
              %p Strings to be logged.
              %h3 Stream Outputs
              %p
                Prints arguments passed in to the calling environments STDOUT with a newline
                character appended and 'WARNING ' prepended.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no arguments are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ info "Bad Monkeys are Typing! "
                    WARNING: Bad Monkeys are Typing!
            %td.code
              .highlight
                %pre
                  warn
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;WARNING: $*&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 note()
              %p Log arguments to the calling environments STDOUT preceeded by 'NOTE .
              %h3 Input Parameters
              %p Strings to be logged.
              %h3 Stream Outputs
              %p
                Prints arguments passed in to the calling environments STDOUT with a newline
                character appended and 'NOTE ' prepended.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no arguments are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ info "You are not Smurfette! "
                    NOTE You are not Smurfette!
            %td.code
              .highlight
                %pre
                  note
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;NOTE: $*&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 debug()
              %p Log arguments to the calling environments STDOUT preceeded by 'DEBUG: .
              %h3 Input Parameters
              %p Strings to be logged.
              %h3 Stream Outputs
              %p
                Prints arguments passed in to the calling environments STDOUT with a newline
                character appended and 'DEBUG: ' prepended.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no arguments are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ debug "Hello there! "
                    DEBUG: Hello there!
            %td.code
              .highlight
                %pre
                  debug
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o ((
                  %span.k ${
                  %span.nv debug_flag
                  %span.p :=0
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;DEBUG: $*&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 error()
              %p
                Log arguments to the calling environments STDERR preceeded by 'ERROR '.
                Exits with status code 1.
              %h3 Input Parameters
              %p Strings to be logged.
              %h3 Stream Outputs
              %p
                Prints arguments passed in to the calling environments STDOUT with a newline
                character appended and 'ERROR ' prepended.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 1 for failure.
              %h3 Failure Scenarios
              %p Fails if no arguments are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ error "Hello there! "
                    ERROR Hello there!
                    *poof* shell closed...
            %td.code
              .highlight
                %pre
                  error
                  %span.o ()
                  %span.o {
                  %span.nb set
                  +o xtrace
                  log
                  %span.s2 &quot;\nERROR: $*&quot;
                  \&gt;&amp;2
                  disable_backtrace
                  = succeed "1" do
                    %span.nb exit
                  %span.o }
          %tr
            %td.docs
              %h2 succeed()
              %p Log arguments to the calling environments STDOUT. Exits with status code 0.
              %h3 Input Parameters
              %p Strings to be logged.
              %h3 Stream Outputs
              %p
                Prints arguments passed in to the calling environments STDOUT with a newline
                character appended.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no arguments are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ succeed "Hello there! "
                    Hello there!
                    *poof* shell closed...
            %td.code
              .highlight
                %pre
                  succeed
                  %span.o ()
                  %span.o {
                  %span.nb set
                  +o xtrace
                  log
                  %span.s2 &quot;$*&quot;
                  = succeed "0" do
                    %span.nb exit
                  %span.o }
          %tr
            %td.docs
              %h2 fail()
              %p
                Log arguments to the calling environments STDERR preceeded by 'ERROR '.
                Exits with status code 1.
              %h3 Input Parameters
              %p Strings to be logged.
              %h3 Stream Outputs
              %p
                Prints arguments passed in to the calling environments STDOUT with a newline
                character appended and 'ERROR ' prepended.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 1 for failure.
              %h3 Failure Scenarios
              %p Fails if no arguments are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ error "Hello there! "
                    ERROR Hello there!
                    *poof* shell closed...
            %td.code
              .highlight
                %pre
                  fail
                  %span.o ()
                  %span.o {
                  %span.nv trace_flag
                  = succeed "0" do
                    %span.o =
                  backtrace
                  %span.s2 &quot;$*&quot;
                  = succeed "1" do
                    %span.nb exit
                  %span.o }
          %tr
            %td.docs
              %h2 verbose()
              %p
                Log arguments to the calling environments STDERR preceeded by 'ERROR '.
                Exits with status code 1.
              %h3 Input Parameters
              %p Strings to be logged.
              %h3 Stream Outputs
              %p
                Prints arguments passed in to the calling environments STDOUT with a newline
                character appended and 'ERROR ' prepended.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 1 for verboseure.
              %h3 verboseure Scenarios
              %p verboses if no arguments are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ verbose "w00t! "
                    user$ verbose_flag=1
                    user$ verbose "w00t! "
                    w00t!
            %td.code
              .highlight
                %pre
                  verbose
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o ((
                  %span.k ${
                  %span.nv verbose_flag
                  %span.p :=0
                  %span.k }
                  %span.o ==
                  1
                  %span.o ))
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;$*&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 logrotate()
              %p Strategically rotate a logfile minimizing data loss.
              %p This function uses a copy, tail and truncate strategy.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    root# logrotate /var/log/my_logfile.log
            %td.code
              .highlight
                %pre
                  logrotate
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot rotate a log file as no log file was given.&quot;
                  %span.k fi
                  = succeed "set_timestamp" do
                    %span.k                   verbose
                  %span.s2 &quot;Tailing the file in a background process into a tail logfile.&quot;
                  %span.o (
                  tail -n 0 -f
                  %span.s2 &quot;${_file}&quot;
                  \&gt;
                  %span.k ${
                  %span.nv file
                  = succeed "." do
                    %span.k }
                  = succeed ".log" do
                    %span.nv $$
                  = succeed "&amp;amp;" do
                    %span.o )
                  %span.nb local
                  %span.nv _tail_pid
                  %span.o =
                  %span.nv $!
                  verbose
                  %span.s2 &quot;Copying the file's contentes into a new timestamped file.&quot;
                  cp
                  %span.s2 &quot;${_file}&quot;
                  %span.s2 &quot;${_file}.${timestamp}&quot;
                  verbose
                  %span.s2 &quot;Truncating the file.&quot;
                  cp /dev/null
                  %span.k ${
                  %span.nv _file
                  %span.k }
                  verbose
                  %span.s2 &quot;Signaling the tail background process to stop.&quot;
                  %span.nb kill
                  \-QUIT
                  %span.k ${
                  %span.nv _tail_pid
                  %span.k }
                  verbose
                  %span.s2 &quot;Appending the tail logfile to the new timestamped logfile.&quot;
                  cat
                  %span.s2 &quot;${file}.$$.log&quot;
                  \&gt;&gt;
                  %span.s2 &quot;${file}.${timestamp}&quot;
                  verbose
                  %span.s2 &quot;Compressing the timestamped file (gzip)&quot;
                  gzip -f -9
                  %span.s2 &quot;${file}.${timestamp}&quot;
                  verbose
                  %span.s2 &quot;Removing the tail logfile&quot;
                  rm
                  %span.s2 &quot;${file}.$$.log&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 log_streams()
              %p
                Log streams to three files:
                \- standard out
                \- standard in
                \- combined (what the user typically sees)
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    root# log_streams "make install" prefix make
                    cat make.out.log
                    root#
                    ...
              %p Alternatively,
              %pre
                %code
                  :preserve
                    root# log_streams "make install" \
                          out /path/to/out.log \
                          err /path/to/err.log \
                          mix /path/to/mix.log # both out &amp; err as they occurred.
                    root# cat /path/to/mix.log
                    ...
            %td.code
              .highlight
                %pre
                  log_streams
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _command
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _prefix _err _out _mix
          %tr
            %td.docs
              %p TODO: allow specification of path, name prefix
            %td.code
              .highlight
                %pre
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv _token
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${token}&quot;
                  in
                  prefix
                  %span.o )
                  %span.nv _prefix
                  %span.o =
                  %span.s2 &quot;${1}.&quot;
                  ;;
                  err
                  %span.o )
                  %span.nv _stderr
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  out
                  %span.o )
                  %span.nv _stdout
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  mix
                  %span.o )
                  %span.nv _stdmix
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  *
                  %span.o )
                  %span.nv _command
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  %span.k esac
                  %span.k done
                  \:
                  %span.se \
                  %span.s2 &quot;${_stdout=&quot;
                  %span.k ${
                  %span.nv 2
                  %span.k :-
                  %span.nv stdout
                  %span.p .log
                  %span.k }
                  %span.s2 &quot;}&quot;
                  %span.se \
                  %span.s2 &quot;${_stderr=&quot;
                  %span.k ${
                  %span.nv 3
                  %span.k :-
                  %span.nv stderr
                  %span.p .log
                  %span.k }
                  %span.s2 &quot;}&quot;
                  %span.se \
                  %span.s2 &quot;${_stdmix=&quot;
                  %span.k ${
                  %span.nv 4
                  %span.k :-
                  %span.nv stdmix
                  %span.p .log
                  %span.k }
                  %span.s2 &quot;}&quot;
                  %span.o {
                  %span.o {
                  %span.k ${
                  %span.nv _command
                  %span.k }
                  2&gt;&amp;1 1&gt;&amp;3 | tee
                  %span.s2 &quot;${_stderr}&quot;
                  %span.o }
                  3&gt;&amp;1 1&gt;&amp;2 | tee
                  %span.s2 &quot;${_stdout}&quot;
                  %span.o }
                  \&gt;
                  %span.s2 &quot;${_stdmix}&quot;
                  2&gt;&amp;1
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 set_ps4()
              %p Set the environmental PS4 variable for informative tracing.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ echo "'$PS4'"
                    '+ '
                    user$ set_ps4
                    user$ echo "'$PS4'"
                    ' &gt; ${BASH_SOURCE##${bdsm_path}\/} ${FUNCNAME[0]:+${FUNCNAME[0]}()} ${LINENO} $ '
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  set_ps4
                  %span.o ()
                  %span.o {
                  %span.nv PS4
                  %span.o =
                  %span.s2 &quot; &gt; \${BASH_SOURCE##\${bdsm_path}\/} \${FUNCNAME[0]:+\${FUNCNAME[0]}()} \${LINENO} $ &quot;
                  = succeed "PS4" do
                    %span.nb export
                  %span.o }
          %tr
            %td.docs
              %h2 trace()
              %p
                Toggle tracing functionality on or off. If 'on' is triggered then every line
                of code execution after the function returns will be displayed in the format
                specified by the PS4 environment variable (see set_ps4).
              %h3 Input Parameters
              %p First parameter is either empty, 'on' or 'off'
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ trace on
                    user$ echo "hi"
                    &gt;   1 $ echo hi
                    user$ trace off
                    &gt;  trace() 1 $ local _option=off
                    &gt;  trace() 3 $ [[ off = \o\n ]]
                    &gt;  trace() 8 $ set +o xtrace
            %td.code
              .highlight
                %pre
                  trace
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _option
                  %span.o =
                  %span.s2 &quot;${1:-on}&quot;
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;${_option}&quot;
                  %span.o =
                  %span.s2 &quot;on&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb export
                  %span.nv trace_flag
                  = succeed "1" do
                    %span.o =
                  %span.nb set
                  \-o xtrace
                  %span.k else
                  %span.k                   %span.nb set
                  +o xtrace
                  %span.nb export
                  %span.nv trace_flag
                  = succeed "0" do
                    %span.o =
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 enable_trace()
              %p Turns tracing on.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ enable_trace
            %td.code
              .highlight
                %pre
                  enable_trace
                  %span.o ()
                  %span.o {
                  trace on
                  %span.o }
          %tr
            %td.docs
              %h2 disable_trace()
              %p Turns tracing off.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No current failure scenarios.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ disable_trace
            %td.code
              .highlight
                %pre
                  disable_trace
                  %span.o ()
                  %span.o {
                  trace off
                  %span.o }
          %tr
            %td.docs
              %h2 debug()
              %p
                Toggle verbose debugging functionality on or off. If 'on' is triggered then
                every line of code execution after the function returns will be displayed.
              %h3 Input Parameters
              %p First parameter is either empty, 'on' or 'off'
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ debug on
                    user$ echo "hi"
                    &gt;   1 $ echo hi
                    user$ debug off
                    &gt;  debug() 1 $ local _option=off
                    &gt;  debug() 3 $ [[ off = \o\n ]]
                    &gt;  debug() 8 $ set +o xdebug
            %td.code
              .highlight
                %pre
                  debug
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _option
                  %span.o =
                  %span.s2 &quot;${1:-on}&quot;
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;${_option}&quot;
                  %span.o =
                  %span.s2 &quot;on&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  %span.k                   %span.nb export
                  %span.nv debug_flag
                  = succeed "1" do
                    %span.o =
                  %span.nb set
                  \-o verbose
                  %span.k else
                  %span.k                   %span.nb set
                  +o verbose
                  %span.nb export
                  %span.nv debug_flag
                  = succeed "0" do
                    %span.o =
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 enable_debug()
              %p Enables verbose debugging output.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ enable_debug
            %td.code
              .highlight
                %pre
                  enable_debug
                  %span.o ()
                  %span.o {
                  debug on
                  %span.o }
          %tr
            %td.docs
              %h2 disable_debug()
              %p Disables verbose debugging output.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ disable_debug
            %td.code
              .highlight
                %pre
                  disable_debug
                  %span.o ()
                  %span.o {
                  debug off
                  %span.o }
          %tr
            %td.docs
              %h2 enable_backtrace()
              %p
                Enables backtrace and program exit whenever a command returns a nonzero value
                that is not handled.
              %h3 Input Parameters
              %p
                First parameter is optional. If it is passed it is a message that will be
                outputed when a command trigger the program to error exit.
              %h3 Stream Outputs
              %p What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat ./test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules trace # Load the trace module.
                    enable_backtrace
                    echo "Error exit with backtrace is now off."
                    false # Does not cause exiting with backtrace printing.
                    
                    user$ $PWD/test
                    Error exit with backtrace is on.
                    ERROR: A command has returned an unhandled error code (nonzero return value).
                    Error Backtrace:
                       Trace   Function           Line  File
                          1.   main()                7  /Users/wayneeseguin/test
            %td.code
              .highlight
                %pre
                  enable_backtrace
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _message
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_message}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb trap
                  %span.s2 &quot;backtrace \&quot;${_message}\&quot;&quot;
                  ERR
                  %span.k else
                  %span.k                   %span.nb trap
                  %span.s2 &quot;backtrace \&quot;A command has returned an unhandled error code (nonzero return value).\&quot;&quot;
                  ERR
                  %span.k fi
                  %span.k                   %span.nb set
                  \-o errexit
                  %span.o }
          %tr
            %td.docs
              %h2 function_name()
              %p Function Description
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat ./test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules trace # Load the trace module.
                    disable_backtrace
                    echo "Error exit with backtrace is now off."
                    false # Does not cause exiting with backtrace printing.
                    
                    user$ ./test
                    Error exit with backtrace is now off.
            %td.code
              .highlight
                %pre
                  disable_backtrace
                  %span.o ()
                  %span.o {
                  %span.nb set
                  +o errexit
                  %span.nb trap
                  \- ERR
                  %span.o }
          %tr
            %td.docs
              %h2 backtrace()
              %p
                Display a backtrace of the current call stack to the point that backtrace was
                called from. Currently trace is turned on as well so that execution after
                calling backtrace is traced.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                The call stack up to the current point of execution is printed to STDOUT of
                the calling environment.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat ./test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules trace # Load the trace module.
                    
                    functiona()
                    {
                      echo "function a"
                      functionb
                      echo "function a"
                    }
                    
                    functionb()
                    {
                      echo "function b"
                      functionc
                      echo "function b"
                    }
                    
                    functionc()
                    {
                      echo "function c"
                      backtrace
                      echo "function c"
                    }
                    
                    functiona
                    
                    user$ $PWD/test
                    function a
                    function b
                    function c
                    Error Backtrace:
                       Trace   Line Function             File
                          4.     25 functionc()          /Users/wayneeseguin/test
                          3.     18 functionb()          /Users/wayneeseguin/test
                          2.     11 functiona()          /Users/wayneeseguin/test
                          1.     29 main()               /Users/wayneeseguin/test
                     &gt; /Users/wayneeseguin/test functionc() 26 $ echo 'function c'
                    function c
                     &gt; /Users/wayneeseguin/test functionb() 19 $ echo 'function b'
                    function b
                     &gt; /Users/wayneeseguin/test functiona() 12 $ echo 'function a'
                    function a
            %td.code
              .highlight
                %pre
                  backtrace
                  %span.o ()
                  %span.o {
                  %span.nb set
                  +o xtrace
                  = succeed "_separator" do
                    %span.nb local
                  %span.nv _columns
                  %span.o =
                  = succeed "tput" do
                    %span.k $(
                  cols
                  %span.k )
                  %span.nb printf
                  \-v _separator
                  %span.s1 '%*s'
                  %span.s2 &quot;${_columns:-${COLUMNS:-80}}&quot;
                  %span.nb local
                  %span.nv _message
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_message}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb printf
                  %span.s2 &quot;\n${_message}\n\n&quot;
                  %span.k fi
                  %span.k                   = succeed "_source" do
                    %span.nb local
                  _function _line _index _largest _format _digits _longest
                  %span.k for
                  %span.o ((
                  %span.nv _index
                  = succeed "0" do
                    %span.o =
                  ; _index &lt;
                  %span.k ${#
                  %span.nv FUNCNAME
                  %span.p [@]
                  %span.k }
                  ; _index++
                  %span.o ))
                  %span.k do
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv FUNCNAME
                  %span.p [
                  %span.k ${
                  %span.nv _index
                  %span.k }
                  %span.p ]
                  %span.k }
                  \&gt;
                  %span.k ${#
                  %span.nv _largest
                  %span.k }
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nv _largest
                  %span.o =
                  %span.k ${
                  %span.nv FUNCNAME
                  %span.p [
                  %span.k ${
                  %span.nv _index
                  %span.k }
                  %span.p ]
                  %span.k }
                  %span.k fi
                  %span.k done
                  %span.k for
                  %span.o ((
                  %span.nv _index
                  = succeed "0" do
                    %span.o =
                  ; _index &lt;
                  %span.k ${#
                  %span.nv BASH_SOURCE
                  %span.p [@]
                  %span.k }
                  ; _index++
                  %span.o ))
                  %span.k do
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv BASH_SOURCE
                  %span.p [
                  %span.k ${
                  %span.nv _index
                  %span.k }
                  %span.p ]
                  %span.k }
                  \&gt;
                  %span.k ${#
                  %span.nv _longest
                  %span.k }
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nv _longest
                  %span.o =
                  %span.k ${
                  %span.nv BASH_SOURCE
                  %span.p [
                  %span.k ${
                  %span.nv _index
                  %span.k }
                  %span.p ]
                  %span.k }
                  %span.k fi
                  %span.k done
                  %span.k for
                  %span.o ((
                  %span.nv _index
                  = succeed "0" do
                    %span.o =
                  ; _index &lt;
                  %span.k ${#
                  %span.nv BASH_LINENO
                  %span.p [@]
                  %span.k }
                  ; _index++
                  %span.o ))
                  %span.k do
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv BASH_LINENO
                  %span.p [
                  %span.k ${
                  %span.nv _index
                  %span.k }
                  %span.p ]
                  %span.k }
                  \&gt;
                  %span.k ${#
                  %span.nv _digits
                  %span.k }
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nv _digits
                  %span.o =
                  %span.k ${
                  %span.nv BASH_LINENO
                  %span.p [
                  %span.k ${
                  %span.nv _index
                  %span.k }
                  %span.p ]
                  %span.k }
                  %span.k fi
                  %span.k done
                  %span.k case
                  %span.s2 &quot;${EDITOR:-}&quot;
                  in
                  = succeed "mvim*|mate*" do
                    %span.o (
                  %span.o )
                  %span.c #_format=&quot; %-$((${#_largest} + 2))s %-$((${#EDITOR} + ${#_digits} + 19 + ${#_longest}))s\n&quot;
                  %span.nv _format
                  %span.o =
                  %span.s2 &quot;%-$((${#_largest} + 2))s %-s\n&quot;
                  %span.nb printf
                  %span.s2 &quot;${_format}&quot;
                  %span.s2 &quot;function()&quot;
                  %span.s2 &quot;Source&quot;
                  1&gt;&amp;2
                  ;;
                  = succeed "vi*|gvim*|emacs*|*" do
                    %span.o (
                  %span.o )
                  %span.nv _format
                  %span.o =
                  %span.s2 &quot;%-$((${#_largest} + 2))s $ %${#EDITOR}s +%-$((${#_digits}))s %-$((${#_longest} + 2))s %s\n&quot;
                  %span.nb printf
                  %span.s2 &quot;${_format}&quot;
                  %span.s2 &quot;function()&quot;
                  %span.s1 ' '
                  %span.s2 &quot;#&quot;
                  %span.s2 &quot;source file&quot;
                  1&gt;&amp;2
                  
                  ;;
                  %span.k esac
                  %span.k                   %span.nb printf
                  %span.s2 &quot;${_separator// /=}\n&quot;
                  1&gt;&amp;2
                  %span.k for
                  %span.o ((
                  %span.nv _index
                  = succeed "1" do
                    %span.o =
                  ; _index &lt;
                  %span.k ${#
                  %span.nv FUNCNAME
                  %span.p [@]
                  %span.k }
                  ; ++_index
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv _source
                  %span.o =
                  %span.s2 &quot;${BASH_SOURCE[${_index}]}&quot;
                  %span.nv _function
                  %span.o =
                  %span.s2 &quot;${FUNCNAME[${_index}]:+${FUNCNAME[${_index}]}()}&quot;
                  %span.nv _line
                  %span.o =
                  %span.k ${
                  %span.nv BASH_LINENO
                  %span.p [
                  %span.k $((
                  _index
                  %span.o -
                  %span.m 1
                  %span.k ))
                  %span.p ]
                  %span.k }
                  %span.k case
                  %span.s2 &quot;$_function&quot;
                  in
                  fail
                  %span.se> \(\)
                  |error
                  %span.se> \(\)
                  |command_not_found_handle
                  %span.se> \(\)
                  |command_not_found
                  %span.se \(\)
                  %span.o )
                  %span.k continue
                  ;;
                  %span.k esac
                  %span.k case
                  %span.s2 &quot;${EDITOR:-}&quot;
                  in
                  = succeed "mvim*|mate*" do
                    %span.o (
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;${_format}&quot;
                  %span.s2 &quot;${_function}&quot;
                  %span.s2 &quot;${EDITOR// *}://open?url=file://${_source}&amp;line=${_line}&quot;
                  1&gt;&amp;2
                  ;;
                  = succeed "vi*|gvim*|emacs*|*" do
                    %span.o (
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;${_format}&quot;
                  %span.s2 &quot;${_function}&quot;
                  %span.s2 &quot;${EDITOR}&quot;
                  %span.s2 &quot;${_line}&quot;
                  %span.s2 &quot;${_source} &quot;
                  1&gt;&amp;2
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k                   %span.nb printf
                  %span.s2 &quot;${_separator// /=}\n&quot;
                  1&gt;&amp;2
                  %span.k if
                  %span.o ((
                  trace_flag &gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "enable_trace" do
                    %span.k                   %span.k fi
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2
                user
                %em> create
                if_missing()
              %p Create a system user if it does not exist on the system.
              %h3 Input Parameters
              %p
                The first parameter should be the user name, then optionally
                [with] group {{groupname}}
              %h3 Stream Outputs
              %p What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
              %h3 Environmental effects
              %p What, if any, environmental side effects this function causes. 'None.' for none.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no username is given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ user_create_if_missing "nginx" with group "nginx"
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  user_create_if_missing
                  %span.o ()
                  %span.o {
                  = succeed "_token" do
                    %span.nb local
                  _group
          %tr
            %td.docs
              %p parse arguments
            %td.code
              .highlight
                %pre
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  ;
                  %span.k do
                  %span.k                   %span.nv _token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  ;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${_token}&quot;
                  in
                  group
                  %span.o )
                  %span.nv _group
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  ;
                  %span.nb shift
                  ;;
                  with
                  %span.o )
                  %span.k continue
                  %span.c # Syntatic sugar, ignore, next!
                  ;;
                  from
                  %span.o )
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  ;
                  %span.nb shift
                  ;;
                  \--force
                  %span.o )
                  %span.nv _force_flag
                  = succeed "1" do
                    %span.o =
                  ;;
                  
                  *
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_group}&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  %span.k                   %span.nv _group
                  %span.o =
                  %span.s2 &quot;${_token}&quot;
                  %span.nb break
                  %span.nb                   %span.k fi
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o ((
                  %span.nv UID
                  %span.o ==
                  0
                  %span.o ))
                  ;
                  %span.k then
                  %span.o (
                  %span.k case
                  %span.s2 &quot;$(uname)&quot;
                  in
                  %span.s2 &quot;OpenBSD&quot;
                  %span.o )
                  groupadd
                  %span.s2 &quot;$package_user&quot;
                  useradd -g
                  %span.s2 &quot;$package_user&quot;
                  %span.s2 &quot;$package_user&quot;
                  \-s /bin/bash
                  usermod -s /bin/bash
                  %span.s2 &quot;$package_user&quot;
                  ;;
                  %span.s2 &quot;FreeBSD&quot;
                  %span.o )
                  pw groupadd -q
                  %span.s2 &quot;$package_user&quot;
                  ;;
                  %span.s2 &quot;Linux&quot;
                  %span.o )
          %tr
            %td.docs
              %p
                groupadd nginx
                useradd -G nginx -M nginx
            %td.code
              .highlight
                %pre
                  %span.k if
                  %span.o [[
                  \-f
                  %span.s2 &quot;/etc/SuSE-release&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  = succeed "groupadd" do
                    %span.k                   %span.s2 &quot;$package_user&quot;
                  %span.k else
                  = succeed "groupadd" do
                    %span.k                   \-f
                  %span.s2 &quot;$package_user&quot;
                  %span.k fi
                  = succeed "useradd" do
                    %span.k                   \-g
                  %span.s2 &quot;${package_user}&quot;
                  %span.s2 &quot;${package_user}&quot;
                  usermod -d
                  %span.s2 &quot;${data_path%\/*}&quot;
                  %span.s2 &quot;${package_user}&quot;
                  usermod -s /bin/bash
                  %span.s2 &quot;${package_user}&quot;
                  ;;
                  %span.s2 &quot;Darwin&quot;
                  %span.o )
                  %span.nv current_max_gid
                  %span.o =
                  = succeed "dscl" do
                    %span.k $(
                  \. -list /Groups gid | awk
                  %span.s1 '{print $2}'
                  | sort -g -r | head -1
                  %span.k )
                  %span.nv next_gid
                  %span.o =
                  = succeed "current_max_gid+1" do
                    %span.k $((
                  %span.k ))
                  %span.nv current_max_uid
                  %span.o =
                  = succeed "dscl" do
                    %span.k $(
                  \. -list /Users UniqueID | awk
                  %span.s1 '{print $2}'
                  | sort -g -r | head -1
                  %span.k )
                  %span.nv next_uid
                  %span.o =
                  = succeed "current_max_uid+1" do
                    %span.k $((
                  %span.k ))
                  %span.k if
                  \! dscl . -list /Users | grep -q
                  %span.s2 &quot;^${package_user}$&quot;
                  ;
                  %span.k then
                  = succeed "dscl" do
                    %span.k                   \. -create
                  %span.s2 &quot;/Groups/$package_user&quot;
                  dscl . -create
                  %span.s2 &quot;/Groups/$package_user&quot;
                  gid
                  %span.s2 &quot;$next_gid&quot;
                  dscl . -create
                  %span.s2 &quot;/Users/${package_user}&quot;
                  dscl . -create
                  %span.s2 &quot;/Users/${package_user}&quot;
                  PrimaryGroupID
                  %span.s2 &quot;$gid&quot;
                  %span.c # UserShell /bin/bash
                  dscl . -create
                  %span.s2 &quot;/Users/${package_user}&quot;
                  uid
                  %span.s2 &quot;$next_uid&quot;
                  dscl . -create
                  %span.s2 &quot;/Users/${package_user}&quot;
                  realname
                  %span.s2 &quot;Postgresql User&quot;
                  dscl . -create
                  %span.s2 &quot;/Users/${package_user}&quot;
                  home
                  %span.s2 &quot;${data_path%\/*}&quot;
                  dscl . -create
                  %span.s2 &quot;/Users/${package_user}&quot;
                  shell
                  %span.s2 &quot;/bin/bash&quot;
                  dscl . -create
                  %span.s2 &quot;/Users/${package_user}&quot;
                  gid
                  %span.s2 &quot;$gid&quot;
                  dscl . -create
                  %span.s2 &quot;/Users/${package_user}&quot;
                  passwd
                  %span.s2 &quot;*&quot;
                  %span.k fi
                  ;;
                  %span.s2 &quot;SunOS&quot;
                  %span.o )
                  groupadd
                  %span.s2 &quot;$package_user&quot;
                  useradd -g
                  %span.s2 &quot;$package_user&quot;
                  \-s /bin/bash -d
                  %span.s2 &quot;${data_path}&quot;
                  %span.s2 &quot;$package_user&quot;
                  usermod -s /bin/bash
                  %span.s2 &quot;$package_user&quot;
                  ;;
                  %span.k esac
                  %span.o )
                  %span.o ||
                  %span.nb true
                  %span.c # Ignore failures with this for now...
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Users and groups may be manipulated only by the super user (root) via su or sudo.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 user_delete()
              %p Deletes the named system user.
              %h3 Input Parameters
              %p The first parameter is the system user to delete.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p The given user will no longer exist on the system.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if the user name was not specified.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ user_delete "nginx"
            %td.code
              .highlight
                %pre
                  user_delete
                  %span.o ()
                  %span.o {
                  = succeed "_token" do
                    %span.nb local
                  _group
          %tr
            %td.docs
              %p parse arguments
            %td.code
              .highlight
                %pre
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  ;
                  %span.k do
                  %span.k                   %span.nv _token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  ;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${_token}&quot;
                  in
                  group
                  %span.o )
                  %span.nv _group
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  ;
                  %span.nb shift
                  ;;
                  with
                  %span.o )
                  %span.k continue
                  %span.c # Syntatic sugar, ignore, next!
                  ;;
                  from
                  %span.o )
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  ;
                  %span.nb shift
                  ;;
                  \--force
                  %span.o )
                  %span.nv _force_flag
                  = succeed "1" do
                    %span.o =
                  ;;
                  
                  *
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_group}&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  %span.k                   %span.nv _group
                  %span.o =
                  %span.s2 &quot;${_token}&quot;
                  %span.nb break
                  %span.nb                   %span.k fi
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o ((
                  %span.nv UID
                  %span.o ==
                  0
                  %span.o ))
                  ;
                  %span.k then
                  %span.o (
                  %span.k case
                  %span.s2 &quot;$(uname)&quot;
                  in
                  %span.s2 &quot;OpenBSD&quot;
                  %span.o )
                  groupdel
                  %span.s2 &quot;$package_user&quot;
                  userdel -g
                  %span.s2 &quot;$package_user&quot;
                  %span.s2 &quot;$package_user&quot;
                  ;;
                  %span.s2 &quot;FreeBSD&quot;
                  %span.o )
                  pw groupdel -q
                  %span.s2 &quot;$package_user&quot;
                  ;;
                  %span.s2 &quot;Linux&quot;
                  %span.o )
                  userdel
                  %span.s2 &quot;${package_user}&quot;
                  ;;
                  %span.s2 &quot;Darwin&quot;
                  %span.o )
                  %span.nv gid
                  %span.o =
                  %span.s2 &quot;501&quot;
                  %span.c #only gids &gt; 500 show up in user preferences
                  %span.c #Find an open gid
                  %span.k while
                  = succeed ";" do
                    %span.nb true
                  %span.k do
                  %span.k                   %span.nv name
                  %span.o =
                  = succeed "dscl" do
                    %span.k $(
                  \. search /groups PrimaryGroupID
                  %span.nv $gid
                  | cut -f1 -s
                  %span.k )
                  %span.k if
                  %span.o [
                  \-z
                  %span.s2 &quot;$name&quot;
                  %span.o ]
                  ;
                  %span.k then
                  %span.k                   %span.nb break
                  %span.nb                   %span.k fi
                  %span.k                   %span.nv gid
                  %span.o =
                  %span.nv $[$gid
                  +1
                  %span.o ]
                  %span.k done
                  %span.c #Create the group
                  dscl . -delete
                  %span.s2 &quot;/Users/${package_user}&quot;
                  PrimaryGroupID
                  %span.s2 &quot;$gid&quot;
                  %span.c # UserShell /bin/bash
                  dscl . -delete
                  %span.s2 &quot;/Groups/$package_user&quot;
                  dscl . -delete
                  %span.s2 &quot;/Groups/$package_user&quot;
                  gid
                  %span.s2 &quot;$gid&quot;
                  ;;
                  %span.s2 &quot;SunOS&quot;
                  %span.o )
                  groupdel
                  %span.s2 &quot;$package_user&quot;
                  userdel
                  %span.s2 &quot;$package_user&quot;
                  ;;
                  %span.k esac
                  %span.o )
                  %span.o ||
                  %span.nb true
                  %span.c # Ignore failures with this for now...
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Users and groups may be manipulated only by the super user (root) via su or sudo.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                user
                %em> is
                root()
              %p Tests if the user the current process is running as is root.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if user is root (UID 0).
                1 if user is not root (UID 0).
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ user_is_root
                    user$ echo $?
                    1
                    
                    root# user_is_root
                    root# echo $?
                    0
            %td.code
              .highlight
                %pre
                  user_is_root
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o ((
                  %span.nv UID
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                user
                %em> is
                not_root()
              %p Tests if the user the current process is running as is not root.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if user is not root (eg UID is nonzero)
                1 if user is root (UID 0)
              %h3 Failure Scenarios
              %p No failure scenarios currently
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ user_is_not_root
                    user$ echo $?
                    0
                    
                    root# user_is_not_root
                    root# echo $?
                    1
            %td.code
              .highlight
                %pre
                  user_is_not_root
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o ((
                  UID !
                  %span.o =
                  0
                  %span.o ))
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                user
                %em> must
                be_root()
              %p Halts the calling program with a failure message if the user is not root.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p A failure message is output to STDERR if the failure condition is met.
              %h3 Environmental effects
              %p What, if any, environmental side effects this function causes. 'None.' for none.
              %h3 Return Codes
              %p 0 if the user is root
              %h3 Failure Scenarios
              %p Fails if the program user running is not root.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ user_must_be_root
                    ERROR: bdsm test test must be run as root and NOT as a user(user)
            %td.code
              .highlight
                %pre
                  user_must_be_root
                  %span.o ()
                  %span.o {
                  user_is_root
                  %span.o ||
                  fail
                  %span.s2 &quot;bdsm $extension $action must be run as a root and NOT as a user ($USER).&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                user
                %em> must
                not
                %em> be
                root()
              %p Halts the calling program with a failure message if the user is not root.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p A failure message is output to STDERR if the failure condition is met.
              %h3 Environmental effects
              %p What, if any, environmental side effects this function causes. 'None.' for none.
              %h3 Return Codes
              %p 0 if the user is root
              %h3 Failure Scenarios
              %p Fails if the program user running is root.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ user_must_not_be_root
                    ERROR: bdsm test test must be run as a (project) user and NOT as a root.
            %td.code
              .highlight
                %pre
                  user_must_not_be_root
                  %span.o ()
                  %span.o {
                  user_is_not_root
                  %span.o ||
                  fail
                  %span.s2 &quot;bdsm $extension $action must be run as a (project) user and NOT as root.&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                user
                %em> run
                as()
              %p Runs a command as a given user.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Any stream outputs of the command being run.
              %h3 Environmental effects
              %p Any environmental effects of the command being run.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no user was specified.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    root# user_run_as "user" pwd
                    /home/user
            %td.code
              .highlight
                %pre
                  user_run_as
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _user
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_user:-}&quot;
                  %span.o ]]
                  %span.o ||
                  fail
                  %span.s2 &quot;Cannot run as user as no user or commands were given.&quot;
                  %span.nb shift
                  = succeed "su" do
                    %span.nb                   %span.s2 &quot;${_user}&quot;
                  \-c
                  %span.s2 &quot;$*&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                user
                %em> run
                as_login()
              %p Runs a command as a given user, in that users login shell.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Any stream outputs of the command being run.
              %h3 Environmental effects
              %p Any environmental effects of the command being run.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no user was specified.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    root# user_run_as_login "deploy" bdsm unicorn restart
                    &lt;&lt; unicorn restart output &gt;&gt;
            %td.code
              .highlight
                %pre
                  user_run_as_login
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _user
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_user:-}&quot;
                  %span.o ]]
                  %span.o ||
                  fail
                  %span.s2 &quot;Cannot run as login user as no user or commands were given.&quot;
                  %span.nb shift
                  = succeed "su" do
                    %span.nb                   \-
                  %span.s2 &quot;${_user}&quot;
                  \-c
                  %span.s2 &quot;$*&quot;
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 show_help()
              %p
                Display help for the current extension based on settings declared in the help
                action.
              %h3 Input Parameters
              %p First parameter is the help section to display, default is all sections 'usage'.
              %h3 Stream Outputs
              %p Prints out formatted help sections to the calling environments STDOUT stream.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ show_help usage
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  show_help
                  %span.o ()
                  %span.o {
                  = succeed "_help_command" do
                    %span.nb local
                  _token
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  ;
                  %span.k do
                  %span.k                   %span.nv _token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  ;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${_token}&quot;
                  in
                  desc*|description
                  %span.o )
                  %span.nv _help_command
                  %span.o =
                  %span.s2 &quot;description&quot;
                  ;;
                  actions
                  %span.o )
                  %span.nv _help_command
                  %span.o =
                  %span.s2 &quot;actions&quot;
                  ;;
                  usage
                  %span.o )
                  %span.nv _help_command
                  %span.o =
                  %span.s2 &quot;usage&quot;
                  ;;
                  %span.k esac
                  %span.k done
                  %span.s2 &quot;${_help_command:-usage}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 description()
              %p Set the string that will be printed when the actions help section is output.
              %h3 Input Parameters
              %p First parameter is a string containing a description of the extension.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Fails if no description is given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ description "This extension handles X Y and Z."
            %td.code
              .highlight
                %pre
                  description
                  %span.o ()
                  %span.o {
                  %span.o [[
                  \-n
                  %span.s2 &quot;$*&quot;
                  %span.o ]]
                  %span.o ||
                  fail
                  %span.s2 &quot;Cannot add description to help as no help description was given.&quot;
                  help_descriptions+
                  %span.o =(
                  %span.s2 &quot;$*&quot;
                  %span.o )
                  %span.o }
          %tr
            %td.docs
              %h2 help_description()
              %p Outputs the collected help description.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Prints the help description output.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p None.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ description "This extension handles X Y and Z."
            %td.code
              .highlight
                %pre
                  help_description
                  %span.o ()
                  %span.o {
                  = succeed "_description" do
                    %span.nb local
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv help_descriptions
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "help_section" do
                    %span.k                   %span.s2 &quot;Description&quot;
                  = succeed "_description" do
                    %span.k for
                  in
                  %span.s2 &quot;${help_descriptions[@]}&quot;
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot;  %s\n&quot;
                  %span.s2 &quot;${_description}&quot;
                  %span.k done
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 actions()
              %p Set the string that will be printed when the actions help section is output.
              %h3 Input Parameters
              %p First parameter is a string of the action descriptions.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Fails if no actions are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ actions "install  - Installs the extension..."
            %td.code
              .highlight
                %pre
                  actions
                  %span.o ()
                  %span.o {
                  %span.o [[
                  \-n
                  %span.s2 &quot;$*&quot;
                  %span.o ]]
                  %span.o ||
                  fail
                  %span.s2 &quot;No help actions were given.&quot;
                  warn
                  %span.s2 &quot;help actions() is depreciated, use action() instead for each action.&quot;
                  %span.nv help_actions
                  %span.o =
                  %span.s2 &quot;$*&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 action()
              %p Adds an action definition for help output.
              %h3 Input Parameters
              %p
                First parameter is the name of the extension action
                Second parameter is the description of the extension action
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p The action description will be stored for use on help output.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if an action name is not given.
                Fails if a description is not provided.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ action "install"  "Installs the extension..."
            %td.code
              .highlight
                %pre
                  action
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _name
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.nb local
                  %span.nv _description
                  %span.o =
                  %span.s2 &quot;${2:-}&quot;
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_name}&quot;
                  %span.o &amp;&amp;
                  \-n
                  %span.s2 &quot;${_description}&quot;
                  %span.o ]]
                  %span.o ||
                  fail
                  %span.s2 &quot;An action and a description must be provided:\naction {name} {description}&quot;
                  help_action_names+
                  %span.o =(
                  %span.s2 &quot;${_name}&quot;
                  %span.o )
                  help_action_descriptions+
                  %span.o =(
                  %span.s2 &quot;${_description}&quot;
                  %span.o )
                  %span.o }
          %tr
            %td.docs
              %h2 note()
              %p Adds a note definition for help Notes section.
              %h3 Input Parameters
              %p
                First parameter is a string containing any note for the notes section of
                the current extension's help output.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ note "Help for this extension can be found in #beginrescueend on irc.freenode.net"
            %td.code
              .highlight
                %pre
                  note
                  %span.o ()
                  %span.o {
                  help_notes+
                  %span.o =(
                  %span.s2 &quot;$*&quot;
                  %span.o )
                  %span.o }
          %tr
            %td.docs
              %h2 dependencies()
              %p Specify content for the dependencies section of the help command.
              %h3 Input Parameters
              %p
                First parameter is a string containing any dependencies for the dependencies
                section of the current extension's help output.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ dependencies " * pcre"
            %td.code
              .highlight
                %pre
                  dependencies
                  %span.o ()
                  %span.o {
                  %span.nv help_dependencies
                  %span.o =
                  %span.s2 &quot;$*&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 resource()
              %p Add a resource for the Resources section of the help command.
              %h3 Input Parameters
              %p
                First parameter is a string containing any resources for the resources
                section of the current extension's help output.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ resource "website: ..."
            %td.code
              .highlight
                %pre
                  resource
                  %span.o ()
                  %span.o {
                  help_resources+
                  %span.o =(
                  %span.s2 &quot;$*&quot;
                  %span.o )
                  %span.o }
          %tr
            %td.docs
              %h2 help_actions()
              %p
                Outputs the help actions in a formatted manner.
                Outputs a message if there are no actions.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                Prints a formatted listing of the actions and their descriptions to the
                calling environments STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat $HOME/test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules help
                    
                    action "help" "Displays the help output for the ${extension} extension"
                    action "install" "Installs Z redis package"
                    action "uninstall" "Uninstalls Z redis package"
                    
                    help_actions
                    
                    user$ "$HOME/test"
                    help      - Displays the help output for the redis extension
                    install   - Installs Z redis package
                    uninstall - Uninstalls Z redis package
            %td.code
              .highlight
                %pre
                  help_actions
                  %span.o ()
                  %span.o {
                  = succeed "_largest" do
                    %span.nb local
                  _index
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv help_action_names
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nv _largest
                  %span.o =
                  %span.k $(
                  array_largest help_action_names
                  %span.k )
                  %span.c # Use the array DSL to grab largest
                  %span.nv _largest
                  %span.o =
                  %span.k $((
                  %span.k ${#
                  %span.nv _largest
                  %span.k }
                  %span.o +
                  %span.m 1
                  %span.k ))
                  help_section
                  %span.s2 &quot;Actions&quot;
                  %span.k for
                  %span.o ((
                  %span.nv _index
                  = succeed "0" do
                    %span.o =
                  ; _index &lt;
                  %span.k ${#
                  %span.nv help_action_names
                  %span.p [@]
                  %span.k }
                  ; _index++
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot;  %-$((_largest + 2))s - %s\n&quot;
                  %span.se \
                  %span.s2 &quot;${help_action_names[${_index}]}&quot;
                  %span.s2 &quot;${help_action_descriptions[${_index}]}&quot;
                  %span.k done
                  %span.k else
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;# No help has been defined for ${extension} actions .&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 help_notes()
              %p
                Outputs the help notes in a formatted manner.
                Outputs a message if there are no notes.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Prints a formatted listing of the notes to the calling environments STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat $HOME/test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules help
                    
                    note "Don't forget the milk! "
                    note "... and cookies... mmm...."
                    
                    help_notes
                    
                    user$ "$HOME/test"
                    * Don't forget the milk!
                    * ... and cookies... mmm....
            %td.code
              .highlight
                %pre
                  help_notes
                  %span.o ()
                  %span.o {
                  = succeed "_index" do
                    %span.nb local
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv help_notes
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "help_section" do
                    %span.k                   %span.s2 &quot;Notes&quot;
                  %span.k for
                  %span.o ((
                  %span.nv _index
                  = succeed "0" do
                    %span.o =
                  ; _index &lt;
                  %span.k ${#
                  %span.nv help_notes
                  %span.p [@]
                  %span.k }
                  ; _index++
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot;  * %s\n&quot;
                  %span.s2 &quot;${help_notes[${_index}]}&quot;
                  %span.k done
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 help_dependencies()
              %p Outputs the help dependencies in a formatted manner.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                Prints a formatted listing of the current extensions defined dependencies to
                the calling environments STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
            %td.code
              .highlight
                %pre
                  help_dependencies
                  %span.o ()
                  %span.o {
                  = succeed "_index" do
                    %span.nb local
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv help_dependencies
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "help_section" do
                    %span.k                   %span.s2 &quot;Dependencies&quot;
                  %span.k for
                  %span.o ((
                  %span.nv _index
                  = succeed "0" do
                    %span.o =
                  ; _index &lt;
                  %span.k ${#
                  %span.nv help_dependencies
                  %span.p [@]
                  %span.k }
                  ; _index++
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot; * %s\n&quot;
                  %span.s2 &quot;${help_dependencies[${_index}]}&quot;
                  %span.k done
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 help_resources()
              %p
                Outputs the help notes in a formatted manner.
                Outputs a message if there are no notes.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                Prints a formatted listing of the defined resources to the calling
                environments STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
            %td.code
              .highlight
                %pre
                  help_resources
                  %span.o ()
                  %span.o {
                  = succeed "_index" do
                    %span.nb local
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv help_resources
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "help_section" do
                    %span.k                   %span.s2 &quot;Resources&quot;
                  %span.k for
                  %span.o ((
                  %span.nv _index
                  = succeed "0" do
                    %span.o =
                  ; _index &lt;
                  %span.k ${#
                  %span.nv help_resources
                  %span.p [@]
                  %span.k }
                  ; _index++
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot; * %s\n&quot;
                  %span.s2 &quot;${help_resources[${_index}]}&quot;
                  %span.k done
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 help_section()
              %p Displays a help section header.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Prints the given string as a help section header.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ help_section Usage
            %td.code
              .highlight
                %pre
                  help_section
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;\n$*\n&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 help_usage()
              %p Display the CLI signature.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Prints the CLI command signature.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ help_usage
                    bdsm core {action} [arguments...]
            %td.code
              .highlight
                %pre
                  help_usage
                  %span.o ()
                  %span.o {
                  help_section
                  %span.s2 &quot;Usage&quot;
                  log
                  %span.s2 &quot;  bdsm ${extension} {action} [arguments...]&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 usage()
              %p Display the usage help output of the command. This displays all help sections.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Prints all help sections to the STDOUT of the calling environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ usage
            %td.code
              .highlight
                %pre
                  usage
                  %span.o ()
                  %span.o {
                  bdsm_version
                  
                  log
                  %span.s2 &quot;\nbdsm ${bdsm_version} https://bdsm.beginrescueend.com/ by Wayne E. Seguin (wayneeseguin@gmail.com)&quot;
                  %span.nv sections
                  = succeed "usage" do
                    %span.o =(
                  description actions notes dependencies resources
                  %span.o )
                  = succeed "section" do
                    %span.k for
                  in
                  %span.s2 &quot;${sections[@]}&quot;
                  %span.k do
                  %span.s2 &quot;help_${section}&quot;
                  %span.k done
                  %span.k case
                  %span.s2 &quot;${extension}&quot;
                  in
                  ext|extension|extend
                  %span.o )
                  help_section
                  %span.s2 &quot;Installed Extensions&quot;
                  %span.nb printf
                  %span.s2 &quot;  &quot;
                  extensions_installed
                  %span.nb echo
                  = succeed "help_section" do
                    %span.nb                   %span.s2 &quot;Available Extensions&quot;
                  %span.nb printf
                  %span.s2 &quot;  &quot;
                  extensions_available
                  %span.nb echo
                  ;;
                  %span.k esac
                  %span.k                   %span.nb echo
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2
                init
                %em> scripts
                path()
              %p Returns the system init scripts path (eg. /etc/init.d /etc/rc.d)
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p The system init scripts path is printed to the calling environments STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Fails the OS is not of a (yet) recognized type.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user@archlinux$ init_scripts_path
                    /etc/rc.d
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  init_scripts_path
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o ((
                  %span.nv UID
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  %span.k case
                  %span.s2 &quot;$MACHTYPE&quot;
                  in
                  *darwin*
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;/etc/init.d&quot;
                  %span.c # Service module will create and use this.
                  ;;
                  
                  *linux-gnu*|*
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;/etc/init.d&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb printf
                  %span.s2 &quot;/etc/init.d&quot;
                  %span.k elif
                  %span.o [[
                  \-d
                  %span.s2 &quot;/etc/rc.d&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb printf
                  %span.s2 &quot;/etc/rc.d&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Unknown init scripts directory (/etc/init.d or /etc/rc.d not found).&quot;
                  %span.k fi
                  ;;
                  %span.k esac
                  %span.k else
                  %span.k                   %span.nb printf
                  %span.s2 &quot;$HOME/.init.d&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 confd_path()
              %p Return the system conf.d path.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Prints the conf.d path for the current system and user.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    root# confd_path
                    /etc/conf.d
            %td.code
              .highlight
                %pre
                  confd_path
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o ((
                  %span.nv UID
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nb printf
                  %span.s2 &quot;/etc/conf.d&quot;
                  %span.k else
                  %span.k                   %span.nb printf
                  %span.s2 &quot;$HOME/.conf.d&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                os
                %em> is
                linux()
              %p Tests if the operating system the process is running on is Linux.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the operating system is linux
                1 if the operating system is not linux
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    root@archlinux# os_is_linux
                    root@archlinux# echo $?
                    0
            %td.code
              .highlight
                %pre
                  os_is_linux
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;$MACHTYPE&quot;
                  %span.o =
                  *linux*
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                os
                %em> is
                darwin()
              %p Tests if the operating system the process is running on is darwin.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the operating system is darwin
                1 if the operating system is not darwin
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user@OSX# os_is_darwin
                    user@OSX# echo $?
                    0
            %td.code
              .highlight
                %pre
                  os_is_darwin
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;$MACHTYPE&quot;
                  %span.o =
                  *darwin*
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                os
                %em> is
                bsd()
              %p Tests if the operating system the process is running on is bsd.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the operating system is bsd
                1 if the operating system is not bsd
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    root@bsd# os_is_bsd
                    root@bsd# echo $?
                    0
            %td.code
              .highlight
                %pre
                  os_is_bsd
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;$MACHTYPE&quot;
                  %span.o =
                  *bsd*
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                os
                %em> is
                solaris()
              %p Tests if the operating system the process is running on is solaris.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the operating system is linux
                1 if the operating system is not linux
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    root@linux# os_is_linux
                    root@linux# echo $?
                    0
            %td.code
              .highlight
                %pre
                  os_is_solaris
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;$MACHTYPE&quot;
                  %span.o =
                  *solaris*
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                os
                %em> is
                aix()
              %p Tests if the operating system the process is running on is aix.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the operating system is aix
                1 if the operating system is not aix
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    root@aix# os_is_aix
                    root@aix# echo $?
                    0
            %td.code
              .highlight
                %pre
                  os_is_aix
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;$MACHTYPE&quot;
                  %span.o =
                  *aix*
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 os_type()
              %p Prints out the operating system category / type.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Prints the OS category/type to the calling environments STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    root@archlinux# os_type
                    linux
                    
                    user@osx# os_type
                    darwin
            %td.code
              .highlight
                %pre
                  os_type
                  %span.o ()
                  %span.o {
                  %span.k case
                  %span.s2 &quot;$MACHTYPE&quot;
                  in
                  = succeed "*linux*" do
                    %span.o (
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;linux&quot;
                  ;;
                  = succeed "*darwin*" do
                    %span.o (
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;darwin&quot;
                  ;;
                  = succeed "*bsd*" do
                    %span.o (
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;bsd&quot;
                  ;;
                  = succeed "*solaris*" do
                    %span.o (
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;solaris&quot;
                  ;;
                  = succeed "*aix*" do
                    %span.o (
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;aix&quot;
                  ;;
                  = succeed "*" do
                    %span.o (
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;$MACHTYPE&quot;
                  ;;
                  %span.k esac
                  %span.o }
          %tr
            %td.docs
              %h2
                os
                %em> arch
                type()
              %p Prints out the OS Arch type.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                Prints out the architecture type string of the system that is running the
                current process.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ os_arch_type
                    x86_64
            %td.code
              .highlight
                %pre
                  os_arch_type
                  %span.o ()
                  %span.o {
                  %span.k case
                  %span.s2 &quot;${MACHTYPE//-*}&quot;
                  in
                  = succeed "i386|i686|i86pc" do
                    %span.o (
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;i386&quot;
                  ;;
                  = succeed "*x86_64*" do
                    %span.o (
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;x86_64&quot;
                  ;;
                  = succeed "*ppc*" do
                    %span.o (
                  %span.o )
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;ppc&quot;
                  ;;
                  %span.k esac
                  %span.o }
          %tr
            %td.docs
              %h2 os_arch()
              %p Prints out the full OS machine type string.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Print the OS machine type string to STDOUT of the calling environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user@OSX# os_arch
                    i386-apple-darwin10.7.0
            %td.code
              .highlight
                %pre
                  os_arch
                  %span.o ()
                  %span.o {
                  %span.nb printf
                  %span.s1 '%s'
                  %span.s2 &quot;${MACHTYPE//-*}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                os
                %em> arch
                capable()
              %p Tests if the operating system the process is running on is Linux.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the operating system is linux
                1 if the operating system is not linux
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user@OSX$ os_arch_capable
                    x86_64
            %td.code
              .highlight
                %pre
                  os_arch_capable
                  %span.o ()
                  %span.o {
                  = succeed "os_is_darwin" do
                    %span.k if
                  %span.k then
                  %span.k                   = succeed "_string" do
                    %span.nb local
                  %span.nb read
                  \-r _string &lt; &lt;
                  %span.o> (
                  sysctl hw.cpu64bit_capable
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${
                  %span.nv _string
                  %span.p //*
                  %span.k }
                  %span.o ==
                  1
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;x86_64&quot;
                  %span.k else
                  = succeed "os_arch_type" do
                    %span.k                   %span.c # Either i386 or ppc
                  %span.k fi
                  %span.k else
                  = succeed "os_arch_type" do
                    %span.k                   %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                os
                %em> cpu
                count()
              %p Print the number of cpu cores on the current system to STDOUT
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p An integer representing the number of CPU cores or 1 if unknown.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ os_cpu_count
                    24
            %td.code
              .highlight
                %pre
                  os_cpu_count
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _count
                  = succeed "1" do
                    %span.o =
                  %span.c # Defaulting to 1.
                  = succeed "os_is_darwin" do
                    %span.k if
                  %span.k then
                  %span.k                   %span.nb read
                  \-r _count &lt; &lt;
                  %span.o> (
                  sysctl hw.ncpu
                  %span.o )
                  %span.nv _count
                  %span.o =
                  %span.s2 &quot;${_count//* }&quot;
                  = succeed "os_is_linux" do
                    %span.k elif
                  %span.k then
                  %span.k                   %span.nv _count
                  %span.o =
                  = succeed "awk" do
                    %span.k $(
                  %span.s1 '/^processor/{count++} END{print count}'
                  \/proc/cpuinfo 2&gt;&amp;1
                  %span.k )
                  %span.k fi
                  %span.k                   %span.nb printf
                  %span.s1 '%d'
                  %span.k ${
                  %span.nv _count
                  %span.k }
                  %span.o }
          %tr
            %td.docs
              %h2 os_version()
              %p Prints the OS version to STDOUT and sets the 'os_version' variable
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p The OS (Kernel) Version is printed to STDOUT.
              %h3 Environmental effects
              %p
                After running this function the os version is stored in the 'os_version'
                variable.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user@archlinux$ os_version
                    2.6.38
                    
                    user@osx$ os_version
                    10.7.0
            %td.code
              .highlight
                %pre
                  os_version
                  %span.o ()
                  %span.o {
                  %span.nb read
                  \-r os_version &lt; &lt;
                  %span.o> (
                  uname -r
                  %span.o )
                  %span.nv os_version
                  %span.o =
                  %span.k ${
                  %span.nv os_version
                  %span.p //-*
                  %span.k }
                  %span.nb printf
                  %span.s1 '%s'
                  %span.s2 &quot;${os_version}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                os
                %em> version
                major()
              %p
                Prints the OS major version to STDOUT and sets the 'os
                %em> version
                major' variable
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p The OS Major Version is printed to STDOUT.
              %h3 Environmental effects
              %p
                After running this function the os major version is stored in the
                'os
                %em> version
                major' variable.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user@archlinux$ os_version
                    2.6.38
                    
                    user@osx$ os_version_major
                    2
            %td.code
              .highlight
                %pre
                  os_version_major
                  %span.o ()
                  %span.o {
                  %span.nv os_version_major
                  %span.o =
                  = succeed "os_version" do
                    %span.k $(
                  %span.k )
                  %span.nv os_version_major
                  %span.o =
                  %span.s2 &quot;${os_version_major//\.*}&quot;
                  %span.nb printf
                  %span.s2 &quot;${os_version_major}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                os
                %em> version
                minor()
              %p
                Prints the OS minor version to STDOUT and sets the 'os
                %em> version
                minor' variable
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p The OS minor Version is printed to STDOUT.
              %h3 Environmental effects
              %p
                After running this function the os minor version is stored in the
                'os
                %em> version
                minor' variable.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user@archlinux$ os_version
                    2.6.38
                    
                    user@osx$ os_version_minor
                    6
            %td.code
              .highlight
                %pre
                  os_version_minor
                  %span.o ()
                  %span.o {
                  %span.nv os_version_minor
                  %span.o =
                  = succeed "os_version" do
                    %span.k $(
                  %span.k )
                  %span.nv os_version_minor
                  %span.o =
                  %span.s2 &quot;${os_version_minor#*\.}&quot;
                  %span.nv os_version_minor
                  %span.o =
                  %span.s2 &quot;${os_version_minor%\.*}&quot;
                  %span.nb printf
                  %span.s2 &quot;${os_version_minor}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                os
                %em> version
                patch()
              %p
                Prints the OS patch version to STDOUT and sets the 'os
                %em> version
                patch' variable
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p The OS patch Version is printed to STDOUT.
              %h3 Environmental effects
              %p
                After running this function the os patch version is stored in the
                'os
                %em> version
                patch' variable.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user@archlinux$ os_version
                    2.6.38
                    
                    user@osx$ os_version_patch
                    38
            %td.code
              .highlight
                %pre
                  os_version_patch
                  %span.o ()
                  %span.o {
                  %span.nv os_version_patch
                  %span.o =
                  = succeed "os_version" do
                    %span.k $(
                  %span.k )
                  %span.nv os_version_patch
                  %span.o =
                  %span.s2 &quot;${os_version_patch//*\.}&quot;
                  %span.nb printf
                  %span.s2 &quot;${os_version_patch}&quot;
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h1 Array Module
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
          %tr
            %td.docs
              %h2
                array
                %em> is
                nonempty()
              %p
                Checks to see if an array with the name given as the first parameter
                is nonempty.
              %h3 Input Parameters
              %p The first parameter is the name of the array variable.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p
                0 if the array is non-empty.
                1 if the array is empty.
              %h3 Failure Scenarios
              %p Fails if the array name, the first parameter, is not given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ the_array=(1 2 3 4 5)
                    user$ array_is_nonempty the_array
                    user$ echo $?
                    0
                    
                    user$ the_array=()
                    user$ array_is_nonempty the_array
                    user$ echo $?
                    1
            %td.code
              .highlight
                %pre
                  array_is_nonempty
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb eval
                  %span.s2 &quot;(( \${#${_array_name}[@]} &gt; 0 ))&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot push onto array as an array name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                array
                %em> is
                empty()
              %p Checks to see if an array with the name given as the first parameter is empty.
              %h3 Input Parameters
              %p The first parameter is the name of the array variable.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p
                0 if the array is empty.
                1 if the array is non-empty.
              %h3 Failure Scenarios
              %p Fails if the array name, the first parameter, is not given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ the_array=()
                    user$ array_is_empty the_array
                    user$ echo $?
                    0
                    
                    user$ the_array=(1 2 3 4 5)
                    user$ array_is_empty the_array
                    user$ echo $?
                    1
            %td.code
              .highlight
                %pre
                  array_is_empty
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb eval
                  %span.s2 &quot;(( \${#${_array_name}[@]} == 0 ))&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot push onto array as an array name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 array_length()
              %p Return the length of the given array.
              %h3 Input Parameters
              %p First parameter is the name of the array variable.
              %h3 Stream Outputs
              %p
                Prints the length of the named array to the STDOUT stream of the calling
                environment.
              %h3 Return Codes
              %p returns 0
              %h3 Failure Scenarios
              %p Fails if the array name, first parameter, is not given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ the_array=(1 2 3 4 5)
                    user$ array_length the_array
                    5
            %td.code
              .highlight
                %pre
                  array_length
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb eval
                  %span.s2 &quot;printf \&quot;%s\\n\&quot; \&quot;\${#${_array_name}[@]}\&quot;&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot push onto array as an array name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                array
                %em> last
                element()
              %p Print the last element of the given array.
              %h3 Input Parameters
              %p First parameter is the name of the array variable.
              %h3 Stream Outputs
              %p
                Prints the last element of the named array to the STDOUT stream of the
                calling environment.
              %h3 Failure Scenarios
              %p Fails if the array name, first parameter, is not given.
              %h3 Return Codes
              %p 0 denoting success
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    $ the_array=(one two three four five)
                    $ array_last_element the_array
                    five
            %td.code
              .highlight
                %pre
                  array_last_element
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  _length
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb eval
                  %span.s2 &quot;_length=\${#${_array_name}[@]}&quot;
                  %span.nb eval
                  %span.s2 &quot;printf \&quot;%s\\n\&quot; \&quot;\${${_array_name}[${_length}]}\&quot;&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot push onto array as an array name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                array
                %em> first
                element()
              %p Print the first element of the given array.
              %h3 Input Parameters
              %p First parameter is the name of the array variable.
              %h3 Stream Outputs
              %p
                Prints the first element of the named array to the STDOUT stream of the
                calling environment.
              %h3 Return Codes
              %p 0 denoting success
              %h3 Failure Scenarios
              %p Fails if the array name, the first parameter, is not given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    $ the_array=(one two three four five)
                    $ array_first_element the_array
                    one
            %td.code
              .highlight
                %pre
                  array_first_element
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  _length
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb eval
                  %span.s2 &quot;printf \&quot;%s\\n\&quot; \&quot;\${${_array_name}[0]}\&quot;&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot push onto array as an array name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 array_push()
              %p Appends one or more elements to the array with the given name.
              %h3 Input Parameters
              %p
                The first parameter is the name of the array variable.
                Remaining parameters are the elements to be appended to the array.
              %h3 Stream Outputs
              %p None.
              %h3 Returns
              %p 0 denoting success
              %h3 Failure Scenarios
              %p
                Fails if the array name, the first parameter, is not given.
                Fails if no elements were given (second paramater and beyond).
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    $ the_array=(1 2 3 4 5)
                    $ array_push the_array 6
                    $ array_join the_array # print the contents of the array, space separated
                    1 2 3 4 5 6
            %td.code
              .highlight
                %pre
                  array_push
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  %span.nb                   = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb eval
                  %span.s2 &quot;(( \${#${_array_name}[@]} &gt; 0 ))&quot;
                  = succeed "_element" do
                    %span.nb local
                  %span.nv _elements
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _elements
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot push elements onto array as no elements were given.&quot;
                  %span.k fi
                  = succeed "_element" do
                    %span.k for
                  in
                  %span.s2 &quot;${_elements[@]}&quot;
                  %span.k do
                  %span.k                   %span.nb eval
                  %span.s2 &quot;${_array_name}+=(\${_element})&quot;
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot push elements onto array as an array name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 array_append()
              %p Return the length of the given array.
              %h3 Input Parameters
              %p
                The first parameter is the name of the array variable.
                Remaining parameters are the elements to append to the end of the array.
              %h3 Stream Outputs
              %p None.
              %h3 Returns
              %p 0 denoting success
              %h3 Failure Scenarios
              %p
                Fails if the array name, the first parameter, is not given.
                Fails if no elements were given to append to the array.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ the_array=(1)
                    user$ array_append the_array 2 3 4 5
                    user$ array_join the_array # print the contents of the array,
                    space separated.
                    1 2 3 4 5
            %td.code
              .highlight
                %pre
                  array_append
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb shift
                  = succeed "_element" do
                    %span.nb local
                  %span.nv _elements
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _elements
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot push elements onto array as no elements were given.&quot;
                  %span.k fi
                  = succeed "_element" do
                    %span.k for
                  in
                  %span.s2 &quot;${_elements[@]}&quot;
                  %span.k do
                  %span.k                   %span.nb eval
                  %span.s2 &quot;${_array_name}+=(\${_element})}&quot;
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot push onto array as an array name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 array_shift()
              %p Removes the first element of the array and prints it.
              %h3 Input Parameters
              %p The first parameter is the name of the array variable.
              %h3 Stream Outputs
              %p
                Prints the first element of the named array to the STDOUT stream of the
                calling environment.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat $HOME/test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework.
                    modules array
                    
                    my_array=(1 2 3 4)
                    echo ${my_array[@]}
                    array_shift my_array
                    echo ${my_array[@]}
                    
                    user$ $HOME/test
                    1 2 3 4
                    1
                    2 3 4
            %td.code
              .highlight
                %pre
                  array_shift
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nv new_array
                  %span.o =()
                  index first_element
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb eval
                  %span.s2 &quot;
                  %span.s2 first_element=\${${_array_name}[0]}
                  %span.s2 for (( index=1; index &lt; \${#${_array_name}[@]}; index++ ))
                  %span.s2 do
                  %span.s2 new_array+=(\${${_array_name}[\${index}]})
                  %span.s2 done
                  %span.s2 ${_array_name}=(\&quot;\${new_array[@]}\&quot;)
                  %span.s2 &quot;
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;${first_element}&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot shift from array as an array name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 array_unshift()
              %p
                Prepends one or more elements to the array whose name is given, in the order
                given.
              %h3 Input Parameters Parameters
              %p
                The first parameter is the name of the array variable.
                Remaining parameters are the elements to prepend to the array.
              %h3 Stream Outputs
              %p
                None.
                Yields a failure message if no array name was given.
                Yields a failure message if no elements were given to unshift.
              %h3 Return Codes
              %p 0 denoting success
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    $ the_array=(2 3 4 5)
                    $ array_unshift 1
                    user$ array_join the_array # print contents of the array, space separated.
                    1 2 3 4 5
                    
                    $ the_array=(4 5)
                    $ array_unshift 3 2 1
                    user$ array_join the_array # print contents of the array, space separated.
                    1 2 3 4 5
            %td.code
              .highlight
                %pre
                  array_unshift
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb shift
                  = succeed "_element" do
                    %span.nb local
                  %span.nv _elements
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _elements
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot push elements onto array as no elements were given.&quot;
                  %span.k fi
                  = succeed "_element" do
                    %span.k for
                  in
                  %span.s2 &quot;${_elements[@]}&quot;
                  %span.k do
                  %span.k                   %span.nb eval
                  %span.s2 &quot;${_array_name}=(\&quot;${_element}\&quot; \&quot;\${${_array_name}[@]}\&quot;)&quot;
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot push onto array as an array name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 array_join()
              %p
                Joins the named array into a string separated by either a space or
                a given string.
              %h3 Input Parameters
              %p
                The first parameter is the name of the array variable.
                The second parameter is the separator between elements in the string, this is
                optional and defaults to a space.
              %h3 Stream Outputs
              %p
                Prints the elements of the named array, separated by either the 2nd parameter
                if given or else a space character, to the STDOUT stream of the calling
                environment.
              %h3 Return Codes
              %p 0 denoting success
              %h3 Failure Scenarios
              %p Fails if the array name, the first parameter, is not given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    $ the_array=(1 2 3 4 5)
                    $ array_join the_array
                    1 2 3 4 5
                    
                    $ array_join the_array '.'
                    1.2.3.4.5
            %td.code
              .highlight
                %pre
                  array_join
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb local
                  %span.nv _separator
                  %span.o =
                  %span.s2 &quot;${1:-' '}&quot;
                  %span.nb eval
                  %span.s2 &quot;
                  %span.s2 for (( index=0 ; index &lt; \${#${_array_name}[@]} ; index++ )) ;
                  %span.s2 do (( index &gt;  0 )) &amp;&amp; printf \&quot;%s\&quot;${_separator}\&quot;\&quot; ;
                  %span.s2 printf \&quot;%s\&quot; \&quot;\${${_array_name}[\${index}]}\&quot; ;
                  %span.s2 done&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot join array as an array name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 array_largest()
              %p Outputs the first string in the array with the largest length.
              %h3 Input Parameters
              %p The first element is an array variable name.
              %h3 Stream Outputs
              %p
                Prints the largest elements of the named array to the STDOUT
                stream of the calling environment.
              %h3 Return Codes
              %p 0 denoting success
              %h3 Failure Scenarios
              %p Fails if the array name, the first parameter, is not given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    $ the_array=(billie bob joe)
                    $ array_largest the_array
                    billie
            %td.code
              .highlight
                %pre
                  array_largest
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _index
                  %span.nv _largest
                  %span.o =
                  %span.s2 &quot;&quot;
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb eval
                  %span.s2 &quot;
                  %span.s2 for (( _index=0 ; _index &lt; \${#${_array_name}[@]} ; _index++ ))
                  %span.s2 do
                  %span.s2 if (( \${#${_array_name}[\${_index}]} &gt; \${#_largest} ))
                  %span.s2 then
                  %span.s2 _largest=\${${_array_name}[\${_index}]}
                  %span.s2 fi
                  %span.s2 done
                  %span.s2 &quot;
                  %span.nb printf
                  %span.s2 &quot;%s&quot;
                  %span.s2 &quot;${_largest}&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot find largest element as an array variable name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                array
                %em> sort
                desc()
              %p Sorts the named array contents in descending order.
              %h3 Input Parameters
              %p An array variable name.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 denoting success
              %h3 Failure Scenarios
              %p Fails if the array name, the first parameter, is not given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat $HOME/test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # BDSM framework
                    modules array
                    
                    arr=(c a d e f b h j i )
                    array_sort_desc arr
                    array_join arr
                    echo
                    
                    user$ $HOME/test
                    j i h f e d c b a
            %td.code
              .highlight
                %pre
                  array_sort_desc
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _index
                  %span.nv _largest
                  %span.o =
                  %span.s2 &quot;&quot;
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb eval
                  %span.s2 &quot;${_array_name}=(\$(
                  %span.s2 echo \&quot;\${${_array_name}[@]}\&quot; | tr ' ' \&quot;\n\&quot; | sort -r
                  %span.s2 ))&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot sort an array in decending order as an array&quot;
                  %span.se \
                  %span.s2 &quot;variable name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                array
                %em> sort
                asc()
              %p Sorts the named array contents in ascending order.
              %h3 Input Parameters
              %p An array variable name.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 denoting success
              %h3 Failure Scenarios
              %p Fails if the array name, the first parameter, is not given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat $HOME/test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # BDSM framework
                    modules array
                    
                    arr=(c a d e f b h j i )
                    array_sort_asc arr
                    array_join arr
                    echo
                    
                    user$ $HOME/test
                    a b c d e f h i j
            %td.code
              .highlight
                %pre
                  array_sort_asc
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _index
                  %span.nv _largest
                  %span.o =
                  %span.s2 &quot;&quot;
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb eval
                  %span.s2 &quot;${_array_name}=(\$(
                  %span.s2 echo \&quot;\${${_array_name}[@]}\&quot; | tr ' ' \&quot;\n\&quot; | sort
                  %span.s2 ))&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot sort an array in ascending order as an array &quot;
                  %span.se \
                  %span.s2 &quot;variable name was not given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 array_unique()
              %p Sorts the named array contents in ascending order.
              %h3 Input Parameters
              %p An array variable name.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p 0 denoting success
              %h3 Failure Scenarios
              %p Fails if the array name, the first parameter, is not given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat $HOME/test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # BDSM framework
                    modules array
                    
                    arr=(a a a b b c c c c d d d d d d)
                    array_unique arr
                    array_join arr
                    echo
                    
                    user$ $HOME/test
                    a b c d
            %td.code
              .highlight
                %pre
                  array_unique
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _array_name
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _index
                  %span.nv _largest
                  %span.o =
                  %span.s2 &quot;&quot;
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  _array_name
                  %span.k then
                  %span.k                   %span.nb eval
                  %span.s2 &quot;${_array_name}=(\$(
                  %span.s2 echo \&quot; \${${_array_name}[@]} \&quot; | awk -v RS=' ' -v ORS=' ' '!(\$0 in a){a[\$0];print}'
                  %span.s2 ))&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot sort an array in ascending order as an array &quot;
                  %span.se \
                  %span.s2 &quot;variable name was not given.&quot;
                  %span.k fi
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 modules()
              %p Loads named BDSM modules into the calling environment.
              %h3 Input Parameters
              %p Positional Parameter listing and descriptions.
              %h3 Stream Outputs
              %p None, unless loading the module causes output to a stream.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no module names were given as parameters.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ modules array system
                    user$ modules_loaded
                    logging trace filesystem array system
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  modules
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o ((
                  trace_flag &lt; 2
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nb set
                  +o xtrace
                  %span.k fi
                  %span.k                   = succeed "_module" do
                    %span.nb local
                  _bdsm _extension _path _file
                  %span.nv _modules
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _modules
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;No modules specified to load.&quot;
                  %span.k fi
                  = succeed "_module" do
                    %span.k for
                  in
                  %span.s2 &quot;${_modules[@]}&quot;
                  %span.k do
                  = succeed "module_is_loaded" do
                    %span.k if
                  %span.s2 &quot;${_module}&quot;
                  %span.k then
                  %span.k continue
                  %span.c # The module has already been loaded, continue to the next one.
                  %span.k else
                  %span.k                   %span.nv _bdsm
                  %span.o =
                  %span.s2 &quot;${modules_path}/bash/${_module}&quot;
                  %span.nv _extension
                  %span.o =
                  %span.s2 &quot;${extension_modules_path}/bash/${_module}&quot;
                  = succeed "_path" do
                    %span.k for
                  in
                  %span.s2 &quot;${_bdsm}&quot;
                  %span.s2 &quot;${_extension}&quot;
                  %span.k do
                  = succeed "_file" do
                    %span.k for
                  in dsl initialize
                  %span.k do
                  %span.k if
                  %span.o [[
                  \-s
                  %span.s2 &quot;${_path}/${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb source
                  %span.s2 &quot;${_path}/${_file}&quot;
                  %span.k fi
                  %span.k done
                  %span.k done
                  = succeed "modules+" do
                    %span.k                   %span.o =(
                  %span.s2 &quot;${_module}&quot;
                  %span.o )
                  %span.k fi
                  %span.k done
                  %span.k if
                  %span.o ((
                  trace_flag &gt; 0
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nb set
                  \-o xtrace
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 module_load()
              %p Function Description
              %h3 Input Parameters
              %p Positional Parameter listing and descriptions.
              %h3 Stream Outputs
              %p None, unless loading the module causes output to a stream.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no extension module files names have been given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ ls ${extension_modules_path}/bash/
                    cli dsl initialize zebra
                    
                    user$ cat ${extension_modules_path}/bash/zebra
                    #!/usr/bin/env bash
                    echo "Zebra!!! "
                    
                    user$ module_load zebra # This will load zebra into the current context
                    Zebra!!!
            %td.code
              .highlight
                %pre
                  module_load
                  %span.o ()
                  %span.o {
                  = succeed "_file" do
                    %span.nb local
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot load a module as no module was given.&quot;
                  %span.k fi
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  = succeed "source_files" do
                    %span.k                   %span.s2 &quot;${extension_modules_path:-&quot;
                  %span.nv $modules_path
                  %span.s2 &quot;}/bash/${_file}&quot;
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2
                module
                %em> is
                loaded()
              %p Checks to see whether or not the named module has been loaded or not.
              %h3 Input Parameters
              %p First parameter is a module name.
              %h3 Stream Outputs
              %p None.
              %h3 Return Codes
              %p
                0 if the module has already been loaded
                1 if the module has not already been loaded
              %h3 Failure Scenarios
              %p Fails if no module name was given as the first parameter.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ module_is_loaded package
                    user$ echo $?
                    1
                    user$ modules package
                    user$ module_is_loaded package
                    0
            %td.code
              .highlight
                %pre
                  module_is_loaded
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _name
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_name}&quot;
                  %span.o ]]
                  %span.o ||
                  fail
                  %span.s2 &quot;Cannot determine if a module is loaded as no module was given.&quot;
                  %span.k case
                  %span.s2 &quot; ${modules[@]} &quot;
                  in
                  = succeed "*" do
                    %span.o (
                  = succeed ":space:" do
                    %span.o [[
                  %span.o ]]
                  %span.k ${
                  %span.nv _name
                  %span.k }
                  = succeed ":space:" do
                    %span.o [[
                  = succeed "*" do
                    %span.o ]]
                  %span.o )
                  = succeed "0" do
                    %span.k return
                  ;;
                  = succeed "*" do
                    %span.o (
                  %span.o )
                  = succeed "1" do
                    %span.k return
                  ;;
                  %span.k esac
                  %span.o }
          %tr
            %td.docs
              %h2 modules_loaded()
              %p Outputs a list of all modules that have been loaded.
              %h3 Input Parameters
              %p Positional Parameter listing and descriptions.
              %h3 Stream Outputs
              %p
                Prints a space separated list of all loaded modules to the STDOUT stream of
                the calling environment.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ modules_loaded
                    logging trace filesystem
            %td.code
              .highlight
                %pre
                  modules_loaded
                  %span.o ()
                  %span.o {
                  %span.nb printf
                  %span.s2 &quot;${modules[@]}\n&quot;
                  %span.o }
          %tr
            %td.docs
              %p Print out a list of all installed modules.
            %td.code
              .highlight
                %pre
                  modules_installed
                  %span.o ()
                  %span.o {
                  = succeed "_module" do
                    %span.nb local
                  %span.nb local
                  %span.nv _module_type
                  %span.o =
                  = succeed "bash" do
                    %span.s2 &quot;${1:-&quot;
                  %span.s2 &quot;}&quot;
                  %span.nb local
                  %span.nv _modules
                  %span.o =(
                  = succeed "find" do
                    %span.k $(
                  %span.s2 &quot;${modules_path}/${_module_type}&quot;
                  \-mindepth 1 -maxdepth 1 -type d | sed -e
                  %span.s1 's#.*/##g'
                  \-e
                  %span.s1 '/\..*/d'
                  %span.k )
                  %span.o )
                  = succeed "_module" do
                    %span.k for
                  in
                  %span.k ${
                  %span.nv _modules
                  %span.p [@]
                  %span.k }
                  ;
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot;%s\n&quot;
                  %span.s2 &quot;${_module}&quot;
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 module_dsl()
              %p Print out a list of all dsl for the given module.
              %h3 Input Parameters
              %p First parameter is the module name to print out the dsl for.
              %h3 Stream Outputs
              %p
                The named module's DSL function listing will is printed to the calling
                environments STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no module name was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ module_dsl defaults
                    read_default()
            %td.code
              .highlight
                %pre
                  module_dsl
                  %span.o ()
                  %span.o {
                  = succeed "_function" do
                    %span.nb local
                  _dsl
                  %span.nv _modules
                  %span.o =
                  %span.s2 &quot;${@:-}&quot;
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _modules
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot print the DSL for module(s) as no module names were given.&quot;
                  %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${modules_path}/bash/${_module}&quot;
                  %span.nv _dsl
                  %span.o =(
                  = succeed "find" do
                    %span.k $(
                  %span.s2 &quot;${_path}&quot;
                  \-mindepth 1 -maxdepth 1 -name dsl -type f -print0 | xargs -0 grep
                  %span.s1 '^[a-z_]*()$'
                  2&gt;/dev/null
                  %span.o ||
                  %span.nb true
                  %span.k )
                  %span.o )
                  = succeed "_function" do
                    %span.k for
                  in
                  %span.s2 &quot;${_dsl[@]}&quot;
                  %span.k do
                  %span.k                   %span.nv _function
                  %span.o =
                  %span.s2 &quot;${_function##*modules\/bash\/}&quot;
                  %span.nb printf
                  %span.s2 &quot;%s\n&quot;
                  %span.s2 &quot;${_function//*:}&quot;
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 modules_list()
              %p Lists dsl for all modules.
              %h3 Input Parameters
              %p First parameter is the module name to print out the dsl for.
              %h3 Stream Outputs
              %p
                DSL function listing for each module is printed to the STDOUT of the calling
                environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ modules_list
                    array
                    
                      array_is_nonempty()
                      array_length()
                      array_last_element()
                      array_first_element()
                      array_push()
                      array_append()
                      array_shift()
                      array_unshift()
                      array_join()
                    ... longish output ...
            %td.code
              .highlight
                %pre
                  modules_list
                  %span.o ()
                  %span.o {
                  = succeed "_module" do
                    %span.nb local
                  _modules _function _dsl
                  = succeed "language" do
                    %span.k for
                  in bash ruby
                  %span.k do
                  %span.k                   %span.nv _modules
                  %span.o =(
                  = succeed "modules_installed" do
                    %span.k $(
                  %span.k ${
                  %span.nv language
                  %span.k })
                  %span.o )
                  = succeed "_module" do
                    %span.k for
                  in
                  %span.s2 &quot;${_modules[@]}&quot;
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot;\n%s\n\n&quot;
                  %span.s2 &quot;${_module}&quot;
                  %span.nv _dsl
                  %span.o =(
                  = succeed "module_dsl" do
                    %span.k $(
                  %span.s2 &quot;${_module}&quot;
                  %span.k )
                  %span.o )
                  = succeed "_function" do
                    %span.k for
                  in
                  %span.s2 &quot;${_dsl[@]}&quot;
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot;%s\n&quot;
                  %span.s2 &quot;  ${_function}&quot;
                  %span.k done
                  %span.k done
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 modules_docs()
              %p Output the module DSL documentation for a given module name.
              %h3 Input Parameters
              %p First parameter is the module name to print out the dsl documentation for.
              %h3 Stream Outputs
              %p DSL documentation for every function of the named module.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no module name is given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ module_docs defaults
                    
                    # read_default
                    
                    Reads default values from an extension's config/defaults file.
                    
                    ### Input Parameters
                    
                    First parameter is the defaults file key to read (key=value).
                    Second parameter is the variable name to store the retrieved value in.
                    Remaining parameters are parsed out as token, value and prefix
                      into|as &lt;variable name&gt;
                      prefix &lt;name&gt;
                      &lt;variable&gt; # If no specifier.
                    
                    ### Stream Outputs
                    
                    None.
                    
                    ### Environmental effects
                    
                    A variable will be set to the value, if the value is nonempty. If no variable
                    name is specified the variable will be assigned the same name as the key.
                    
                    ### Return Codes
                    
                    0 for success.
                    
                    ### Failure Scenarios
                    
                    Fails if no arguments are passed in, at least need to specify a key.
                    
                    ### Usage Examples
                    
                        user$ read_default "version" prefix "package" # extension is nginx for example
                        user$ echo $package_version
                        1.0.0
            %td.code
              .highlight
                %pre
                  module_docs
                  %span.o ()
                  %span.o {
                  = succeed "_function" do
                    %span.nb local
                  _dsl _module content_flag table_flag
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${token}&quot;
                  in
                  \--content
                  %span.o )
                  %span.nv content_flag
                  = succeed "1" do
                    %span.o =
                  ;;
                  \--table
                  %span.o )
                  %span.nv table_flag
                  = succeed "1" do
                    %span.o =
                  ;;
                  *
                  %span.o )
                  %span.nv _module
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_module}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${core_development_path}/modules/bash/${_module}&quot;
                  %span.k if
                  %span.o ((
                  %span.nv content_flag
                  %span.o ==
                  1
                  %span.o ))
                  %span.k then
                  = succeed "shocco" do
                    %span.k                   %span.s2 &quot;${_path}/dsl&quot;
                  | awk
                  %span.s1 '/&lt;body&gt;/{p=1;next;} /\/body&gt;/{p=0;next;} {if (p == 1) print ; } '
                  %span.k elif
                  %span.o ((
                  %span.nv table_flag
                  %span.o ==
                  1
                  %span.o ))
                  %span.k then
                  = succeed "shocco" do
                    %span.k                   %span.s2 &quot;${_path}/dsl&quot;
                  | awk
                  %span.s1 '/&lt;table/{p=1;} {if (p == 1) print ; } /\/table&gt;/{p=0;} '
                  %span.k else
                  = succeed "shocco" do
                    %span.k                   %span.s2 &quot;${_path}/dsl&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot glean documentation for a module as no module name was given&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 modules_docgen()
              %p Lists dsl for all modules.
              %h3 Input Parameters
              %p First parameter is the module name to print out the dsl for.
              %h3 Stream Outputs
              %p
                DSL function listing for each module is printed to the STDOUT of the calling
                environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ modules_list
                    array
                    
                      array_is_nonempty()
                      array_length()
                      array_last_element()
                      array_first_element()
                      array_push()
                      array_append()
                      array_shift()
                      array_unshift()
                      array_join()
                    ... longish output ...
            %td.code
              .highlight
                %pre
                  modules_docgen
                  %span.o ()
                  %span.o {
          %tr
            %td.docs
              %p
                TODO: Replace with,
                for file in modules/bash/
                %em> /dsl ; do (name=${file%%\/dsl}; shocco $file > html/${name//
                \\/}.html)&amp; done ; wait
            %td.code
              .highlight
                %pre
                  %span.nb> local
                  _module _modules _function _dsl
                  %span.nb local
                  %span.nv _prefix
                  %span.o =
                  %span.s2 &quot;${core_development_path}/html/modules&quot;
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${site_development_path}&quot;
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${core_development_path}&quot;
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;&lt;html&gt;&lt;body&gt;&lt;h2&gt;BDSM Module Documentation&lt;/h2&gt;&lt;ul&gt;&quot;
                  %span.se \
                  \&gt;
                  %span.s2 &quot;${_prefix}/index.html&quot;
                  %span.nv _modules
                  %span.o =(
                  %span.k $(
                  find
                  %span.s2 &quot;${core_development_path}/modules/bash&quot;
                  \-mindepth 1 -maxdepth 1
                  %span.se \
                  \-type d | sed -e
                  %span.s1 's#.*/##g'
                  \-e
                  %span.s1 '/\..*/d'
                  %span.k )
                  %span.o )
                  = succeed "_module" do
                    %span.k for
                  in
                  %span.s2 &quot;${_modules[@]}&quot;
                  %span.k do
                  %span.o (
                  ensure_paths_exist
                  %span.s2 &quot;${_prefix}/${_module}&quot;
                  %span.nv _base
                  %span.o =
                  %span.s2 &quot;${_prefix}/${_module}&quot;
                  log
                  %span.s2 &quot;Generating ${_base}.html&quot;
                  module_docs
                  %span.s2 &quot;${_module}&quot;
                  \&gt;
                  %span.s2 &quot;${_base}.html&quot;
                  html2haml
                  %span.s2 &quot;${_base}.html&quot;
                  %span.se \
                  \&gt;&gt;
                  %span.s2 &quot;${site_development_path}/content/modules/bash/${name}/dsl.haml&quot;
                  log
                  %span.s2 &quot;&lt;li&gt;&lt;a href=\&quot;./${_module}.html\&quot;&gt;${_module}&lt;/a&gt;&lt;/li&gt;&quot;
                  %span.se \
                  \&gt;&gt;
                  %span.s2 &quot;${_prefix}/index.html&quot;
                  = succeed "&amp;amp;" do
                    %span.o )
                  %span.k done
                  %span.k                   %span.nb wait
                  = succeed "log" do
                    %span.nb                   %span.s2 &quot;  &lt;/ul&gt;&lt;/body&gt;&lt;/html&gt;&quot;
                  \&gt;&gt;
                  %span.s2 &quot;${_prefix}/index.html&quot;
                  log
                  %span.s2 &quot;Modules documentation content has been generated in ${_prefix}.&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Set core_development_path in ~/.bdsmrc in order to run docgen.&quot;
                  %span.k fi
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${site_development_path}&quot;
                  %span.k then
          %tr
            %td.docs
              %p Copy the generated files into the proper site content dir.
            %td.code
              .highlight
                %pre
                  %span.nv files
                  %span.o =(
                  = succeed "find" do
                    %span.k $(
                  %span.s2 &quot;${_prefix}&quot;
                  \-mindepth 1 -iname
                  %span.s1 '*.haml'
                  %span.k )
                  %span.o )
                  = succeed "file" do
                    %span.k for
                  in
                  %span.s2 &quot;${files[@]}&quot;
                  %span.k do
                  %span.o (
                  %span.nv name
                  %span.o =
                  %span.k ${
                  %span.nv file
                  %span.p ##*\/
                  %span.k }
                  %span.nv name
                  %span.o =
                  %span.k ${
                  %span.nv name
                  %span.p %.haml
                  %span.k }
                  ensure_paths_exist
                  %span.s2 &quot;${site_development_path}/content/modules/bash/${name}&quot;
                  log
                  %span.s2 &quot;Building ${name} dsl from generated docs.&quot;
                  cat &gt;
                  %span.s2 &quot;${site_development_path}/content/modules/bash/${name}/dsl.haml&quot;
                  %span.s &lt;&lt;Header
                  %span.s .breadcrumbs
                  %span.s %a{ :href =&gt; &quot;/&quot; }
                  %span.s Documentation
                  %span.s &amp;nbsp;&gt;&amp;nbsp;
                  %span.s %a{ :href =&gt; &quot;/modules/&quot; }
                  %span.s Modules
                  %span.s &amp;nbsp;&gt;&amp;nbsp;
                  %span.s %a{ :href =&gt; &quot;/modules/bash/&quot; }
                  %span.s Bash
                  %span.s &amp;nbsp;&gt;&amp;nbsp;
                  %span.s %a{ :href =&gt; &quot;/modules/bash/${name}/&quot; }
                  %span.s ${name}
                  %span.s &amp;nbsp;&gt;&amp;nbsp;
                  %span.s %a{ :href =&gt; &quot;/modules/bash/${name}/dsl/&quot; }
                  %span.s DSL API :: ${name}
                  %span.s %hr
                  %span.s %h1
                  %span.s Module ${name}
                  %span.s Header
                  cat
                  %span.nv $file
                  \&gt;&gt;
                  %span.s2 &quot;${site_development_path}/content/modules/bash/${name}/dsl.haml&quot;
                  = succeed "&amp;amp;" do
                    %span.o )
                  %span.k done
                  %span.k                   %span.nb wait
                  = succeed "log" do
                    %span.nb                   %span.s2 &quot;Module documentation has been generated from the source code path ${core_development_path} into the site development path ${site_development_path}&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Set site_development_path in ~/.bdsmrc in order to run docgen.&quot;
                  %span.k fi
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 extension_action()
              %p
                Load the environment for a given extension action and then call it.
                This is the main function for BDSM.
              %h3 Input Parameters
              %p One or more extension names.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                The current extension's initialize file will be resourced into the current
                environment.
              %h3 Return Codes
              %p
                0 for success
                1 for failure
              %h3 Failure Scenarios
              %p
                Fails if no extension was given.
                Fails if no action was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    $ cat $HOME/test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules extensions
                    extension_action ext list
                    
                    $  $HOME/test
                    bash fossil git libevent nginx p7zip postgresql rails redis srv tig tmux zeromq zlib
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  extension_action
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv result
                  = succeed "0" do
                    %span.o =
                  = succeed "extension" do
                    %span.nb unset
                  action
                  %span.nb export
                  %span.nv extension
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${extension}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;'extension' is not set! Something has gone terribly wrong.&quot;
                  %span.k fi
                  %span.k                   %span.nb shift
                  %span.nb export
                  %span.nv action
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${action}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;'action' is not set! Something has gone terribly wrong.&quot;
                  %span.k fi
                  %span.k                   %span.nb shift
                  %span.nb                   %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv extension_args
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nv extension_args
                  %span.o =
                  %span.s2 &quot;$@&quot;
                  %span.k fi
                  %span.k                   = succeed "extension_args" do
                    %span.nb export
                  %span.nv extension_path
                  %span.o =
                  %span.s2 &quot;$extensions_path/$extension&quot;
                  %span.nv extension_config_path
                  %span.o =
                  %span.s2 &quot;$extensions_path/$extension/config&quot;
                  %span.nv extension_templates_path
                  %span.o =
                  %span.s2 &quot;$extensions_path/$extension/templates&quot;
                  %span.nv extension_modules_path
                  %span.o =
                  %span.s2 &quot;$extensions_path/$extension/modules&quot;
                  %span.nv extension_bin_path
                  %span.o =
                  %span.s2 &quot;$extensions_path/$extension/bin&quot;
                  %span.nv extension_log_path
                  %span.o =
                  %span.s2 &quot;$log_path/$extension&quot;
                  %span.nv paths
                  %span.o =
                  = succeed "env" do
                    %span.k $(
                  | awk -F
                  %span.o =
                  \-v
                  %span.nv ORS
                  %span.o =
                  %span.s1 ' '
                  %span.s1 '/_path/{print $1}'
                  %span.k )
                  %span.nv flags
                  %span.o =
                  = succeed "env" do
                    %span.k $(
                  | awk -F
                  %span.o =
                  \-v
                  %span.nv ORS
                  %span.o =
                  %span.s1 ' '
                  %span.s1 '/_flag/{print $1}'
                  %span.k )
                  enter
                  %span.s2 &quot;${extension_path}&quot;
                  %span.o ||
                  fail
                  %span.s2 &quot;Could not enter the extension directory!\n    (${extension_path})&quot;
                  bdsm_exports
                  %span.nv action_file
                  %span.o =
                  %span.s2 &quot;${extension_path}/bin/${action}&quot;
                  file_exists
                  %span.s2 &quot;${action_file}&quot;
                  %span.o ||
                  fail
                  %span.s2 &quot;Action binary/file ${action} missing for extension ${extension}\n    (${action_file})&quot;
                  %span.nv action_file_type
                  %span.o =
                  %span.s2 &quot;$(file &quot;
                  %span.nv $action_file
                  %span.s2 &quot;)&quot;
                  %span.k case
                  %span.s2 &quot;${action_file_type}&quot;
                  in
                  
                  *sh
                  %span.o> [[
                  \:space:
                  %span.o> ]]
                  script*|*POSIX
                  %span.o> [[
                  \:space:
                  %span.o> ]]
                  shell*|*Bourne-Again*
                  %span.o )
                  %span.nv action_type
                  %span.o =
                  %span.s2 &quot;bash&quot;
                  ;;
                  
                  *ASCII*
                  %span.o )
          %tr
            %td.docs
              %p Launch with helper dsl, if possible.
            %td.code
              .highlight
                %pre
                  %span.nv extension
                  %span.o =
                  %span.s2 &quot;${action_file//.}&quot;
                  %span.k case
                  %span.s2 &quot;${extension}&quot;
                  in
                  bash|sh
                  %span.o )
                  %span.nv action_type
                  %span.o =
                  %span.s2 &quot;bash&quot;
                  %span.c #rb) action_type=&quot;ruby&quot;   ;;
                  ;;
                  *
                  %span.o )
                  %span.nb read
                  \-r shebang &lt;
                  %span.s2 &quot;${action_file}&quot;
                  %span.k case
                  %span.s2 &quot;${shebang}&quot;
                  in
                  *ruby|*rbx|*jruby|*macruby
                  %span.o )
                  %span.nv binary
                  %span.o =
                  %span.s2 &quot;${shebang##*(#|!)}&quot;
                  %span.nv binary
                  %span.o =
                  %span.s2 &quot;${binary##* }&quot;
                  %span.nv action_type
                  %span.o =
                  %span.s2 &quot;ruby&quot;
                  ;;
                  *
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-x
                  %span.s2 &quot;${action_file}&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  %span.k                   %span.nv action_type
                  %span.o =
                  %span.s2 &quot;binary&quot;
                  %span.k else
                  %span.k                   %span.nv action_type
                  %span.o =
                  %span.s2 &quot;not executable&quot;
                  %span.k fi
                  ;;
                  %span.k esac
                  ;;
                  %span.k esac
                  %span.k                   %span.nv result
                  %span.o =
                  %span.nv $?
                  ;;
                  
                  cannot
                  %span.o> [[
                  \:space:
                  %span.o> ]]
                  open
                  %span.o )
                  %span.nv action_type
                  %span.o =
                  %span.s2 &quot;dne&quot;
                  ;;
                  
                  *
                  %span.o )
                  = succeed "file_is_executable" do
                    %span.k if
                  %span.s2 &quot;${action_file}&quot;
                  ;
                  %span.k then
                  %span.k                   %span.nv action_type
                  %span.o =
                  %span.s2 &quot;binary&quot;
                  %span.k else
                  %span.k                   %span.nv action_type
                  %span.o =
                  %span.s2 &quot;noexec&quot;
                  %span.k fi
                  ;;
                  %span.k esac
                  %span.o ||
                  %span.nv result
                  %span.o =
                  %span.nv $?
          %tr
            %td.docs
              %p Now based on the determined action_type we launch the extension.
            %td.code
              .highlight
                %pre
                  %span.k case
                  %span.s2 &quot;${action_type}&quot;
                  in
                  bash
                  %span.o )
                  %span.o (
                  enable_backtrace
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;${action}&quot;
                  %span.o =
                  %span.s2 &quot;help&quot;
                  %span.o ]]
                  %span.k then
                  %span.c # Load the help module also.
                  modules core
                  %span.nb help
                  %span.nb                   %span.k else
                  = succeed "modules" do
                    %span.k                   core
                  %span.k fi
                  = succeed "source_files" do
                    %span.k                   %span.se \
                  %span.s2 &quot;${extension_modules_path}/bash/dsl&quot;
                  %span.se \
                  %span.s2 &quot;${extension_modules_path}/bash/initialize&quot;
                  %span.se \
                  %span.s2 &quot;${extension_modules_path}/bash/cli&quot;
                  \.
                  %span.s2 &quot;${action_file}&quot;
                  %span.o )
                  %span.o ||
                  %span.nv result
                  %span.o =
                  %span.nv $?
                  %span.k return
                  %span.nv $result
                  ;;
                  
                  ruby
                  %span.o )
                  %span.nv requires
                  %span.o =()
                  = succeed "script" do
                    %span.k for
                  in dsl initialize
                  %span.k do
                  = succeed "requires+" do
                    %span.k                   %span.o =(
                  %span.s2 &quot;-r${modules_path}/ruby/core/${script}.rb&quot;
                  %span.o )
                  %span.k done
                  %span.s2 &quot;${binary:-ruby}&quot;
                  \-I
                  %span.s2 &quot;${modules_path}/ruby&quot;
                  \-I
                  %span.s2 &quot;${extension_modules_path}/ruby&quot;
                  %span.se \
                  %span.k ${
                  %span.nv requires
                  %span.p [@]
                  %span.k }
                  %span.s2 &quot;${action_file}&quot;
                  ;;
          %tr
            %td.docs
              %p
                python|lua|javascript)
                ADD "${modules
                %em> path}/${action
                type}/" to the lib path so the script can require "bdsm"
                "${action_file}"
                ;;
            %td.code
              .highlight
                %pre
                  dne|noexec
                  %span.o )
                  fail
                  %span.s2 &quot;Processing ${action} failed, file type is unknown, file does not exist or file is not executable.&quot;
                  ;;
                  binary|*
                  %span.o )
                  %span.s2 &quot;${action_file}&quot;
                  %span.s2 &quot;${extension_action}&quot;
                  %span.s2 &quot;${extension_args[@]}&quot;
                  ;;
                  %span.k esac
                  %span.o ||
                  %span.nv result
                  %span.o =
                  %span.nv $?
                  %span.k return
                  %span.nv $result
                  %span.o }
          %tr
            %td.docs
              %h2 extension_reload()
              %p Reloads (re-sources) the current extension's DSL and initialization files.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                The current extension's DSL and initialization files are re-sourced into the
                calling environment.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No current failure scenarios.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ extension_reload
            %td.code
              .highlight
                %pre
                  extension_reload
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${extension_modules_path}/bash&quot;
                  source_files
                  %span.s2 &quot;${_path}/dsl&quot;
                  %span.s2 &quot;${_path}/initialize&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 extension_reinitialize()
              %p Reinitializes the current extension.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                The current extension's initialize file will be resourced into the current
                environment.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ extension_reinitialize
            %td.code
              .highlight
                %pre
                  extension_reinitialize
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${extension_modules_path}/bash&quot;
                  source_files
                  %span.s2 &quot;${_path}/initialize&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 extension_version()
              %p Outputs the named extension's version
              %h3 Input Parameters
              %p First parameter must be the name of an extension.
              %h3 Stream Outputs
              %p The extension-version string for the named extension.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if the extension name is not given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ extension_reinitialize
            %td.code
              .highlight
                %pre
                  extension_version
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _extension
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  variable_is_nonempty
                  %span.o ||
                  fail
                  %span.s2 &quot;Can not retrieve extension version as no extension was given.&quot;
                  %span.nb shift
                  %span.nb true
                  %span.k ${
                  %span.nv extension_path
                  %span.p :=
                  %span.s2 &quot;${extensions_path}/${_extension}&quot;
                  %span.k }
                  = succeed "file_exists" do
                    %span.k if
                  %span.s2 &quot;${extension_path}/VERSION&quot;
                  %span.k then
                  %span.k                   %span.nb read
                  \-r extension_version &lt;
                  %span.s2 &quot;${extension_path}/VERSION&quot;
                  %span.k else
                  %span.k                   %span.nv extension_version
                  %span.o =
                  %span.s2 &quot;head&quot;
                  %span.k fi
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;${extension}-${extension_version}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 extension_licence()
              %p Emits the extension's license file, if it exists.
              %h3 Input Parameters
              %p First parameter may optionally be an extension name.
              %h3 Stream Outputs
              %p If the extension has a LICENSE file then it wil be printed to STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently exist.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    $ cat $HOME/test
                    !/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules extensions
                    extension_license postgresql
                    
                    $ $HOME/test
                    Copyright (c) 2009-2011 Wayne E. Seguin
                    
                    Licensed under the Apache License, Version 2.0 (the \"License\");
                    you may not use this file except in compliance with the License.
                    You may obtain a copy of the License at
                    
                        http://www.apache.org/licenses/LICENSE-2.0
                    
                    Unless required by applicable law or agreed to in writing, software
                    distributed under the License is distributed on an \"AS IS\" BASIS,
                    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
                    See the License for the specific language governing permissions and
                    limitations under the License.
            %td.code
              .highlight
                %pre
                  extension_license
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _extension
                  %span.o =
                  %span.s2 &quot;${1:-${extension}}&quot;
                  variable_is_nonempty _extension
                  %span.o ||
                  fail
                  %span.s2 &quot;Can not display extension license as an extension was not given.&quot;
                  cat -v
                  %span.s2 &quot;${extensions_path}/${_extension}/LICENSE&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 extensions_installed()
              %p Lists the extensions installed on the currently running process's system.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                The names of the currently installed non-core extensions are printed to the
                calling environment's STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    $ cat $HOME/test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules extensions
                    extensions_installed
                    
                    $ $HOME/test
                    bash fossil git libevent nginx p7zip postgresql rails redis tig tmux zeromq zlib
            %td.code
              .highlight
                %pre
                  extensions_installed
                  %span.o ()
                  %span.o {
                  extensions_in
                  %span.s2 &quot;${extensions_path}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 extensions_available()
              %p
                Lists the extensions available to install on the currently running process's
                system.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                The names of the available to install non-core extensions are printed to the
                calling environment's STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                     $ cat $HOME/test
                     #!/usr/bin/env bash
                     source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                     modules extensions
                     extensions_available
            %td.code
              .highlight
                %pre
                  :preserve
                    
                    
          %tr
            %td.docs
              %pre
                %code
                  :preserve
                     $  $HOME/test
                     ack androidsdk apache bash bcrypt cacti cmake ctags curl deploy erlang fossil freetype ghc ghostscript git god iconv imagemagick jpeg keepalived lcms libevent libpng libwmf libxml2 libxslt logrotate lua memcached mercurial mongodb monit mysql nginx node npm openpkg openssl p7zip passenger pcre perl postgresql r rails rainbows readline redis riak rsync rvm screen sphinx sqlite3 subversion system thin tiff tig tmux unicorn unrar zeromq zlib zsh
            %td.code
              .highlight
                %pre
                  extensions_available
                  %span.o ()
                  %span.o {
                  extensions_in
                  %span.s2 &quot;${extensions_src_path}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                extensions
                %em> in
                development()
              %p Lists the extensions available in the development repository, if set.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                The names of the available to install non-core development repository
                extensions are printed to the calling environment's STDOUT, if defined.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                     $ cat $HOME/test
                     #!/usr/bin/env bash
                     source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                     modules extensions
                     extensions_in_development
            %td.code
              .highlight
                %pre
                  :preserve
                    
                    
          %tr
            %td.docs
              %pre
                %code
                  :preserve
                     $  $HOME/test
                     ack androidsdk apache bash bcrypt cacti cmake ctags curl deploy erlang fossil freetype ghc ghostscript git god iconv imagemagick jpeg keepalived lcms libevent libpng libwmf libxml2 libxslt logrotate lua memcached mercurial mongodb monit mysql nginx node npm openpkg openssl p7zip passenger pcre perl postgresql r rails rainbows readline redis riak rsync rvm screen sphinx sqlite3 subversion system thin tiff tig tmux unicorn unrar zeromq zlib zsh
            %td.code
              .highlight
                %pre
                  extensions_in_development
                  %span.o ()
                  %span.o {
                  %span.nb true
                  %span.s2 &quot;${extensions_development_path:=&quot;
                  %span.k ${
                  %span.nv extensions_src_path
                  %span.k }
                  %span.s2 &quot;}&quot;
                  list_extensions_in
                  %span.s2 &quot;${extensions_development_path}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 extensions_in()
              %p Lists the extensions in a given directory.
              %h3 Input Parameters
              %p
                First parameter is a full path a BDSM extensions directory.
                (example: /usr/local/bdsm/extensions)
              %h3 Stream Outputs
              %p
                The names of the extensions in the given directory are printed to the
                calling environment's STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    $ cat $HOME/test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules extensions
                    extensions_in /usr/local/bdsm/extensions
                    
                    $  $HOME/test
                    bash fossil git libevent nginx p7zip postgresql rails redis tig tmux zeromq zlib
            %td.code
              .highlight
                %pre
                  extensions_in
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  directory_exists
                  %span.s2 &quot;${_path}&quot;
                  %span.o ||
                  fail
                  %span.s2 &quot;Cannot list extensions in '${_path}' as the directory does not exist.&quot;
                  %span.nv _files
                  %span.o =(
                  = succeed "find" do
                    %span.k $(
                  %span.s2 &quot;${_path}&quot;
                  \-mindepth 2 -maxdepth 2 -name
                  %span.s1 'VERSION'
                  \-type f
                  %span.k )
                  %span.o )
                  %span.nv extensions
                  %span.o =()
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  %span.k                   %span.nv extension_source_path
                  %span.o =
                  %span.s2 &quot;${_file/%\/VERSION}&quot;
                  %span.nv extension_name
                  %span.o =
                  %span.s2 &quot;${extension_source_path//*\/}&quot;
                  %span.k case
                  %span.k ${
                  %span.nv extension_name
                  %span.k }
                  in
                  = succeed "core|ext|mod|pkg|srv|svc|" do
                    %span.o (
                  = succeed "." do
                    %span.o [[=
                  = succeed "*" do
                    %span.o =]]
                  %span.o )
                  %span.nb true
                  %span.c # Ignore core extensions, they are updated with BDSM itself.
                  ;;
                  = succeed "*" do
                    %span.o (
                  %span.o )
                  extensions
                  %span.o [
                  %span.k ${#
                  %span.nv extensions
                  %span.p [@]
                  %span.k }
                  %span.o ]=
                  %span.s2 &quot;${extension_name//*\//}&quot;
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k                   %span.nv extensions
                  %span.o =
                  %span.s2 &quot;${extensions[@]}&quot;
                  %span.nb printf
                  %span.s2 &quot;${extensions}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 extension_actions()
              %p Lists actions exposed by the named extension.
              %h3 Input Parameters
              %p First parameter is the name of the extension to list actions for.
              %h3 Stream Outputs
              %p
                The names of the extensions in the given directory are printed to the
                calling environment's STDOUT.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Fails if no extension name is given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                     $ cat $HOME/test
                     #!/usr/bin/env bash
                     source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                     modules extensions
                     extension_actions "postgresql"
                    
                     $ $HOME/test
                     backup configure help initialize install restart start status stop uninstall upgrade
            %td.code
              .highlight
                %pre
                  extension_actions
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _extension
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_extension}&quot;
                  %span.o ]]
                  %span.o ||
                  fail
                  %span.s2 &quot;Cannot list actions for extension as no extension was given.&quot;
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;$extensions_path/${_extension}/bin&quot;
                  directory_exists
                  %span.s2 &quot;${_path}&quot;
                  %span.o ||
                  = succeed "0" do
                    %span.k return
                  %span.nb local
                  %span.nv _files
                  %span.o =(
                  = succeed "find" do
                    %span.k $(
                  %span.s2 &quot;${_path}&quot;
                  \-mindepth 1 -maxdepth 1 -type f
                  %span.k )
                  %span.o )
                  = succeed "_file" do
                    %span.nb local
                  %span.nv _actions
                  %span.o =()
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  %span.o [[
                  \! -x
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.o ||
                  _actions+
                  %span.o =(
                  %span.s2 &quot;${_file//*\/}&quot;
                  %span.o )
                  %span.k done
                  %span.k                   %span.nv _actions
                  %span.o =
                  %span.s2 &quot;${_actions[@]}&quot;
                  %span.c # Convert from array to string.
                  %span.nb printf
                  %span.s2 &quot;${_actions}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                extension
                %em> is
                installed()
              %p Tests if a given extension is installed.
              %h3 Input Parameters
              %p First parameter is an extension name.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the extension is installed.
                1 if the extension is not installed.
              %h3 Failure Scenarios
              %p Fails if no extension name is given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    $ cat $HOME/test
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    modules extensions
                    extensions_installed
                    echo
                    for extension in postgresql asdf
                    do
                      if extension_is_installed "${extension}"
                      then
                        echo "${extension} is installed! "
                      else
                        echo "${extension} is NOT installed! "
                      fi
                    done
                    
                    $  $HOME/test
                    bash fossil git libevent mysql nginx node npm p7zip postgresql rails redis tig tmux zeromq zlib
                    postgresql is installed!
                    asdf is NOT installed!
            %td.code
              .highlight
                %pre
                  extension_is_installed
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _name
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_name}&quot;
                  %span.o ]]
                  %span.o ||
                  fail
                  %span.s2 &quot;Can not check for an installed extension as no extension name was given.&quot;
                  %span.nb local
                  %span.nv _extensions
                  %span.o =
                  %span.s2 &quot; $(extensions_in &quot;
                  %span.k ${
                  %span.nv extensions_path
                  %span.k }
                  %span.s2 &quot;) &quot;
                  %span.k case
                  %span.s2 &quot;${_extensions}&quot;
                  in
                  = succeed "*" do
                    %span.o (
                  = succeed ":space:" do
                    %span.o [[
                  %span.o ]]
                  %span.k ${
                  %span.nv _name
                  %span.k }
                  = succeed ":space:" do
                    %span.o [[
                  = succeed "*" do
                    %span.o ]]
                  %span.o )
                  = succeed "0" do
                    %span.k return
                  ;;
                  = succeed "*" do
                    %span.o (
                  %span.o )
                  = succeed "1" do
                    %span.k return
                  ;;
                  %span.k esac
                  %span.o }
          %tr
            %td.docs
              %h2 extensions_install()
              %p Installs the given extensions.
              %h3 Input Parameters
              %p One or more extension names.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                The named extensions will be installed to the filesystem in the BDSM
                extensions directory.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no extensions are passed in to install.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ extensions_install libevent tmux
            %td.code
              .highlight
                %pre
                  extensions_install
                  %span.o ()
                  %span.o {
                  = succeed "_extension" do
                    %span.nb local
                  %span.nb local
                  %span.nv _extensions
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _extensions
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot install extensions as no extensions were given to install.&quot;
                  %span.k fi
          %tr
            %td.docs
              %p
                We need to ensure that the extensions directory already exists before calling
                install in parallel.
            %td.code
              .highlight
                %pre
                  extension_fetch
                  %span.s2 &quot;${extension_uri:=&quot;
                  %span.k ${
                  %span.nv extensions_repository_url
                  %span.k }
                  %span.s2 &quot;}&quot;
                  = succeed "_extension" do
                    %span.k for
                  in
                  %span.s2 &quot;${_extensions[@]}&quot;
                  %span.k do
                  %span.k case
                  %span.s2 &quot;${_extension#\/}&quot;
                  in
                  ext|srv|pkg|core|mod
                  %span.o )
                  %span.k continue
                  %span.c # Skip core extensions.
                  ;;
                  %span.k esac
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_extension}&quot;
                  %span.o ]]
                  %span.k then
                  %span.c # Skip any empty extensions / 'artifact'.
                  %span.k continue
                  %span.k else
                  %span.o (
                  extension_install
                  %span.s2 &quot;${_extension}&quot;
                  = succeed "&amp;amp;" do
                    %span.o )
                  %span.k fi
                  %span.k done
                  %span.k                   %span.nb wait
                  %span.o }
          %tr
            %td.docs
              %h2 extension_install()
              %p Installs the given extension.
              %h3 Input Parameters
              %p First parameter is the name of the extension to install
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                The named extension will be installed to the filesystem in the BDSM
                extension directory.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no extension are passed in to install.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ extension_install redis
            %td.code
              .highlight
                %pre
                  extension_install
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _extension
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_extension}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot install an extension as no extension name was given.&quot;
                  %span.k fi
                  = succeed "extension_is_valid" do
                    %span.k if
                  %span.s2 &quot;${extension_src_path}/${_extension}&quot;
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot; - ${_extension}&quot;
                  copy_directories to
                  %span.s2 &quot;${bdsm_path}/extensions&quot;
                  %span.s2 &quot;${extension_src_path}/${_extension}&quot;
                  log
                  %span.s2 &quot;${extension_uri}&quot;
                  to
                  %span.s2 &quot;${bdsm_path}/extensions/${_extension}/.uri&quot;
          %tr
            %td.docs
              %p TODO: Process extension dependencies...
            %td.code
              .highlight
                %pre
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;${extension_src_path} is not a proper extension.
                  %span.s2 The named extension is missing VERSION and/or bin/help files.
                  %span.s2 Halting installation.&quot;
                  %span.k fi
                  %span.o }
                  extension_fetch_and_install
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _extension
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_extension}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot fetch and install an extension as no extension name was given.&quot;
                  %span.k fi
                  = succeed "extension_fetch" do
                    %span.k                   %span.s2 &quot;${extension_uri:=&quot;
                  %span.k ${
                  %span.nv extensions_repository_url
                  %span.k }
                  %span.s2 &quot;}&quot;
                  extension_install
                  %span.s2 &quot;${_extension}&quot;
                  %span.o }
                  extension_fetch
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _url
                  %span.o =
                  %span.s2 &quot;${1:-$extension_uri}&quot;
                  %span.nb local
                  %span.nv _identifier
                  %span.o =
                  %span.s2 &quot;${_url//\//_}&quot;
                  %span.c # Convert '/' to an invalid url component '_'
                  %span.nb local
                  %span.nv repo_path
                  %span.o =
                  %span.s2 &quot;${repos_path}/${_identifier}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_url}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot fetch an extension from a url as no url was given&quot;
                  %span.k fi
          %tr
            %td.docs
              %p TODO: scm fetch vs tarball fetch
            %td.code
              .highlight
                %pre
                  scm_fetch
                  %span.s2 &quot;${_url}&quot;
                  scm_update
                  %span.s2 &quot;${_url}&quot;
                  %span.nv extension_src_path
                  %span.o =
                  %span.s2 &quot;${repo_path}&quot;
                  %span.o }
                  extension_is_valid
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot determine if an extension is valid as the path to the extension was not given.&quot;
                  %span.k fi
          %tr
            %td.docs
              %p TODO: Add all extension requirement checks here.
            %td.code
              .highlight
                %pre
                  %span.k if
                  %span.o [[
                  \-s
                  %span.s2 &quot;${_path}/VERSION&quot;
                  %span.o &amp;&amp;
                  \-x
                  %span.s2 &quot;${_path}/bin/help&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
                  extension_package
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _name
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_name}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot package an extension as no extension name was given.&quot;
                  %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${extensions_development_path:-&quot;
                  %span.nv $extensions_src_path
                  %span.s2 &quot;}&quot;
                  enter
                  %span.s2 &quot;${_path}&quot;
                  = succeed "extension_is_valid" do
                    %span.k if
                  %span.s2 &quot;${_path}/${_name}&quot;
                  %span.k then
                  %span.k                   %span.nb local
                  %span.nv _version
                  %span.o =
                  %span.s2 &quot;$(cat &quot;
                  %span.k ${
                  %span.nv _name
                  = succeed "/VERSION" do
                    %span.k }
                  %span.s2 &quot;)&quot;
                  log
                  %span.s2 &quot;Packaging extension ${_name}&quot;
                  log
                  %span.s2 &quot;${_name}-${_version}:&quot;
                  = succeed "archiver" do
                    %span.k for
                  in
                  %span.s2 &quot;gzip&quot;
                  %span.s2 &quot;bzip2 -z&quot;
                  %span.s2 &quot;xz -z&quot;
                  %span.k do
                  = succeed "command_exists" do
                    %span.k if
                  %span.k ${
                  %span.nv archiver
                  %span.p // *
                  %span.k }
                  %span.k then
                  = succeed "tar" do
                    %span.k if
                  cf
                  %span.s2 &quot;${_name}-${_version}.tar&quot;
                  %span.s2 &quot;${_name}/&quot;
                  %span.k then
                  %span.k ${
                  %span.nv archiver
                  %span.k }
                  \-f -9
                  %span.s2 &quot;${_name}-${_version}.tar&quot;
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;There was an error ($?) while trying to create a tar of the '${_name}' directory while packaging.&quot;
                  %span.k fi
                  %span.k fi
                  = succeed "ensure_paths_exist" do
                    %span.k                   %span.s2 &quot;${_path}/pkg&quot;
                  = succeed "file" do
                    %span.k for
                  in
                  = succeed ".tar.*" do
                    %span.s2 &quot;${_name}-${_version}&quot;
                  %span.k do
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;  - ${file}&quot;
                  log
                  %span.s2 &quot;$( file_md5 &quot;
                  %span.k ${
                  %span.nv file
                  %span.k }
                  %span.s2 &quot; )&quot;
                  to
                  %span.s2 &quot;${file}.md5&quot;
                  log
                  %span.s2 &quot;  - ${file}.md5&quot;
                  move_files --force
                  %span.s2 &quot;${file}&quot;
                  %span.s2 &quot;${file}.md5&quot;
                  to
                  %span.s2 &quot;${_path}/pkg&quot;
                  %span.k done
                  %span.k done
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Packaging complete (packages are located in '${_path}/pkg' )&quot;
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot package extension '${_name}' as the extension is not valid.&quot;
                  %span.k fi
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h2 package_error
              %p
                Presents the user with a package related error message including the tail
                of an optional log file.
              %h3 Input Parameters
              %p
                String to be logged, an optional log file containing more details and
                an optional number of lines of the file to show (defaults to 25)
              %h3 Stream Outputs
              %p
                Prints arguments passed in to the calling environments STDOUT with a newline
                character appended and 'ERROR ' prepended.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 1 for failure.
              %h3 Failure Scenarios
              %p Fails if no arguments are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ package_error "Hello there! " configure.log 5
                    ERROR Hello there!
                    
                    
                    Tail of configure.log:
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  %span.c #			checking for inflate in -lz... no
                  %span.c #			configure: error: zlib library not found
                  %span.c #			If you have zlib already installed, see config.log for details on the
                  %span.c #			failure.  It is possible the compiler isn't looking in the proper directory.
                  %span.c #			Use --without-zlib to disable zlib support.
          %tr
            %td.docs
              %pre
                %code
                  :preserve
                    *poof* shell closed...
            %td.code
              .highlight
                %pre
                  package_error
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _message
                  %span.o =
                  %span.nv $1
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_message}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot print a package error as no message was provided.&quot;
                  %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _log
                  %span.o =
                  %span.nv $2
                  %span.k if
                  %span.o [[
                  \-n
                  %span.k ${
                  %span.nv _log
                  %span.k }
                  %span.o ]]
                  %span.o &amp;&amp;
                  file_exists
                  %span.k ${
                  %span.nv _log
                  %span.k }
                  %span.k then
                  %span.c # Append tail of error log to the error message.
                  %span.nb local
                  %span.nv _num_lines
                  %span.o =
                  %span.k ${
                  %span.nv 3
                  %span.k :-
                  %span.nv 25
                  %span.k }
                  %span.c # Default the number of lines to 25
                  %span.nv _message
                  %span.o =
                  %span.s2 &quot;${_message}\n\nTail of ${_log}:\n$( tail -n ${_num_lines} ${_log} )&quot;
                  %span.k fi
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;${_message}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 package_definition
              %p Enables module developers to easily set package variables in name, value pairs.
              %h3 Input Parameters
              %p
                Parameters must come in pairs, variable name first (without the 'package'
                prefix), value second.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                For each name/value pair, a variable package_${name} is created with the given
                value.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if extension developer accidentailly separates key/value with an = :)
                Fails if a key is given without a matching value.
              %h3 Usage Examples
              %p Example Usage:
              %p
                user$ package_definition \
                name "bash" \
                version "4.2" \
                url "ftp.gnu.org/gnu/bash/"
              %h3 Notes
              %p
                For readability it is recommended to split the line into "key value" lines by
                ending the line with a singele backslash '\' character with no space afterwards.
            %td.code
              .highlight
                %pre
                  package_definition
                  %span.o ()
                  %span.o {
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  ;
                  %span.k do
                  %span.k                   %span.nv key
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  ;
                  %span.nb shift
                  %span.nb                   %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${1:-}&quot;
                  %span.o ]]
                  ;
                  %span.k then
                  %span.k                   %span.nv value
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  ;
                  %span.nb shift
                  %span.nb                   %span.k else
                  %span.k if
                  %span.nb echo
                  %span.s2 &quot;$key&quot;
                  | grep
                  %span.s1 '='
                  ;
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Invalid key '${key}'\n =&gt; Guess: Most likely the '=' is supposed to be a ' '.&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Value not specified for key '${key}'\n =&gt; They tend to come in pairs :)&quot;
                  %span.k fi
                  %span.k fi
                  %span.k case
                  %span.s2 &quot;$key&quot;
                  in
                  name
                  %span.o )
                  %span.nv package_name
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  version
                  %span.o )
                  %span.nv package_version
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  file
                  %span.o )
                  %span.nv package_file
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  dir
                  %span.o )
                  %span.nv package_dir
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  url
                  %span.o )
                  %span.nv package_url
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  base_url
                  %span.o )
                  %span.nv package_base_url
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  docs_url
                  %span.o )
                  %span.nv package_docs_url
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  patches_url
                  %span.o )
                  %span.nv package_patches_url
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  md5_url
                  %span.o )
                  %span.nv package_md5_url
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  active_path
                  %span.o )
                  %span.nv active_path
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  bin_path
                  %span.o )
                  %span.nv bin_path
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  packages_path
                  %span.o )
                  %span.nv packages_path
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  source_path
                  %span.o )
                  %span.nv source_path
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  target_path
                  %span.o )
                  %span.nv target_path
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
                  archive_format
                  %span.o )
                  %span.nv archive_format
                  %span.o =
                  %span.s2 &quot;${value}&quot;
                  ;;
          %tr
            %td.docs
              %p TODO: Simplify into
            %td.code
              .highlight
                %pre
                  %span.c #(+([[[:alnum:]]|])_path|name|version|url|md5_url)
          %tr
            %td.docs
              %p
                eval "${key}=${value}"
                ;;
            %td.code
              .highlight
                %pre
                  *
                  %span.o )
                  fail
                  %span.s2 &quot;Unknown key '${key}' (value: ${value})&quot;
                  ;;
                  %span.k esac
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 package_install
              %p
                Performs all package installation steps:
                * download
                * extract
                * patch
                * confiure
                * build
                * install
                * postinstall
                * activation
                * service setup, if service module is loaded
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Steps performed are logged to STDOUT of the calling environment.
              %h3 Environmental effects
              %p Package installation artifacts are created in the system and source directories.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Fails if any of the constituant components fail.
              %h3 Usage Examples
              %p Example Usage:
              %p
                user$ package_definition \
                name "bash" \
                version "4.2" \
                url "ftp.gnu.org/gnu/bash/"
              %p user$ package_install
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_install
                  %span.o ()
                  %span.o {
                  variables_must_be_nonempty package_name package_version archive_format
                  %span.nb true
                  %span.s2 &quot;${package_dir:=&quot;
                  %span.k ${
                  %span.nv package_name
                  = succeed "-" do
                    %span.k }
                  %span.k ${
                  %span.nv package_version
                  %span.k }
                  %span.s2 &quot;}&quot;
                  ensure_paths_exist
                  %span.s2 &quot;${source_path}&quot;
                  enter
                  %span.s2 &quot;${source_path}&quot;
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_download&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_download&quot;
                  %span.k else
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Downloading ${package_name} ${package_version}&quot;
                  package_fetch
                  %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_preextract&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_preextract&quot;
                  %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_extract&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_extract&quot;
                  %span.k else
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Extracting ${package_name} ${package_version}&quot;
                  package_extract
                  %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_postextract&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_postextract&quot;
                  %span.k fi
                  = succeed "enter" do
                    %span.k                   %span.s2 &quot;${package_dir}&quot;
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_patch&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_patch&quot;
                  %span.k else
                  = succeed "package_patch" do
                    %span.k                   %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_preconfigure&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_preconfigure&quot;
                  %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_configure&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_configure&quot;
                  %span.k else
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Configuring ${package_name} ${package_version}&quot;
                  package_configure
                  %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_postconfigure&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_postconfigure&quot;
                  %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_build&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_build&quot;
                  %span.k else
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Building ${package_name} ${package_version}&quot;
                  package_build
                  %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_preinstall&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_preinstall&quot;
                  %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_install&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_install&quot;
                  %span.k else
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Installing ${package_name} ${package_version}&quot;
                  package_make_install
                  
                  log
                  %span.s2 &quot;Installed ${package_name} ${package_version}.&quot;
                  %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_postinstall&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_postinstall&quot;
                  %span.k fi
                  = succeed "package_activate_if_first" do
                    %span.k                   %span.s2 &quot;${package_name}&quot;
                  %span.s2 &quot;${package_version}&quot;
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${package_name}_postactivate&quot;
                  %span.k then
                  %span.s2 &quot;${package_name}_postactivate&quot;
                  %span.k fi
                  = succeed "package_setup" do
                    %span.k                   = succeed "module_is_loaded" do
                    %span.k if
                  %span.s2 &quot;service&quot;
                  %span.k then
                  = succeed "service_setup" do
                    %span.k                   %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                package
                %em> fetch
                md5
              %p Fetches the package's md5 sum from the md5_url, if given.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p The 'package_md5' variable is set with the downloaded md5 sum.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Fails if any of the constituant components fail.
              %h3 Usage Examples
              %p Example Usage:
              %p
                user$ package
                %em> fetch
                md5
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_fetch_md5
                  %span.o ()
                  %span.o {
                  variables_must_be_nonempty package_name package_version archive_format
                  = succeed "download_url" do
                    %span.nb local
                  \:
                  %span.se \
                  %span.s2 &quot;${package_file:=&quot;
                  %span.k ${
                  %span.nv package_name
                  = succeed "-" do
                    %span.k }
                  %span.k ${
                  %span.nv package_version
                  = succeed "." do
                    %span.k }
                  %span.k ${
                  %span.nv archive_format
                  %span.k }
                  %span.s2 &quot;}&quot;
                  %span.se \
                  %span.s2 &quot;${packge_md5_url:=&quot;
                  %span.k ${
                  %span.nv package_base_url
                  = succeed "/" do
                    %span.k }
                  %span.k ${
                  %span.nv package_file
                  = succeed ".md5" do
                    %span.k }
                  %span.s2 &quot;}&quot;
                  %span.se \
                  %span.s2 &quot;${package_md5:=$( hash_file &quot;
                  %span.k ${
                  %span.nv extension_config_path
                  = succeed "/md5" do
                    %span.k }
                  %span.s2 &quot; &quot;
                  %span.k ${
                  %span.nv package_file
                  %span.k }
                  %span.s2 &quot; )}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${package_md5}&quot;
                  %span.o &amp;&amp;
                  \-n
                  %span.s2 &quot;${package_md5_url}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "curl" do
                    %span.k                   \-L
                  %span.s2 &quot;${packge_md5_url}&quot;
                  \-o
                  %span.s2 &quot;${package_file}.md5&quot;
                  2&gt;/dev/null
                  %span.o ||
                  error
                  %span.s2 &quot;Fetching md5 from '${package_md5_url}' failed.&quot;
                  %span.nv package_md5
                  %span.o =
                  = succeed "cat" do
                    %span.k $(
                  %span.s2 &quot;${package_file}.md5&quot;
                  %span.k )
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 package_fetch
              %p Fetches the package's archive file.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p curl output goes to STDERR of the calling environment.
              %h3 Environmental effects
              %p The package archive file will be placed on the filesystem.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_fetch
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_fetch
                  %span.o ()
                  %span.o {
                  variables_must_be_nonempty package_name package_version archive_format
                  
                  \:
                  %span.se \
                  %span.s2 &quot;${package_file:=&quot;
                  %span.k ${
                  %span.nv package_name
                  = succeed "-" do
                    %span.k }
                  %span.k ${
                  %span.nv package_version
                  = succeed "." do
                    %span.k }
                  %span.k ${
                  %span.nv archive_format
                  %span.k }
                  %span.s2 &quot;}&quot;
                  %span.se \
                  %span.s2 &quot;${package_url:=&quot;
                  %span.k ${
                  %span.nv package_base_url
                  = succeed "/" do
                    %span.k }
                  %span.k ${
                  %span.nv package_file
                  %span.k }
                  %span.s2 &quot;}&quot;
                  package_fetch_md5
                  = succeed "variable_is_nonempty" do
                    %span.k if
                  package_md5
                  %span.k then
                  = succeed "file_matches_md5" do
                    %span.k                   %span.s2 &quot;${package_file}&quot;
                  %span.s2 &quot;${package_md5}&quot;
                  %span.o ||
                  %span.o {
                  log
                  %span.s2 &quot;${package_file} does not match md5 ${package_md5}, removing and downloading.&quot;
                  remove_files
                  %span.s2 &quot;${package_file}&quot;
                  curl -L
                  %span.s2 &quot;${package_url}&quot;
                  \-o
                  %span.s2 &quot;${package_file}&quot;
                  %span.o ||
                  error
                  %span.s2 &quot;Downloading ${package_name} from '${package_url}' to '${package_file}' failed &quot;
                  %span.o }
                  %span.k else
                  = succeed "curl" do
                    %span.k                   \-L
                  %span.s2 &quot;${package_url}&quot;
                  \-o
                  %span.s2 &quot;${package_file}&quot;
                  %span.o ||
                  error
                  %span.s2 &quot;Downloading ${package_name} from '${package_url}' to '${package_file}' failed &quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 package_extract
              %p Extracts the package archive into the package source directory.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p The 'package_md5' variable is set with the downloaded md5 sum.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Errors halting program if any extraction fails or if the archive format is
                unknown.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_extract
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_extract
                  %span.o ()
                  %span.o {
                  extract_archive
                  %span.s2 &quot;${package_file}&quot;
                  %span.s2 &quot;${source_path}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 package_configure
              %p Configures the package source (eg. ./configure ...).
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Makefile will be generated for a standard package extension.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if configuration fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_configure
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_configure
                  %span.o ()
                  %span.o {
                  = succeed "_command" do
                    %span.nb local
                  %span.k if
                  %span.o [[
                  \-n
                  %span.k ${
                  %span.nv configure_command
                  %span.k :-}
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _command
                  %span.o =
                  %span.s2 &quot;${configure_command}&quot;
                  %span.k else
                  %span.k                   %span.nb export
                  %span.nv PREFIX
                  %span.o =
                  %span.s2 &quot;${install_base_path}/${package_version}&quot;
                  %span.nv _command
                  %span.o =
                  = succeed "--prefix" do
                    %span.s2 &quot;./configure ${configure_flags[@]:-&quot;
                  %span.o =
                  %span.k ${
                  %span.nv install_path
                  %span.k :-
                  %span.nv $packages_path
                  %span.k }
                  %span.s2 &quot;}&quot;
                  file_is_executable
                  %span.s2 &quot;configure&quot;
                  %span.o ||
                  = succeed "0" do
                    %span.k return
                  %span.k fi
                  %span.k if
                  %span.k ${
                  %span.nv _command
                  %span.k }
                  \&gt; configure.log 2&gt;&amp;1
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Configuration of ${package_name} ${package_version} successful.&quot;
                  %span.k else
                  = succeed "package_error" do
                    %span.k                   %span.s2 &quot;Configuration of ${package_name} ${package_version} failed&quot;
                  %span.s2 &quot;configure.log&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 package_build
              %p builds the package source (eg. make)
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Makefile will be generated for a standard package extension.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if building fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_build
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_build
                  %span.o ()
                  %span.o {
                  = succeed "_command" do
                    %span.nb local
                  %span.k if
                  %span.o [[
                  \-n
                  %span.k ${
                  %span.nv make_command
                  %span.k :-}
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _command
                  %span.o =
                  %span.s2 &quot;${make_command}&quot;
                  %span.k else
                  %span.k                   %span.nv _command
                  %span.o =
                  = succeed "-j" do
                    %span.s2 &quot;make ${make_flags[@]:-&quot;
                  = succeed "os_cpu_count" do
                    %span.k $(
                  %span.k )
                  %span.s2 &quot;}&quot;
                  %span.k fi
                  %span.k if
                  %span.nb eval
                  %span.s2 &quot;${_command}&quot;
                  \&gt; make.log 2&gt;&amp;1
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "package_error" do
                    %span.k                   %span.s2 &quot;Compilation of ${package_name} ${package_version} failed! &quot;
                  %span.s2 &quot;make.log&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                package
                %em> make
                install
              %p make install  the package source (eg. make)
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Installation files will be installed to the install_path.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if make install fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p
                user$ package
                %em> make
                install
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_make_install
                  %span.o ()
                  %span.o {
                  = succeed "_command" do
                    %span.nb local
                  %span.k if
                  %span.o [[
                  \-n
                  %span.k ${
                  %span.nv make_install_command
                  %span.k :-}
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _command
                  %span.o =
                  %span.s2 &quot;${make_install_command}&quot;
                  %span.k else
                  %span.k                   %span.nv _command
                  %span.o =
                  %span.s2 &quot;make ${make_install_flags[@]:-install}&quot;
                  %span.k fi
                  %span.k if
                  %span.k ${
                  %span.nv _command
                  %span.k }
                  \&gt; make.install.log 2&gt;&amp;1
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "package_error" do
                    %span.k                   %span.s2 &quot;Installation of ${package_name} ${package_version} failed! &quot;
                  %span.s2 &quot;make.install.log&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 package_activate
              %p activates the package
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Symlink will be created to the active version in the package install path.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if activateing fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_activate
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_activate
                  %span.o ()
                  %span.o {
          %tr
            %td.docs
              %p TODO: Switch package activation to
            %td.code
              .highlight
                %pre
                  %span.nb local
                  %span.nv _package
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.nv _version
                  %span.o =
                  %span.s2 &quot;${2:-}&quot;
                  variables_must_be_nonempty _package _version
                  = succeed "symlink_exists" do
                    %span.k if
                  %span.s2 &quot;${packages_path}/${_package}/active&quot;
                  %span.k then
                  = succeed "package_deactivate" do
                    %span.k                   %span.s2 &quot;${_package}&quot;
                  %span.k fi
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${install_path}&quot;
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Activating ${_package} ${_version}&quot;
                  = succeed "command_exists" do
                    %span.k if
                  rsync
                  %span.k then
                  = succeed "rsync" do
                    %span.k                   \-a
                  %span.s2 &quot;${install_path}/&quot;
                  %span.s2 &quot;${active_path}/&quot;
                  %span.k else
                  = succeed "cp" do
                    %span.k                   \-Rf
                  %span.s2 &quot;${install_path}/&quot;
                  %span.s2 &quot;${active_path}&quot;
                  %span.k fi
                  = succeed "link" do
                    %span.k                   \--force
                  %span.s2 &quot;${packages_path}/${_package}/${_version}&quot;
                  %span.se \
                  to
                  %span.s2 &quot;${packages_path}/${_package}/active&quot;
                  %span.k else
                  = succeed "warn" do
                    %span.k                   %span.s2 &quot;Skipping activation of ${_package} ${_version} &quot;
                  %span.se \
                  %span.s2 &quot;as '${install_path}' does not exist.&quot;
                  %span.k fi
                  = succeed "package_setup" do
                    %span.k                   %span.s2 &quot;${_package}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 package_setup
              %p Sets up the package
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p
                ldconfig, profile.d and service (init.d / conf.d) files will be put in place
                on the system.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if setup fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_setup
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_setup
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _package
                  %span.o =
                  %span.s2 &quot;${1:-${package_name}}&quot;
                  package_ldconfig
                  %span.s2 &quot;${_package}&quot;
                  package_profile_d
                  %span.s2 &quot;${_package}&quot;
                  = succeed "module_is_loaded" do
                    %span.k if
                  %span.s2 &quot;service&quot;
                  %span.k then
                  = succeed "service_setup" do
                    %span.k                   %span.s2 &quot;${_package}&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 package_deactivate
              %p deactivates the package
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Active symlinks will be removed from the filesystem.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if deactivating fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_deactivate
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_deactivate
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _package
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _file _files
                  
                  variables_must_be_nonempty _package
                  
                  log
                  %span.s2 &quot;Deactivating ${_package}&quot;
                  %span.o (
                  enter
                  %span.s2 &quot;${install_path}&quot;
                  %span.nv directories
                  %span.o =(
                  = succeed "find" do
                    %span.k $(
                  \. -type d
                  %span.k )
                  %span.o )
                  %span.nv files
                  %span.o =(
                  = succeed "find" do
                    %span.k $(
                  \. -type f
                  %span.k )
                  %span.o )
                  = succeed "file" do
                    %span.k for
                  in
                  %span.s2 &quot;${files[@]}&quot;
                  %span.k do
                  = succeed "rm" do
                    %span.k                   \-f
                  %span.s2 &quot;${active_path}/${file#.\/}&quot;
                  %span.k done
                  %span.o )
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;/etc/ld.so.profile.d/${_package}.conf&quot;
                  %span.s2 &quot;/etc/profile.d/${_package}.sh&quot;
                  %span.s2 &quot;${packages_path}/${_package}/active&quot;
                  %span.o )
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 $&quot;${_files[@]}&quot;
                  %span.k do
                  = succeed "file_exists" do
                    %span.k if
                  %span.s2 &quot;${_file}&quot;
                  %span.k then
                  = succeed "remove_files" do
                    %span.k                   %span.s2 &quot;${_file}&quot;
                  %span.k fi
                  %span.k done
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;${_package} deactivated&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                package
                %em> activate
                if_first
              %p
                Activates the package version , if another package version has not yet been
                activated.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p
                Active symlinks will be added to the filesystem if it is the first version
                installed.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if deactivating fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p
                user$ package
                %em> activate
                if_first
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_activate_if_first
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _package
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.nv _version
                  %span.o =
                  %span.s2 &quot;${2:-}&quot;
                  variables_must_be_nonempty _package _version
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${install_path}&quot;
                  %span.k then
                  = succeed "symlink_exists" do
                    %span.k                   %span.s2 &quot;${packages_path}/${_package}/active&quot;
                  %span.o ||
                  package_activate
                  %span.s2 &quot;${_package}&quot;
                  %span.s2 &quot;${_version}&quot;
                  %span.k else
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;'${install_path}' not found, skipping activation.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 package_ldconfig
              %p Sets up system level ldconfigs for the package libraries.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Adjusts ldconfig configuration and runs ldconfig (on linux).
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if deactivating fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_ldconfig
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_ldconfig
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _package
                  %span.o =
                  %span.s2 &quot;${1:-${package_name}}&quot;
                  _path _files
                  
                  variables_must_be_nonempty _package
                  
                  directory_exists
                  %span.s2 &quot;${packages_path}/${_package}/active/lib&quot;
                  %span.o ||
                  = succeed "0" do
                    %span.k return
                  %span.c # no lib/ directory for activated package, no need to update ldconfig
          %tr
            %td.docs
              %p TODO: Figure out if solaris and freebsd have an analog to this?
            %td.code
              .highlight
                %pre
                  %span.k> if
                  user_is_root
                  %span.k then
                  = succeed "os_is_linux" do
                    %span.k if
                  %span.k then
                  = succeed "ensure_paths_exist" do
                    %span.k                   %span.s2 &quot;/etc/ld.so.conf.d&quot;
                  %span.k if
                  \! file_exists
                  %span.s2 &quot;/etc/ld.so.conf.d/bdsm.conf&quot;
                  %span.k then
                  %span.k                   %span.nb printf
                  %span.s2 &quot;%s\n&quot;
                  %span.s2 &quot;${active_path}/lib&quot;
                  \&gt;
                  %span.s2 &quot;/etc/ld.so.conf.d/bdsm.conf&quot;
                  chmod_files 0644
                  %span.s2 &quot;/etc/ld.so.conf.d/bdsm.conf&quot;
                  %span.k fi
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Updating ldconfig for ${_package}&quot;
                  ldconfig
                  = succeed "os_is_darwin" do
                    %span.k elif
                  %span.k then
                  %span.c # Cluster Fuck.
                  %span.nb true
          %tr
            %td.docs
              %p
                This should be handled by the profile.d?
                %em> files=($(find "${packages
                path}/${
                %em>
                  package}/active" -mindepth 1 -maxdepth 1 -type d))
                  (( ${#
                files[@]} > 0 )) &amp;&amp; copy
                %em> files to "${packages
                path}" "${_files[@]}"
            %td.code
              .highlight
                %pre
                  %span.k fi
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                package
                %em> profile
                d
              %p Sets up system level profile_d configuration for the package
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Updates profile_d configuration for the given package
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if profile_d setup fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p
                user$ package
                %em> profile
                d
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_profile_d
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _package
                  %span.o =
                  %span.s2 &quot;${1:-${package_name}}&quot;
                  variables_must_be_nonempty _package
                  = succeed "template_exists" do
                    %span.k if
                  %span.s2 &quot;profile.d.template&quot;
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Updating shell profile for ${_package}&quot;
                  ensure_paths_exist
                  %span.s2 &quot;${profile_d_path}&quot;
                  ensure_files_exist
                  %span.s2 &quot;${profile_path}&quot;
                  install_template
                  %span.s2 &quot;profile.d&quot;
                  to
                  %span.s2 &quot;${profile_d_path}/${_package}.sh&quot;
                  mode 0755
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 package_uninstall
              %p Uninstalls the package
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Uninstalls the package install effects from the system.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if uninstall fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_uninstall
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_uninstall
                  %span.o ()
                  %span.o {
                  variables_must_be_nonempty package_name package_version archive_format
                  = succeed "package_is_active" do
                    %span.k if
                  %span.s2 &quot;${package_name}&quot;
                  %span.s2 &quot;${package_version}&quot;
                  %span.k then
                  %span.c # Deactivate the package if active.
                  package_deactivate
                  %span.s2 &quot;${package_name}&quot;
                  %span.k fi
                  = succeed "remove_paths" do
                    %span.k                   %span.s2 &quot;${install_path}&quot;
                  = succeed "module_is_loaded" do
                    %span.k if
                  service
                  %span.k then
                  %span.c # Remove any service reminants.
                  service_uninstall
                  %span.k fi
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;${package_name} ${package_version} has been uninstalled.&quot;
                  %span.o }
          %tr
            %td.docs
              %h2 package_patch
              %p Applies any patches found for the current package.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Updates the source code directory for the package with any patches found.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if patching fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_patch
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_patch
                  %span.o ()
                  %span.o {
                  = succeed "_patches" do
                    %span.nb local
                  _patch
                  %span.k if
                  \! directory_exists
                  %span.s2 &quot;${extension_patches_path}&quot;
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k fi
          %tr
            %td.docs
              %p
                TODO: Three level hierarchy based on patches/{OS}/{version},
                root level as 'global' always installed.
            %td.code
              .highlight
                %pre
                  :preserve
                    
                    
          %tr
            %td.docs
              %p TODO: Test each dir for existence and skip if missing
            %td.code
              .highlight
                %pre
                  %span.nv _patches
                  %span.o =(
                  = succeed "find" do
                    %span.k $(
                  %span.s2 &quot;${extension_patches_path}&quot;
                  \-mindepth 1 -maxdepth 1 -iname
                  %span.s1 '*.patch'
                  \-type f
                  %span.k )
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _patches
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k fi
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Applying patches for ${package_name} ${package_version}&quot;
                  package_apply_patches
                  %span.s2 &quot;${_patches[@]}&quot;
                  %span.k if
                  \! directory_exists
                  %span.s2 &quot;${extension_patches_path}/$(os_type)&quot;
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k fi
                  %span.k                   %span.nv _patches
                  %span.o =(
                  = succeed "find" do
                    %span.k $(
                  %span.s2 &quot;${extension_patches_path}/$(os_type)&quot;
                  \-mindepth 1 -maxdepth 1 -iname
                  %span.s1 '*.patch'
                  \-type f
                  %span.k )
                  %span.o )
                  package_apply_patches
                  %span.s2 &quot;${_patches[@]}&quot;
                  %span.k if
                  \! directory_exists
                  %span.s2 &quot;${extension_patches_path}/$(os_type)/${package_version}&quot;
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k fi
                  %span.k                   %span.nv _patches
                  %span.o =(
                  = succeed "find" do
                    %span.k $(
                  %span.s2 &quot;${extension_patches_path}/$(os_type)/${package_version}&quot;
                  \-mindepth 1 -maxdepth 1 -iname
                  %span.s1 '*.patch'
                  \-type f
                  %span.k )
                  %span.o )
                  package_apply_patches
                  %span.s2 &quot;${_patches[@]}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                package
                %em> apply
                patches
              %p Applies patches found
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Applies any patches found for the current package.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if apply_patches fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p
                user$ package
                %em> apply
                patches
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_apply_patches
                  %span.o ()
                  %span.o {
                  = succeed "_patch" do
                    %span.nb local
                  %span.nv _patches
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _patches
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot apply patches as no patches were given.&quot;
                  %span.k fi
                  = succeed "_patch" do
                    %span.k for
                  in
                  %span.s2 &quot;${_patches[@]}&quot;
                  %span.k do
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;TODO: patch application is NIY&quot;
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 package_usage
              %p Sets up system level usage configuration for the package
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Updates usage configuration for the given package
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if usage setup fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_usage
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_usage
                  %span.o ()
                  %span.o {
                  %span.nb printf
                  %span.s2 &quot;
                  %span.s2 Usage:
                  %span.s2 $0 [options]
                  %span.s2 options:
                  %span.s2 --prefix   - specify prefix path
                  %span.s2 --src)     - specify source directory
                  %span.s2 --data)    - specify data directory
                  %span.s2 --user)    - specify user to install as
                  %span.s2 --version) - specify version to install
                  %span.s2 --licence) - view licence
                  %span.s2 --help)    - view this usage information
                  %span.s2 &quot;
                  = succeed "0" do
                    %span.k return
                  %span.o }
          %tr
            %td.docs
              %h2 package_cli
              %p Parses package CLI arguments
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Updates cli configuration for the given package
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if cli setup fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_cli
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_cli
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _ignored_args
                  %span.o =()
                  %span.nv number_of_args
                  %span.o =
                  %span.k ${#
                  %span.nv extension_args
                  %span.p [@]
                  %span.k }
                  %span.k for
                  %span.o ((
                  %span.nv index
                  = succeed "0" do
                    %span.o =
                  ; index &lt;
                  %span.nv $number_of_args
                  ; index++
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;${extension_args[$index]}&quot;
                  %span.k case
                  %span.s2 &quot;$token&quot;
                  in
                  \--prefix
                  %span.o )
                  %span.nv packages_path
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--src
                  %span.o )
                  %span.nv src_path
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--data
                  %span.o )
                  %span.nv data_path
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--user
                  %span.o )
                  %span.nv package_user
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--version
                  %span.o )
                  %span.nv package_version
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--base_url
                  %span.o )
                  %span.nv package_base_url
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--file
                  %span.o )
                  %span.nv package_file
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--directory
                  %span.o )
                  %span.nv package_directory
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--archive_format
                  %span.o )
                  %span.nv archive_format
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--activate|activate
                  %span.o )
          %tr
            %td.docs
              %p TODO: Throw error if parameter is not specified.
            %td.code
              .highlight
                %pre
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv extension_args
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "package_activate" do
                    %span.k                   %span.s2 &quot;${extension}&quot;
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot activate ${extension}, no version was given.&quot;
                  %span.k fi
                  ;;
                  \--deactivate|deactivate
                  %span.o )
                  package_deactivate
                  %span.s2 &quot;${extension}&quot;
                  ;;
                  \--md5
                  %span.o )
                  %span.nv package_md5
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--licence
                  %span.o )
                  extension_license
                  = succeed "0" do
                    %span.nb exit
                  ;;
                  \--help
                  %span.o )
                  package_usage
                  = succeed "0" do
                    %span.nb exit
                  ;;
                  \--trace
                  %span.o )
                  %span.nb set
                  \-o xtrace
                  ;;
                  *
                  %span.o )
                  _ignored_args+
                  %span.o =(
                  %span.s2 &quot;${token}&quot;
                  %span.o )
                  ;;
                  %span.k esac
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _ignored_args
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nv extension_args
                  %span.o =(
                  %span.s2 &quot;${_ignored_args[@]}&quot;
                  %span.o )
                  %span.k fi
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 package_active
              %p Parses package active arguments
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Updates active configuration for the given package
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if active setup fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_active
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_is_active
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _name
                  %span.o =
                  %span.s2 &quot;${1:-${package_name}}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_name}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Can not query if a package is active as no package name was given or name is empty.&quot;
                  %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${packages_path}/${_name}&quot;
                  %span.k if
                  %span.o [[
                  \-L
                  %span.s2 &quot;${_path}/active&quot;
                  %span.o &amp;&amp;
                  \-d
                  = succeed "readlink" do
                    %span.k $(
                  %span.s2 &quot;${_path}/active&quot;
                  %span.k )
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 package_must be
              %p Parses package must be arguments
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p Updates must be configuration for the given package
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p Errors halting program if must be setup fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_must be
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_must_be_active
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _name
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_name}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Can not ensure that package is active as no package name was given or name is empty.&quot;
                  %span.k fi
                  = succeed "package_is_active" do
                    %span.k if
                  %span.s2 &quot;${_name}&quot;
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Install/activate the node package extension before installing ${_name}.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                packages
                %em> must
                be_active
              %p
                Parses package must
                %em> be
                active arguments
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p
                Updates must
                %em> be
                active configuration for the given package
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Errors halting program if must
                %em> be
                active setup fails for any reason.
              %h3 Usage Examples
              %p Example Usage:
              %p
                user$ packages
                %em> must
                be_active
              %h3 Notes
            %td.code
              .highlight
                %pre
                  packages_must_be_active
                  %span.o ()
                  %span.o {
                  = succeed "_package" do
                    %span.nb local
                  %span.nv _packages
                  %span.o =
                  %span.s2 &quot;$@&quot;
                  %span.k if
                  %span.o ((
                  %span.s2 &quot;${#@}&quot;
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Can not ensure that packages are active as no packages were given.&quot;
                  %span.k fi
                  = succeed "_package" do
                    %span.k for
                  in
                  %span.s2 &quot;${_packages[@]}&quot;
                  %span.k do
                  = succeed "package_must_be_active" do
                    %span.k                   %span.s2 &quot;${_package}&quot;
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 package_docs
              %p
                Opens package documentation website either in the web browser (if able) or via
                curl through PAGER (defaulting to less).
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None if can open web browser or website docs in PAGER otherwise.
              %h3 Environmental effects
              %p Web browser will open with documentation url if able.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Error if package
                %em> docs
                url has not been set.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_docs
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_docs
                  %span.o ()
                  %span.o {
          %tr
            %td.docs
              %p TODO: move this logic into a core dsl function.
            %td.code
              .highlight
                %pre
                  %span.k> if
                  os_is_darwin
                  %span.k then
                  = succeed "open" do
                    %span.k                   %span.nv $package_docs_url
                  = succeed "command_exists" do
                    %span.k elif
                  xdg-open
                  %span.k then
                  = succeed "xdg-open" do
                    %span.k                   %span.nv $package_docs_url
                  = succeed "command_exists" do
                    %span.k elif
                  lynx
                  %span.k then
                  = succeed "lynx" do
                    %span.k                   %span.nv $package_docs_url
                  = succeed "command_exists" do
                    %span.k elif
                  links
                  %span.k then
                  = succeed "links" do
                    %span.k                   %span.nv $package_docs_url
                  %span.k else
                  = succeed "curl" do
                    %span.k                   \-s -L
                  %span.nv $package_docs_url
                  \-o /tmp/
                  %span.k ${
                  %span.nv package_name
                  = succeed "-" do
                    %span.k }
                  %span.k ${
                  %span.nv package_version
                  = succeed ".docs" do
                    %span.k }
                  %span.k ${
                  %span.nv EDITOR
                  %span.k :-
                  %span.p /bin/less
                  %span.k }
                  \/tmp/
                  %span.k ${
                  %span.nv package_name
                  = succeed "-" do
                    %span.k }
                  %span.k ${
                  %span.nv package_version
                  = succeed ".docs" do
                    %span.k }
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 package_website
              %p
                Opens package documentation website either in the web browser (if able) or via
                curl through PAGER (defaulting to less).
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None if can open web browser or website website in PAGER otherwise.
              %h3 Environmental effects
              %p Web browser will open with documentation url if able.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Error if package
                %em> website
                url has not been set.
              %h3 Usage Examples
              %p Example Usage:
              %p user$ package_website
              %h3 Notes
            %td.code
              .highlight
                %pre
                  package_website
                  %span.o ()
                  %span.o {
          %tr
            %td.docs
              %p TODO: move this logic into a core dsl function.
            %td.code
              .highlight
                %pre
                  %span.k> if
                  os_is_darwin
                  %span.k then
                  = succeed "open" do
                    %span.k                   %span.nv $package_website_url
                  = succeed "command_exists" do
                    %span.k elif
                  xdg-open
                  %span.k then
                  = succeed "xdg-open" do
                    %span.k                   %span.nv $package_website_url
                  = succeed "command_exists" do
                    %span.k elif
                  lynx
                  %span.k then
                  = succeed "lynx" do
                    %span.k                   %span.nv $package_website_url
                  = succeed "command_exists" do
                    %span.k elif
                  links
                  %span.k then
                  = succeed "links" do
                    %span.k                   %span.nv $package_website_url
                  %span.k else
                  = succeed "curl" do
                    %span.k                   \-s -L
                  %span.nv $package_website_url
                  \-o /tmp/
                  %span.k ${
                  %span.nv package_name
                  = succeed "-" do
                    %span.k }
                  %span.k ${
                  %span.nv package_version
                  = succeed ".website" do
                    %span.k }
                  %span.k ${
                  %span.nv EDITOR
                  %span.k :-
                  %span.p /bin/less
                  %span.k }
                  \/tmp/
                  %span.k ${
                  %span.nv package_name
                  = succeed "-" do
                    %span.k }
                  %span.k ${
                  %span.nv package_version
                  = succeed ".website" do
                    %span.k }
                  %span.k fi
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h1 General Services functions.
              %h2 services_list()
              %p
                List installed services. These are extensions that have loaded the service
                module.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                A list of available services to install are printed to STDOUT of
                the calling environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                NIY
                No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ services_avilable
                    Available service listing has not yet been implemented.
                    This feature has not yet been implemented.
              %h1 General Services functions.
              %h2 services_list()
              %p
                List installed services. These are extensions that have loaded the service
                module.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                A list of available services to install are printed to STDOUT of
                the calling environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                NIY
                No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ services_avilable
                    Available service listing has not yet been implemented.
                    This feature has not yet been implemented.
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
                  services_avilable
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;Available service listing has not yet been implemented.&quot;
                  NIY
                  services_installed
                  %span.o }
          %tr
            %td.docs
              %h2 services_installed()
              %p
                List installed services. These are extensions that have loaded the service
                module.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                A list of installed extensions that load the service module are printed
                to the STDOUT of the calling environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                NIY
                No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ services_installed
                    nginx unicorn redis postgresql
            %td.code
              .highlight
                %pre
                  services_installed
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;Installed services has not yet been implemented.&quot;
                  NIY
                  %span.o }
          %tr
            %td.docs
              %h2 services_available()
              %p List available services. These are extensions that load the service module.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                A list of available extensions that load the service module are printed to
                STDOUT of the calling environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                NIY
                No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ services_available
                    nginx redis postgresql mongodb ...
            %td.code
              .highlight
                %pre
                  services_available
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;Installed services has not yet been implemented.&quot;
                  NIY
                  %span.o }
          %tr
            %td.docs
              %h1 Single Service functions.
              %h2 service_setup()
              %p Service setup and configuration.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                Creates a system service user with the same name as the service.
                Sets up the service init_d file from template, if it exists.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_setup
                    ...
            %td.code
              .highlight
                %pre
                  service_setup
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;#creating paths for ${service} ${package_version}...&quot;
                  ensure_paths_exist
                  %span.s2 &quot;${service_paths[@]}&quot;
                  %span.s2 &quot;${install_path}&quot;
                  chown_paths_recursively
                  %span.s2 &quot;${service_user}:${service_user}&quot;
                  %span.s2 &quot;${service_paths[@]}&quot;
                  chown_paths_recursively
                  %span.s2 &quot;${service_user}:${service_user}&quot;
                  %span.se \
                  %span.s2 &quot;${service_root_paths[@]}&quot;
                  = succeed "user_is_root" do
                    %span.k if
                  %span.k then
          %tr
            %td.docs
              %p TODO: create an 'user_exists' function and use it here.
            %td.code
              .highlight
                %pre
                  user_create_if_missing
                  %span.s2 &quot;${service_user}&quot;
                  %span.se \
                  with group
                  %span.s2 &quot;${service_user}&quot;
                  2&gt;/dev/null
                  
                  ensure_paths_exist
                  %span.s2 &quot;${service_root_paths[@]}&quot;
                  chown_paths_recursively
                  %span.s2 &quot;${service_user}:${service_user}&quot;
                  %span.se \
                  %span.s2 &quot;${service_root_paths[@]}&quot;
                  %span.k fi
                  = succeed "service_install_init_d" do
                    %span.k                   %span.s2 &quot;${service}&quot;
                  %span.o }
          %tr
            %td.docs
              %h1 Single Service functions.
              %h2 service_uninstall()
              %p Service uninstall and configuration.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                Creates a system service user with the same name as the service.
                Sets up the service init_d file from template, if it exists.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure scenarios currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_uninstall
                    ...
            %td.code
              .highlight
                %pre
                  service_uninstall
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;TODO: service_uninstall is NIY&quot;
          %tr
            %td.docs
              %ol
                %li Remove init scripts
                %li Unload OS service hooks
                %li
                  Deactivate database path.
            %td.code
              .highlight
                %pre
                  %span.o }
          %tr
            %td.docs
              %h2 service_start()
              %p Starts the given service using init scripts.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Whatever stream output comes from the called init script.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if extension was not set.
                Fails if the init script is missing or not executable.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ extension=redis
                    user$ service_start
                    ...
            %td.code
              .highlight
                %pre
                  service_start
                  %span.o ()
                  %span.o {
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${service}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;In order to start a service the 'service' variable must be set.&quot;
                  %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${service}_start&quot;
                  %span.k then
                  %span.s2 &quot;${service}_start&quot;
                  %span.k else
                  = succeed "file_is_executable" do
                    %span.k if
                  %span.s2 &quot;${init_scripts_path}/${service}&quot;
                  %span.k then
                  = succeed "service_init_start" do
                    %span.k                   %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;${init_scripts_path}/${service} is missing or not executable.&quot;
                  %span.k fi
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 service_stop()
              %p stops the given service using init scripts.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Whatever stream output comes from the called init script.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if service was not set.
                Fails if the init script is missing or not executable.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_stop
                    ...
            %td.code
              .highlight
                %pre
                  service_stop
                  %span.o ()
                  %span.o {
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${service}_stop&quot;
                  %span.k then
                  %span.s2 &quot;${service}_stop&quot;
                  %span.k else
                  = succeed "file_is_executable" do
                    %span.k if
                  %span.s2 &quot;${init_scripts_path}/${service}&quot;
                  %span.k then
                  = succeed "service_init_stop" do
                    %span.k                   %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;${init_scripts_path}/${service} is missing or not executable.&quot;
                  %span.k fi
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 service_reload()
              %p reloads the given service using init scripts.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Whatever stream output comes from the called init script.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if service was not set.
                Fails if the init script is missing or not executable.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_reload
                    ...
            %td.code
              .highlight
                %pre
                  service_reload
                  %span.o ()
                  %span.o {
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${service}_reload&quot;
                  %span.k then
                  %span.s2 &quot;${service}_reload&quot;
                  %span.k else
                  = succeed "file_is_executable" do
                    %span.k if
                  %span.s2 &quot;${init_scripts_path}/${service}&quot;
                  %span.k then
                  = succeed "service_init_reload" do
                    %span.k                   %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;${init_scripts_path}/${service} is missing or not executable.&quot;
                  %span.k fi
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 service_restart()
              %p restarts the given service using init scripts.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Whatever stream output comes from the called init script.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if service was not set.
                Fails if the init script is missing or not executable.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_restart
                    ...
            %td.code
              .highlight
                %pre
                  service_restart
                  %span.o ()
                  %span.o {
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${service}_restart&quot;
                  %span.k then
                  %span.s2 &quot;${service}_restart&quot;
                  %span.k else
                  = succeed "file_is_executable" do
                    %span.k if
                  %span.s2 &quot;${init_scripts_path}/${service}&quot;
                  %span.k then
                  = succeed "service_init_stop" do
                    %span.k                   service_init_start
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;${init_scripts_path}/${service} is missing or not executable.&quot;
                  %span.k fi
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 service_status()
              %p statuss the given service using init scripts.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Whatever stream output comes from the called init script.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if service was not set.
                Fails if the init script is missing or not executable.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_status
                    ...
            %td.code
              .highlight
                %pre
                  service_status
                  %span.o ()
                  %span.o {
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${service}_status&quot;
                  %span.k then
                  %span.s2 &quot;${service}_status&quot;
                  %span.k else
                  = succeed "file_is_executable" do
                    %span.k if
                  %span.s2 &quot;${init_scripts_path}/${service}&quot;
                  %span.k then
                  = succeed "service_init_status" do
                    %span.k                   %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;${init_scripts_path}/${service} is missing or not executable.&quot;
                  %span.k fi
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 service_logtail()
              %p logtails the given service using init scripts.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Whatever stream output comes from the called init script.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if service was not set.
                Fails if the init script is missing or not executable.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_logtail
                    ...
            %td.code
              .highlight
                %pre
                  service_logtail
                  %span.o ()
                  %span.o {
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${service}_logtail&quot;
                  %span.k then
                  %span.s2 &quot;${service}_logtail&quot;
                  %span.k else
                  = succeed "file_is_executable" do
                    %span.k if
                  %span.s2 &quot;${init_scripts_path}/${service}&quot;
                  %span.k then
                  = succeed "service_init_logtail" do
                    %span.k                   %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;${init_scripts_path}/${service} is missing or not executable.&quot;
                  %span.k fi
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 service_info()
              %p infos the given service using init scripts.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Whatever stream output comes from the called init script.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if service was not set.
                Fails if the init script is missing or not executable.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_info
                    ...
            %td.code
              .highlight
                %pre
                  service_info
                  %span.o ()
                  %span.o {
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${service}_info&quot;
                  %span.k then
                  %span.s2 &quot;${service}_info&quot;
                  %span.k else
                  = succeed "file_is_executable" do
                    %span.k if
                  %span.s2 &quot;${init_scripts_path}/${service}&quot;
                  %span.k then
                  = succeed "service_init_info" do
                    %span.k                   %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;${init_scripts_path}/${service} is missing or not executable.&quot;
                  %span.k fi
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 service_configcheck()
              %p configchecks the given service using init scripts.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Whatever stream output comes from the called init script.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if service was not set.
                Fails if the init script is missing or not executable.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_configcheck
                    ...
            %td.code
              .highlight
                %pre
                  service_configcheck
                  %span.o ()
                  %span.o {
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${service}_configcheck&quot;
                  %span.k then
                  %span.s2 &quot;${service}_configcheck&quot;
                  %span.k else
                  = succeed "file_is_executable" do
                    %span.k                   %span.s2 &quot;${init_scripts_path}/${service}&quot;
                  %span.o ||
                  fail
                  %span.s2 &quot;${init_scripts_path}/${service} is missing or not executable.&quot;
                  %span.s2 &quot;${init_scripts_path}/${service}&quot;
                  configcheck
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 service_usage()
              %p usages the given service using init scripts.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Whatever stream output comes from the called init script.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if service was not set.
                Fails if the init script is missing or not executable.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_usage
                    ...
            %td.code
              .highlight
                %pre
                  service_usage
                  %span.o ()
                  %span.o {
          %tr
            %td.docs
              %p TODO: Update this for service specific items.
            %td.code
              .highlight
                %pre
                  %span.nb printf
                  %span.s2 &quot;
                  %span.s2 Usage:
                  %span.s2 $0 [options]
                  %span.s2 Options:
                  %span.s2 --prefix   - specify prefix path
                  %span.s2 --src)     - specify source directory
                  %span.s2 --data)    - specify data directory
                  %span.s2 --user)    - specify user to install as
                  %span.s2 --version) - specify version to install
                  %span.s2 --licence) - view licence
                  %span.s2 --help)    - view this usage information
                  %span.s2 &quot;
                  = succeed "0" do
                    %span.k return
                  %span.o }
          %tr
            %td.docs
              %h2 service_cli()
              %p clis the given service using init scripts.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Whatever stream output comes from the called init script.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if service was not set.
                Fails if the init script is missing or not executable.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_cli
                    ...
            %td.code
              .highlight
                %pre
                  service_cli
                  %span.o ()
                  %span.o {
          %tr
            %td.docs
              %p TODO: Update this for service specific items.
            %td.code
              .highlight
                %pre
                  %span.nb local
                  %span.nv _ignored_args
                  %span.o =()
                  %span.nv number_of_args
                  %span.o =
                  %span.k ${#
                  %span.nv extension_args
                  %span.p [@]
                  %span.k }
                  %span.k for
                  %span.o ((
                  %span.nv index
                  = succeed "0" do
                    %span.o =
                  ; index &lt;
                  %span.nv $number_of_args
                  ; index++
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;${extension_args[$index]}&quot;
                  %span.k case
                  %span.s2 &quot;$token&quot;
                  in
                  \--prefix
                  %span.o )
                  %span.nv prefix_path
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--src
                  %span.o )
                  %span.nv src_path
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--data
                  %span.o )
                  %span.nv data_path
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--user
                  %span.o )
                  %span.nv service_user
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--version
                  %span.o )
                  %span.nv service_version
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--base_url
                  %span.o )
                  %span.nv service_base_url
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--file
                  %span.o )
                  %span.nv service_file
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--directory
                  %span.o )
                  %span.nv service_directory
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--archive_format
                  %span.o )
                  %span.nv archive_format
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--activate|activate
                  %span.o )
          %tr
            %td.docs
              %p TODO: Throw error if parameter is not specified.
            %td.code
              .highlight
                %pre
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv extension_args
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "service_activate" do
                    %span.k                   %span.s2 &quot;${service}&quot;
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot activate ${service}, no version was given.&quot;
                  %span.k fi
                  ;;
                  \--deactivate|deactivate
                  %span.o )
                  service_deactivate
                  %span.s2 &quot;${service}&quot;
                  ;;
                  \--md5
                  %span.o )
                  %span.nv service_md5
                  %span.o =
                  %span.s2 &quot;${extension_args[$((++index))]}&quot;
                  ;;
                  \--help
                  %span.o )
                  service_usage
                  = succeed "0" do
                    %span.nb exit
                  ;;
                  \--trace
                  %span.o )
                  %span.nb set
                  \-o xtrace
                  ;;
                  *
                  %span.o )
                  _ignored_args+
                  %span.o =(
                  %span.s2 &quot;${token}&quot;
                  %span.o )
                  ;;
                  %span.k esac
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _ignored_args
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nv extension_args
                  %span.o =(
                  %span.s2 &quot;${_ignored_args[@]}&quot;
                  %span.o )
                  %span.k fi
                  %span.k done
                  = succeed "service_init_path" do
                    %span.k                   %span.o }
          %tr
            %td.docs
              %h2 service_pid()
              %p
                List installed services. These are extensions that have loaded the service
                module.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p
                A list of extensions that load the service module are printed to STDOUT of
                the calling environment.
              %h3 Environmental effects
              %p Sets the variable 'service_pid' to contain the pid of the process or 0.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p None currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    root# service=redis
                    root# service_pid
                    root# echo $service_pid
                    0
            %td.code
              .highlight
                %pre
                  service_pid
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  = succeed "/var/run" do
                    %span.s2 &quot;${run_path:=&quot;
                  %span.s2 &quot;}/${service}&quot;
                  %span.nb local
                  %span.nv _pid
                  = succeed "0" do
                    %span.o =
                  ensure_paths_exist
                  %span.s2 &quot;${_path}&quot;
                  = succeed "file_is_nonempty" do
                    %span.k if
                  %span.s2 &quot;${_path}/${service}.pid&quot;
                  %span.k then
                  %span.k                   %span.nb read
                  \-r _pid &lt;
                  %span.s2 &quot;${_path}/${service}.pid&quot;
                  = succeed "os_is_linux" do
                    %span.k if
                  %span.k then
                  %span.c # Sanity check.
                  %span.k if
                  \! directory_exists
                  %span.s2 &quot;/proc/${pid}&quot;
                  %span.k then
                  %span.k                   %span.nv _pid
                  = succeed "0" do
                    %span.o =
                  rm -f
                  %span.s2 &quot;${_path}/${service}.pid&quot;
                  %span.k fi
                  %span.k fi
                  %span.k fi
                  %span.k                   %span.nv service_pid
                  %span.o =
                  %span.k ${
                  %span.nv _pid
                  %span.k }
                  = succeed "0" do
                    %span.k return
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> load
                conf_d()
              %p
                Load the /etc/conf.d/{service}.conf configuration file into the calling
                environment.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None, unless the configuration file contains any print statements.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_load_conf_d
            %td.code
              .highlight
                %pre
                  service_load_conf_d
                  %span.o ()
                  %span.o {
                  source_files
                  %span.s2 &quot;${confd_path}/${service}.conf&quot;
                  %span.o }
          %tr
            %td.docs
              %h1 Service init functions.
              %h2
                service
                %em> install
                init_d()
              %p Installs the BDSM service module init.d script for the current extension.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging messages informing the end user of what is occurring.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service_install_init_d
            %td.code
              .highlight
                %pre
                  service_install_init_d
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _service
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.nv _version
                  %span.o =
                  %span.s2 &quot;${2:-${package_version}}&quot;
                  variables_must_be_nonempty _service
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${init_scripts_path}&quot;
                  %span.k then
                  = succeed "user_is_root" do
                    %span.k if
                  %span.k then
                  = succeed "ensure_paths_exist" do
                    %span.k                   %span.s2 &quot;/etc/conf.d&quot;
                  %span.s2 &quot;${init_scripts_path}&quot;
                  log
                  %span.s2 &quot;Installing init scripts for ${_service}&quot;
          %tr
            %td.docs
              %p TODO: Install the service init script...
            %td.code
              .highlight
                %pre
                  %span.k> if
                  template_exists
                  %span.s2 &quot;${_service}&quot;
                  %span.k then
                  = succeed "install_template" do
                    %span.k                   %span.s2 &quot;${_service}&quot;
                  to
                  %span.s2 &quot;${init_scripts_path}/${_service}&quot;
                  %span.se \
                  mode 0755
                  %span.k else
          %tr
            %td.docs
              %p Use core srv init.d template
            %td.code
              .highlight
                %pre
                  install_template
                  %span.s2 &quot;init.d&quot;
                  %span.se \
                  from
                  %span.s2 &quot;${extensions_path}/srv/templates&quot;
                  %span.se \
                  to
                  %span.s2 &quot;${init_scripts_path}/${_service}&quot;
                  mode 0755
                  
                  seed_template
                  %span.s2 &quot;${init_scripts_path}/${_service}&quot;
                  %span.se \
                  modules_path
                  %span.s2 &quot;${modules_path}&quot;
                  %span.se \
                  service
                  %span.s2 &quot;${service}&quot;
                  %span.se \
                  service_user
                  %span.s2 &quot;${service_user}&quot;
                  %span.k fi
                  = succeed "service_activate" do
                    %span.k                   %span.s2 &quot;${service}&quot;
                  %span.s2 &quot;${package_version}&quot;
          %tr
            %td.docs
              %p
                TODO: Replace this with install
                %em> template + seed
                template
            %td.code
              .highlight
                %pre
                  log
                  %span.s2 &quot;%s\n&quot;
                  %span.s2 &quot;[ -d \&quot;${prefix_path}/${_service}/active/bin\&quot; ] &amp;&amp; &quot;
                  %span.se \
                  to
                  %span.s2 &quot;/etc/profile.d/${_service}.sh&quot;
                  log
                  %span.s2 &quot;%s\n&quot;
                  %span.s2 &quot;PATH=\&quot;\$PATH:${prefix_path}/${_service}/active/bin\&quot; ; export PATH; &quot;
                  %span.se \
                  append to
                  %span.s2 &quot;/etc/profile.d/${_service}.sh&quot;
                  chmod_files 0755
                  %span.s2 &quot;/etc/profile.d/${_service}.sh&quot;
                  %span.k fi
                  %span.k else
                  = succeed "0" do
                    %span.k return
                  %span.c # No bin/ dir, no need for it to be in the path.
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> init
                path()
              %p Sets the PATH explicitely for purposes of the current service extension.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p Alters the PATH variable.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service_init_path
            %td.code
              .highlight
                %pre
                  service_init_path
                  %span.o ()
                  %span.o {
                  %span.nv PATH
                  %span.o =
                  %span.s2 &quot;${prefix_path}/bin:/bin:/usr/bin:/usr/local/bin:/sbin:/usr/sbin:/usr/local/sbin:${PATH}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> init
                start()
              %p This is the generalized service init start function.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging telling the end user what is happening.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service_init_start
            %td.code
              .highlight
                %pre
                  service_init_start
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;Starting ${service}...&quot;
                  service_init_path
                  %span.nb local
                  %span.nv _result
                  = succeed "0" do
                    %span.o =
                  %span.nv _command
                  %span.o =(
                  %span.s2 &quot;${service_binary}&quot;
                  %span.o )
                  = succeed "array_is_nonempty" do
                    %span.k if
                  service_start_flags
                  %span.k then
                  = succeed "_command+" do
                    %span.k                   %span.o =(
                  %span.s2 &quot;${service_start_flags[@]}&quot;
                  %span.o )
                  %span.k fi
                  = succeed "array_is_nonempty" do
                    %span.k if
                  service_flags
                  %span.k then
                  = succeed "_command+" do
                    %span.k                   %span.o =(
                  %span.s2 &quot;${service_flags[@]}&quot;
                  %span.o )
                  %span.k fi
                  %span.k if
                  %span.o ((
                  %span.nv service_run_as_root_flag
                  %span.o ==
                  1
                  %span.o ))
                  %span.k then
                  %span.k if
                  %span.k ${
                  %span.nv _command
                  %span.p [*]
                  %span.k }
                  %span.k then
                  %span.k                   %span.nb true
                  %span.nb                   %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;${service} failed to start.&quot;
                  %span.k fi
                  %span.k else
                  %span.k if
                  \! user_run_as
                  %span.s2 &quot;${service_user}&quot;
                  %span.s2 &quot;${_command[*]}&quot;
                  %span.k then
                  %span.k                   %span.nb true
                  %span.nb                   %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;${service} failed to start.&quot;
                  %span.k fi
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> init
                stop()
              %p This is the generalized service init stop function.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging telling the end user what is happening.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service_init_stop
            %td.code
              .highlight
                %pre
                  service_init_stop
                  %span.o ()
                  %span.o {
                  service_init_path
                  %span.k if
                  %span.o ((
                  service_pid &gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Stopping ${service}...&quot;
                  %span.k if
                  %span.nb kill
                  \-QUIT
                  %span.s2 &quot;${service_pid}&quot;
                  %span.k then
                  = succeed "rm" do
                    %span.k                   \-f
                  %span.s2 &quot;$service_pid_file&quot;
                  %span.k else
                  %span.k return
                  %span.nv $?
                  %span.k fi
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Service pid has not been set or is zero.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> init
                status()
              %p This is the generalized service init status function.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging telling the end user what is happening.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service_init_status
            %td.code
              .highlight
                %pre
                  service_init_status
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;statusing ${service}...&quot;
                  service_init_path
                  %span.nb local
                  %span.nv _command
                  %span.o =(
                  %span.s2 &quot;${service_binary}&quot;
                  %span.o )
                  = succeed "array_is_nonempty" do
                    %span.k if
                  service_status_flags
                  %span.k then
                  = succeed "_command+" do
                    %span.k                   %span.o =(
                  %span.s2 &quot;${service_status_flags[@]}&quot;
                  %span.o )
                  %span.k fi
                  = succeed "array_is_nonempty" do
                    %span.k if
                  service_flags
                  %span.k then
                  = succeed "_command+" do
                    %span.k                   %span.o =(
                  %span.s2 &quot;${service_flags[@]}&quot;
                  %span.o )
                  %span.k fi
                  = succeed "user_run_as" do
                    %span.k if
                  %span.s2 &quot;${service_user}&quot;
                  %span.s2 &quot;${_command[*]}&quot;
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "touch" do
                    %span.k                   %span.s2 &quot;$service_pid_file&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> init
                reload()
              %p This is the generalized service init reload function.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging telling the end user what is happening.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service_init_reload
            %td.code
              .highlight
                %pre
                  service_init_reload
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;reloading ${service}...&quot;
                  service_init_path
                  %span.nb local
                  %span.nv _command
                  %span.o =(
                  %span.s2 &quot;${service_binary}&quot;
                  %span.o )
                  = succeed "array_is_nonempty" do
                    %span.k if
                  service_reload_flags
                  %span.k then
                  = succeed "_command+" do
                    %span.k                   %span.o =(
                  %span.s2 &quot;${service_reload_flags[@]}&quot;
                  %span.o )
                  %span.k fi
                  = succeed "array_is_nonempty" do
                    %span.k if
                  service_flags
                  %span.k then
                  = succeed "_command+" do
                    %span.k                   %span.o =(
                  %span.s2 &quot;${service_flags[@]}&quot;
                  %span.o )
                  %span.k fi
                  = succeed "user_run_as" do
                    %span.k if
                  %span.s2 &quot;${service_user}&quot;
                  %span.s2 &quot;${_command[*]}&quot;
                  %span.k then
                  = succeed "touch" do
                    %span.k                   %span.s2 &quot;$service_pid_file&quot;
                  %span.k else
                  %span.k return
                  %span.nv $?
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> init
                usage()
              %p This is the generalized service init usage function.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging telling the end user what is happening.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service_init_usage
            %td.code
              .highlight
                %pre
                  service_init_usage
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;Usage:\n\n  $0 {start|stop|restart|status|info|logtail}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> init
                logtail()
              %p This is the generalized service init logtail function.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging telling the end user what is happening.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service_init_logtail
            %td.code
              .highlight
                %pre
                  service_init_logtail
                  %span.o ()
                  %span.o {
          %tr
            %td.docs
              %p TODO: Adjust this to allow for parameter passing.
            %td.code
              .highlight
                %pre
                  %span.nb> exec
                  tail -n 10
                  %span.s2 &quot;${service_log_file}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> init
                info()
              %p This is the generalized service init info function.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Outputs information about the service (version, etc...).
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service_init_info
            %td.code
              .highlight
                %pre
                  service_init_info
                  %span.o ()
                  %span.o {
                  NIY
                  %span.s2 &quot;service_init_info has not yet been implemented for the service module.&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> conf
                d()
              %p Installs the conf.d template for the service, if it exists.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging updates to inform the user what is happening.
              %h3 Environmental effects
              %p
                Once completed a conf.d file should be in place.
                For example /etc/conf.d/redis.conf for the redis service.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_conf_d
            %td.code
              .highlight
                %pre
                  service_conf_d
                  %span.o ()
                  %span.o {
          %tr
            %td.docs
              %p TODO: Install a default conf.d template if extension does not define one.
            %td.code
              .highlight
                %pre
                  %span.k> if
                  template_exists
                  %span.s2 &quot;conf.d&quot;
                  %span.k then
                  = succeed "install_template" do
                    %span.k                   %span.s2 &quot;conf.d.template&quot;
                  to
                  %span.s2 &quot;/etc/conf.d/${service}.conf&quot;
                  %span.se \
                  mode 0644 owner
                  %span.s2 &quot;${service_user}:${service_user}&quot;
                  = succeed "template_exists" do
                    %span.k if
                  %span.s2 &quot;/etc/conf.d/${service}.conf&quot;
                  %span.k then
                  = succeed "seed_template" do
                    %span.k                   %span.s2 &quot;/etc/conf.d/${service}.conf&quot;
                  %span.se \
                  prefix_path
                  %span.s2 &quot;${prefix_path}&quot;
                  %span.se \
                  init_scripts_path
                  %span.s2 &quot;${init_scripts_path}&quot;
                  %span.se \
                  modules_path
                  %span.s2 &quot;${modules_path}&quot;
                  %span.se \
                  data_path
                  %span.s2 &quot;${data_path}&quot;
                  %span.se \
                  confd_path
                  %span.s2 &quot;${confd_path}&quot;
                  %span.se \
                  extension
                  %span.s2 &quot;${service}&quot;
                  %span.se \
                  service
                  %span.s2 &quot;${service}&quot;
                  %span.k fi
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> init
                start()
              %p This is the generalized service init start function.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging telling the end user what is happening.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service_init_action start
            %td.code
              .highlight
                %pre
                  service_init_action
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _action
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  service_load_conf_d
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;${service}_${action}&quot;
                  %span.k then
                  %span.s2 &quot;${service}_${action}&quot;
                  %span.k else
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;${service_actions[*]}&quot;
                  %span.o =
                  *
                  %span.o> [[
                  \:space:
                  %span.o ]]
                  %span.k ${
                  %span.nv action
                  %span.k }
                  = succeed ":space:" do
                    %span.o [[
                  = succeed "*" do
                    %span.o ]]
                  %span.o ]]
                  %span.k then
                  = succeed "service_init_" do
                    %span.k                   %span.k ${
                  %span.nv action
                  %span.k }
                  %span.k else
                  = succeed "service_init_usage" do
                    %span.k                   %span.k fi
                  %span.k fi
                  %span.k return
                  %span.nv $?
                  %span.o }
          %tr
            %td.docs
              %h2
                service
                %em> init
                d()
              %p The main logic for generalized service init.d scripts.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging updates to inform the user what is happening.
              %h3 Environmental effects
              %p May alter the runstate of the service extension.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_init_d
            %td.code
              .highlight
                %pre
                  service_init_d
                  %span.o ()
                  %span.o {
                  enable_backtrace
                  %span.c # Enable backtrace on script error.
                  service_load_conf_d
                  %span.c # Load the configuration file.
          %tr
            %td.docs
              %p Sanity checks go here.
            %td.code
              .highlight
                %pre
                  %span.k> if
                  file_is_executable
                  %span.s2 &quot;${service_binary}&quot;
                  %span.k then
                  = succeed "service_pid" do
                    %span.k                   service_cli
                  %span.c # Parse the script arguments and take action accordingly.
                  service_init_action
                  %span.s2 &quot;${service_action}&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Could not find ${service_binary} or ${service_binary} is not executable.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 service_deactivate()
              %p Deactivates the named service or
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging updates to inform the user what is happening.
              %h3 Environmental effects
              %p Changes the current or named service's init script to be nonexecutable.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_deactivate
            %td.code
              .highlight
                %pre
                  service_deactivate
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _service
                  %span.o =
                  %span.s2 &quot;${1:-&quot;
                  %span.k ${
                  %span.nv service
                  %span.k }
                  %span.s2 &quot;}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_service}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;a service name must be set or passed in in order to deactivate a service.&quot;
                  %span.k fi
                  = succeed "file_exists" do
                    %span.k if
                  %span.s2 &quot;${init_scripts_path}/${_service}&quot;
                  %span.k then
                  = succeed "chmod_files" do
                    %span.k                   0644
                  %span.s2 &quot;${init_scripts_path}/${_service}&quot;
                  = succeed "user_is_root" do
                    %span.k if
                  %span.k then
                  %span.c # Add service to system startup
                  = succeed "command_exists" do
                    %span.k if
                  rc-update
                  %span.k then
                  = succeed "rc-update" do
                    %span.k                   add
                  %span.k ${
                  %span.nv service
                  %span.k }
                  default
                  = succeed "command_exists" do
                    %span.k elif
                  chkconfig
                  %span.k then
                  = succeed "chkconfig" do
                    %span.k                   %span.k ${
                  %span.nv service
                  %span.k }
                  on
                  %span.c #elif command_exists svc
                  %span.c #then
          %tr
            %td.docs
              %p svc ${service} on # TODO: daemontools start on boot
            %td.code
              .highlight
                %pre
                  %span.k else
                  %span.c # Fall back on rc.local to start redis at system startup.
                  %span.k if
                  \! file_contains
                  %span.s2 &quot;/etc/rc.local&quot;
                  %span.s2 &quot;${service} start&quot;
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;${init_scripts_path}/${service} start&quot;
                  %span.se \
                  append to /etc/rc.local
                  %span.k fi
                  %span.k fi
                  %span.k fi
                  %span.k fi
          %tr
            %td.docs
              %p TDOO: hook into system's paths.
            %td.code
              .highlight
                %pre
                  %span.o }
          %tr
            %td.docs
              %h2 service_activate()
              %p Activates the named service or
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p Logging updates to inform the user what is happening.
              %h3 Environmental effects
              %p Changes the current or named service's init script to be nonexecutable.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p No failure conditions currently.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ service=redis
                    user$ service_deactivate
            %td.code
              .highlight
                %pre
                  service_activate
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _service
                  %span.o =
                  %span.s2 &quot;${1:-&quot;
                  %span.k ${
                  %span.nv service
                  %span.k }
                  %span.s2 &quot;}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_service}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;the service name must be set or passed in in order to activate a service.&quot;
                  %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _version
                  %span.o =
                  %span.s2 &quot;${2:-${package_version}}&quot;
                  variables_must_be_nonempty _service _version
                  = succeed "symlink_exists" do
                    %span.k if
                  %span.s2 &quot;${service_db_path}/active&quot;
                  %span.k then
                  = succeed "service_deactivate" do
                    %span.k                   %span.s2 &quot;${_service}&quot;
                  %span.k fi
                  %span.k if
                  \! directory_exists
                  %span.s2 &quot;${service_db_path}/${_version}&quot;
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Skipping activation of ${_service} ${_version} as '${install_path}' does not exist.&quot;
                  %span.k fi
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;Activating service ${_service} version ${_version}&quot;
                  link --force
                  %span.s2 &quot;${service_db_path}/${_version}&quot;
                  to
                  %span.s2 &quot;${service_db_path}/active&quot;
                  = succeed "file_exists" do
                    %span.k if
                  %span.s2 &quot;${init_scripts_path}/${service}&quot;
                  %span.k then
                  = succeed "chmod_files" do
                    %span.k                   0755
                  %span.s2 &quot;${init_scripts_path}/${service}&quot;
                  = succeed "os_is_linux" do
                    %span.k if
                  %span.k then
                  = succeed "user_is_root" do
                    %span.k if
                  %span.k then
                  %span.c # Add service to system startup
                  = succeed "command_exists" do
                    %span.k if
                  rc-update
                  %span.k then
                  = succeed "rc-update" do
                    %span.k                   remove
                  %span.k ${
                  %span.nv service
                  %span.k }
                  default
                  = succeed "command_exists" do
                    %span.k elif
                  chkconfig
                  %span.k then
                  = succeed "chkconfig" do
                    %span.k                   %span.k ${
                  %span.nv service
                  %span.k }
                  off
                  %span.c #elif command_exists svc
                  %span.c #then
          %tr
            %td.docs
              %p
                svc ${service} off
                TODO: daemontools remove start on boot
            %td.code
              .highlight
                %pre
                  %span.k else
                  %span.c # Fall back on rc.local to start redis at system startup.
                  %span.k if
                  \! file_contains
                  %span.s2 &quot;/etc/rc.local&quot;
                  %span.s2 &quot;${service} start&quot;
                  %span.k then
                  = succeed "sed" do
                    %span.k                   \-i -e
                  %span.s2 &quot;d#${init_scripts_path}/${service} start#&quot;
                  \/etc/rc.local
                  %span.k fi
                  %span.k fi
                  %span.k fi
                  = succeed "os_is_darwin" do
                    %span.k elif
                  %span.k then
                  %span.k                   %span.nb true
                  %span.c # TODO: launchctl
                  %span.k else
                  %span.c # ::shrug::
                  %span.k if
                  \! file_contains
                  %span.s2 &quot;/etc/rc.local&quot;
                  %span.s2 &quot;${service} start&quot;
                  %span.k then
                  = succeed "sed" do
                    %span.k                   \-i -e
                  %span.s2 &quot;d#${init_scripts_path}/${service} start#&quot;
                  \/etc/rc.local
                  %span.k fi
                  %span.k fi
                  %span.k fi
                  %span.o }
                  service_status
                  %span.o ()
                  %span.o {
                  log
                  %span.s2 &quot;${service}:&quot;
                  %span.k if
                  %span.o [[
                  \-s
                  %span.s2 &quot;${service_pid_file}&quot;
                  %span.o ]]
                  %span.o &amp;&amp;
                  %span.o ((
                  = succeed "head" do
                    %span.k $(
                  \-1
                  %span.k ${
                  %span.nv service_pid_file
                  %span.k })
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  %span.k                   %span.nb local
                  %span.nv pid
                  %span.o =
                  = succeed "head" do
                    %span.k $(
                  \-1
                  %span.k ${
                  %span.nv service_pid_file
                  %span.k })
                  %span.nb local
                  %span.nv ps
                  %span.o =
                  = succeed "ps" do
                    %span.k $(
                  \-p
                  %span.k ${
                  %span.nv pid
                  %span.k }
                  \-ostate,sgi_rss,vsize | tail -1
                  %span.k )
                  log
                  %span.s2 &quot;  status: running&quot;
                  log
                  %span.s2 &quot;  version: ${service_version}&quot;
                  log
                  %span.s2 &quot;  process: &quot;
                  log
                  %span.s2 &quot;    pid: ${pid}&quot;
                  = succeed "os_is_linux" do
                    %span.k if
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;    parent_pid: $(awk  '/^PPid:/{print $2}' /proc/${pid}/status)&quot;
                  log
                  %span.s2 &quot;    state: $(printf &quot;
                  %span.nv $ps
                  %span.s2 &quot; | awk '{print $1}')&quot;
                  log
                  %span.s2 &quot;    rss: $(printf &quot;
                  %span.nv $ps
                  %span.s2 &quot; | awk '{print $2}')&quot;
                  log
                  %span.s2 &quot;    vsz: $(printf &quot;
                  %span.nv $ps
                  %span.s2 &quot; | awk '{print $3}')&quot;
                  %span.k fi
                  = succeed "command_exists" do
                    %span.k if
                  lsof
                  %span.k then
                  %span.k                   %span.nb local
                  %span.nv cwd
                  %span.o =
                  %span.nv binary
                  %span.o =
                  %span.nv libraries
                  %span.o =()
                  %span.nv tcp_ports
                  %span.o =()
                  %span.nv udp_ports
                  %span.o =()
                  %span.nv sockets
                  %span.o =()
                  %span.nv logs
                  %span.o =()
                  string
                  %span.k while
                  %span.nb read
                  \-r line
                  %span.k do
                  %span.k case
                  %span.s2 &quot;$line&quot;
                  in
                  = succeed "*" do
                    %span.o (
                  = succeed ":space:" do
                    %span.o [[
                  = succeed "cwd" do
                    %span.o ]]
                  = succeed ":space:" do
                    %span.o [[
                  = succeed "*" do
                    %span.o ]]
                  %span.o )
                  %span.nv cwd
                  %span.o =
                  %span.s2 &quot;${line##* }&quot;
                  ;;
                  = succeed "*" do
                    %span.o (
                  = succeed ":space:" do
                    %span.o [[
                  = succeed "txt" do
                    %span.o ]]
                  = succeed ":space:" do
                    %span.o [[
                  = succeed "*" do
                    %span.o ]]
                  %span.o )
                  %span.nv binary
                  %span.o =
                  %span.s2 &quot;${line##* }&quot;
                  ;;
                  = succeed "*/lib/*" do
                    %span.o (
                  %span.o )
                  %span.nv string
                  %span.o =
                  %span.s2 &quot;${line%% (*}&quot;
                  libraries+
                  %span.o =(
                  %span.s2 &quot;${string##* }&quot;
                  %span.o )
                  ;;
                  = succeed "*.log*" do
                    %span.o (
                  %span.o )
                  logs+
                  %span.o =(
                  %span.s2 &quot;${line##* }&quot;
                  %span.o )
                  ;;
                  = succeed "*.sock*" do
                    %span.o (
                  %span.o )
                  sockets+
                  %span.o =(
                  %span.s2 &quot;${line##* }&quot;
                  %span.o )
                  ;;
                  = succeed "*TCP*" do
                    %span.o (
                  %span.o )
                  %span.nv string
                  %span.o =
                  %span.s2 &quot;${line%% (*}&quot;
                  tcp_ports+
                  %span.o =(
                  %span.s2 &quot;${string##* }&quot;
                  %span.o )
                  ;;
                  = succeed "*" do
                    %span.o (
                  %span.o )
                  %span.nb true
                  %span.c # ignore
                  ;;
                  %span.k esac
                  %span.k done
                  \&lt; &lt;
                  %span.o> (
                  lsof -U -p
                  %span.k ${
                  %span.nv pid
                  %span.k }
                  %span.o )
                  log
                  %span.s2 &quot;    cwd: ${cwd}&quot;
                  log
                  %span.s2 &quot;    binary: ${binary}&quot;
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv logs
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;    logs:&quot;
                  array_sort_asc logs
                  array_unique logs
                  = succeed "log" do
                    %span.k for
                  in
                  %span.s2 &quot;${logs[@]}&quot;
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot;      - %s\n&quot;
                  %span.s2 &quot;${log}&quot;
                  %span.k done
                  %span.k fi
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv libraries
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;    libraries:&quot;
                  array_sort_asc libraries
                  array_unique libraries
                  = succeed "library" do
                    %span.k for
                  in
                  %span.s2 &quot;${libraries[@]}&quot;
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot;      - %s\n&quot;
                  %span.s2 &quot;${library}&quot;
                  %span.k done
                  %span.k fi
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv tcp_ports
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;    tcp_ports:&quot;
                  array_sort_asc tcp_ports
                  array_unique tcp_ports
                  = succeed "tcp_port" do
                    %span.k for
                  in
                  %span.s2 &quot;${tcp_ports[@]}&quot;
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot;      - %s\n&quot;
                  %span.s2 &quot;${tcp_port}&quot;
                  %span.k done
                  %span.k fi
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv sockets
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;    sockets:&quot;
                  array_sort_asc sockets
                  array_unique sockets
                  = succeed "socket" do
                    %span.k for
                  in
                  %span.s2 &quot;${sockets[@]}&quot;
                  %span.k do
                  %span.k                   %span.nb printf
                  %span.s2 &quot;      - %s\n&quot;
                  %span.s2 &quot;${socket}&quot;
                  %span.k done
                  %span.k fi
                  %span.k fi
                  %span.k else
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;  status: not running&quot;
                  %span.k fi
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
!!!
%html
  %head
    %meta{:content => "text/html;charset=utf-8", "http-eqiv" => "content-type"}/
    %title dsl
    %link{:href => "http://jashkenas.github.com/docco/resources/docco.css", :rel => "stylesheet"}/
  %body
    #container
      #background
      %table{:cellpadding => "0", :cellspacing => "0"}
        %thead
          %tr
            %th.docs
              %h1 dsl
            %th.code
        %tbody
          %tr
            %td.docs
              %h1 Filesystem Module
            %td.code
              .highlight
                %pre
                  %span.c #!/usr/bin/env bash
          %tr
            %td.docs
              %h2 source_files
              %p Safely source files only if they exists and are nonempty.
              %h3 Input Parameters
              %p One or more files.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p Nonempty files given will be sourced into the calling environment.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no files are given to sources.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ source_files "$HOME/.dotfiles/scripts/functions"
            %td.code
              .highlight
                %pre
                  source_files
                  %span.o ()
                  %span.o {
                  = succeed "_file" do
                    %span.nb local
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  %span.k                   %span.nv _file
                  %span.o =
                  %span.k ${
                  %span.nv _file
                  %span.p /\~\//
                  %span.nv $HOME
                  %span.p \/
                  %span.k }
                  %span.c # Expand ~/ to full value of $HOME
                  = succeed "file_is_nonempty" do
                    %span.k if
                  %span.s2 &quot;${_file}&quot;
                  %span.k then
                  %span.k                   %span.nb source
                  %span.s2 &quot;${_file}&quot;
          %tr
            %td.docs
              %p
                TODO: figure out how to see if 'source' itself failed or simply
                returning nonzero code.
                || fail "Failed to source ${_file}."
            %td.code
              .highlight
                %pre
                  %span.k fi
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot source files as no files were given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 nonempty_files
              %p Outputs a subset of the named files that are nonempty.
              %h3 Input Parameters
              %p One or more files.
              %h3 Stream Outputs
              %p
                Each nonempty filename parameter will be printed to STDOUT of the calling
                environment.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no file names are given as arguments.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ nonempty_files a $HOME/.bdmsrc c
                    /Users/wayneeseguin/.bdsmrc
            %td.code
              .highlight
                %pre
                  nonempty_files
                  %span.o ()
                  %span.o {
                  = succeed "_file" do
                    %span.nb local
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  = succeed "file_is_nonempty" do
                    %span.k if
                  %span.s2 &quot;${_file}&quot;
                  %span.k then
                  %span.k                   %span.nb printf
                  %span.s2 &quot;${_file}\n&quot;
                  %span.k fi
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot return nonempty files as no files were given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                ensure
                %em> paths
                exist
              %p
                Iterates over the list of given paths, creates the directory if it
                does not exist.
              %h3 Input Parameters
              %p A list of paths to create if missing.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p Paths that were given but do not exist will be created.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no paths were given to.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ ls -a
                    . ..
                    user$ ensure_paths_exist a b c
                    user$ ls -a
                    . .. a b c
            %td.code
              .highlight
                %pre
                  ensure_paths_exist
                  %span.o ()
                  %span.o {
                  = succeed "_path" do
                    %span.nb local
                  %span.nv _paths
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _paths
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_path" do
                    %span.k for
                  in
                  %span.s2 &quot;${_paths[@]}&quot;
                  %span.k do
                  %span.k if
                  \! directory_exists
                  %span.s2 &quot;${_path}&quot;
                  %span.k then
                  = succeed "mkdir" do
                    %span.k                   \-p
                  %span.s2 &quot;${_path}&quot;
                  %span.k fi
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot ensure paths exist as no paths were given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 remove_files
              %p Removes the given files, if they exist.
              %h3 Input Parameters
              %p One or more file names/paths.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                The named files will no longer exist on the system, if they existed to begin
                with.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no files were named.
                Fails if a named file is a directory.
                Fails if a named file exists but is not a file.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ touch a b c
                    user$ ls -a
                    . .. a b c
                    user$ remove_files a b c
                    user$ ls
                    . ..
            %td.code
              .highlight
                %pre
                  remove_files
                  %span.o ()
                  %span.o {
                  = succeed "_file" do
                    %span.nb local
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  %span.k if
                  %span.o [[
                  \-f
                  %span.s2 &quot;${_file}&quot;
                  %span.o ||
                  \-L
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "rm" do
                    %span.k                   \-f
                  %span.s2 &quot;${_file}&quot;
                  %span.k elif
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot remove the file ${_file} as it is a directory.&quot;
                  %span.k elif
                  %span.o [[
                  \-e
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Unknown filesystem entity type located at ${_file}, cannot remove.&quot;
                  %span.k else
                  %span.k                   %span.nb true
                  %span.c # already gone
                  %span.k fi
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot remove files as no files were given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 remove
              %p Removes the given entries, if they exist.
              %h3 Input Parameters
              %p One or more file, directory or symlink names/paths.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                The named files will no longer exist on the system, if they existed to begin
                with.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no files were named.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ touch a
                    user$ mkdir b
                    user$ ln -s b c
                    user$ ls -a
                    . .. a b c
                    user$ remove a b c
                    user$ ls
                    . ..
            %td.code
              .highlight
                %pre
                  remove
                  %span.o ()
                  %span.o {
                  = succeed "_file" do
                    %span.nb local
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  %span.k if
                  %span.o [[
                  \-f
                  %span.s2 &quot;${_file}&quot;
                  %span.o ||
                  \-L
                  %span.s2 &quot;${_file}&quot;
                  %span.o ||
                  \-d
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "rm" do
                    %span.k                   \-rf
                  %span.s2 &quot;${_file}&quot;
                  %span.k elif
                  %span.o [[
                  \-e
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Unhandled filesystem entity type located at ${_file}, cannot remove. (File, link and directory types are handled)&quot;
                  %span.k fi
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot remove files as no files were given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 remove_paths
              %p Function Description
              %h3 Input Parameters
              %p Positional Parameter listing and descriptions.
              %h3 Stream Outputs
              %p What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
              %h3 Environmental effects
              %p What, if any, environmental side effects this function causes. 'None.' for none.
              %h3 Return Codes
              %p
                0 if ...
                1 if ...
              %h3 Failure Scenarios
              %p Fails if ...
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ {{ setup the scenario }}
                    user$ function_name {{ parameters }}
                    user$ {{ demonstrate the results}}
            %td.code
              .highlight
                %pre
                  remove_paths
                  %span.o ()
                  %span.o {
                  = succeed "_path" do
                    %span.nb local
                  %span.nv _paths
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _paths
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_path" do
                    %span.k for
                  in
                  %span.s2 &quot;${_paths[@]}&quot;
                  %span.k do
                  %span.k if
                  %span.o [[
                  \-f
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot remove the path '${_path}' as it is a file.&quot;
                  %span.k elif
                  %span.o [[
                  \-L
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "rm" do
                    %span.k                   \-f
                  %span.s2 &quot;${_path}&quot;
                  %span.k elif
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "rm" do
                    %span.k                   \-rf
                  %span.s2 &quot;${_path}&quot;
                  %span.k elif
                  %span.o [[
                  \-e
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Unknown filesystem entity type at ${_path}, cannot remove.&quot;
                  %span.k else
                  %span.k                   %span.nb true
                  %span.c # already gone
                  %span.k fi
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot remove paths as no paths were given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                ensure
                %em> files
                exist
              %p
                Iterates over the list of given files, creates the directory if it
                does not exist.
              %h3 Input Parameters
              %p A list of files to create if missing.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p files that were given but do not exist will be created.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p Fails if no files were given to.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ ls -a
                    . ..
                    user$ ensure_files_exist a b c
                    user$ ls -a
                    . .. a b c
            %td.code
              .highlight
                %pre
                  ensure_files_exist
                  %span.o ()
                  %span.o {
                  = succeed "_file" do
                    %span.nb local
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  _path
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  %span.k                   %span.nv _path
                  %span.o =
                  %span.s2 &quot;${_file%\/*}&quot;
                  %span.k if
                  %span.o [[
                  \! -d
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "mkdir" do
                    %span.k                   \-p
                  %span.s2 &quot;${_path}&quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  \! -e
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "touch" do
                    %span.k                   %span.s2 &quot;${_file}&quot;
                  %span.k fi
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot ensure files exist as no files were given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                ensure
                %em> files
                are_executable
              %p Sets the executable bits on a file if it is not executable.
              %h3 Input Parameters
              %p One or more file name/paths
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p Files that were given and not executable will have their execute bits set.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if no files were given as parameters.
                Fails if one of the files given was a directory.
                Fails if one of the files given does not exist.
                Fails if one of the files paths does not exist.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ ensure_files_are_executable /etc/rc.d/postgresql
              %p
                TODO: change this to be a  fail function if one is not
                make this into make
                %em> files
                executable or some such
            %td.code
              .highlight
                %pre
                  ensure_files_are_executable
                  %span.o ()
                  %span.o {
                  = succeed "_file" do
                    %span.nb local
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  _path
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot make the file '${_file}' executable as it is a directory.&quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  \! -f
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot make the file '${_file}' executable as the file does not exist.&quot;
                  %span.k fi
                  %span.k                   %span.nv _path
                  %span.o =
                  %span.s2 &quot;${_file%\/*}&quot;
                  %span.k if
                  \!
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_path}&quot;
                  %span.o &amp;&amp;
                  \! -d
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot make the file '${_file} executable as '${_path}' does not even exist.&quot;
                  %span.k fi
                  = succeed "chmod" do
                    %span.k                   +x
                  %span.s2 &quot;${_file}&quot;
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot ensure files are executable as no files were given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 link
              %p Create a symlink from source to target.
              %h3 Input Parameters
              %p
                First parameter is the source
                Second parameter is the target
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p Symlink is created if no failure conditions are triggered.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if target exists and is a file.
                Fails if target exists and is a directory.
              %h3 Usage Examples
              %p The following usages are equivalent
              %pre
                %code
                  :preserve
                    user$ link from /home/user/.vim/vimrc to /home/user/.vimrc
                    user$ link /home/user/.vim/vimrc to /home/user/.vimrc
                    user$ link /home/user/.vim/vimrc /home/user/.vimrc
            %td.code
              .highlight
                %pre
                  link
                  %span.o ()
                  %span.o {
                  = succeed "token" do
                    %span.nb local
                  _source _target
                  %span.nv _force_flag
                  = succeed "0" do
                    %span.o =
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${token}&quot;
                  in
                  to
                  %span.o )
                  %span.nv _target
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  from
                  %span.o )
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  \--force
                  %span.o )
                  %span.nv _force_flag
                  = succeed "1" do
                    %span.o =
                  ;;
                  *
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_source}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _source
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.k elif
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _target
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.k fi
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o ((
                  %span.nv _force_flag
                  %span.o ==
                  1
                  %span.o ))
                  %span.k then
                  = succeed "remove" do
                    %span.k                   %span.s2 &quot;${_target}&quot;
                  %span.k fi
          %tr
            %td.docs
              %p TODO: What should we do if files already exist?
            %td.code
              .highlight
                %pre
                  %span.k if
                  %span.o [[
                  \-f
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot link ${_source} to ${_target} exists and is a file!&quot;
                  %span.k elif
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot link ${_source} to ${_target} exists and is a directory&quot;
                  %span.k else
                  = succeed "ensure_paths_exist" do
                    %span.k                   %span.s2 &quot;${_target%\/*}&quot;
                  ln -fs
                  %span.s2 &quot;${_source}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 move_directory
              %p
                Moves a directory from one location to another.
                (This is also used to rename a directory.)
              %h3 Input Parameters
              %p
                The first parameter is the source directory name
                The second parameter is the target directory name
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p If successful, a directory is renamed (moved).
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if the source directory is not specified.
                Fails if the target directory is not specified.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ move_directory "freetds-0.91rc"* to "freetds-0.91"
            %td.code
              .highlight
                %pre
                  move_directory
                  %span.o ()
                  %span.o {
                  = succeed "_source" do
                    %span.nb local
                  _target _mode _owner
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  ;
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  ;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${token}&quot;
                  in
                  to
                  %span.o )
                  %span.nv _target
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  
                  from
                  %span.o )
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  
                  mode
                  %span.o )
                  %span.nv _mode
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  
                  owner
                  %span.o )
                  %span.nv _owner
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  
                  *
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_source}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _source
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.k elif
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _target
                  %span.o =
                  %span.s2 &quot;$token&quot;
          %tr
            %td.docs
              %p When we have a target we are done.
            %td.code
              .highlight
                %pre
                  %span.nb break
                  %span.nb                   %span.k fi
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_source}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot move file as the source and target must be specified. &quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot move file as the source and target must be specified. &quot;
                  %span.k fi
                  = succeed "mv" do
                    %span.k                   %span.s2 &quot;${_source}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_mode:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "chmod" do
                    %span.k                   \-R
                  %span.s2 &quot;${_mode}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_owner:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "chown" do
                    %span.k                   \-R
                  %span.s2 &quot;${_owner}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 move_file
              %p
                Moves a file from one location to another.
                (This is also used to rename a file.)
              %h3 Input Parameters
              %p
                The first parameter is the source file name
                The second parameter is the target file name
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p If successful, a file is renamed (moved).
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if the source file is not specified.
                Fails if the target file is not specified.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ move_file "$HOME/.bashrc" to "$HOME/.bashrc.orig"
            %td.code
              .highlight
                %pre
                  move_file
                  %span.o ()
                  %span.o {
                  = succeed "_source" do
                    %span.nb local
                  _target _mode _owner
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  ;
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  ;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${token}&quot;
                  in
                  to
                  %span.o )
                  %span.nv _target
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  from
                  %span.o )
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  mode
                  %span.o )
                  %span.nv _mode
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  owner
                  %span.o )
                  %span.nv _owner
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  
                  *
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_source}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _source
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.k elif
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _target
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.nb break
                  %span.nb                   %span.k fi
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_source}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot move file as the source and target must be specified. &quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot move file as the source and target must be specified. &quot;
                  %span.k fi
                  = succeed "mv" do
                    %span.k                   %span.s2 &quot;${_source}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_mode:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "chmod" do
                    %span.k                   %span.s2 &quot;${_mode}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_owner:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "chown" do
                    %span.k                   %span.s2 &quot;${_owner}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 copy_file
              %p
                Copys a file from one location to another.
                (This is also used to rename a file.)
              %h3 Input Parameters
              %p
                The first parameter is the source file name
                The second parameter is the target file name
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p If successful, a file is renamed (copyd).
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if the source file is not specified.
                Fails if the target file is not specified.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ copy_file "$HOME/.bashrc" to "$HOME/.bashrc.orig"
            %td.code
              .highlight
                %pre
                  copy_file
                  %span.o ()
                  %span.o {
                  = succeed "_source" do
                    %span.nb local
                  _target
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  ;
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${token}&quot;
                  in
                  to
                  %span.o )
                  %span.nv _target
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  from
                  %span.o )
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  mode
                  %span.o )
                  %span.nv _mode
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  owner
                  %span.o )
                  %span.nv _owner
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  *
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_source:-}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _source
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.nb shift
                  %span.nb                   %span.k elif
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_target:-}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _target
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.nb break
                  %span.nb                   %span.k fi
                  ;;
                  %span.k esac
                  %span.k done
                  = succeed "cp" do
                    %span.k                   %span.s2 &quot;${_source}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_mode:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "chmod" do
                    %span.k                   %span.s2 &quot;${_mode}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k fi
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_owner:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "chown" do
                    %span.k                   %span.s2 &quot;${_owner}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                copy
                %em> files
                to
              %p depreciated, please use copy_files with the 'to' specifier instead
            %td.code
              .highlight
                %pre
                  copy_files_to
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _file
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Path was not given as the first parameter.&quot;
                  %span.k else
                  %span.k                   %span.nb shift
                  %span.nb                   %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;No files were given in order to copy them into ${_path}.&quot;
                  %span.k fi
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;copy_files_to is depreciated, please use copy_files with the 'to' specifier instead&quot;
                  ensure_paths_exist
                  %span.s2 &quot;${_path}&quot;
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  = succeed "file_is_missing" do
                    %span.k if
                  %span.s2 &quot;${_file}&quot;
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot copy file ${_file} to ${_path} as the file does not exist.&quot;
                  %span.k else
                  = succeed "cp" do
                    %span.k                   %span.s2 &quot;${_file}&quot;
                  %span.s2 &quot;${_path}/${_file}&quot;
                  %span.k fi
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 copy_files
              %p Copys a given list of files into the named path.
              %h3 Input Parameters
              %p
                The first parameter is the path to copy the files into.
                Remaining parameters are the file name/path list.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p If successful, all named files are copied into the target path.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if no target path is given.
                Fails if no files are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ copy_files "$HOME/.bashrc" "$HOME/.bash_profile" \
                            to "$HOME/backup"
            %td.code
              .highlight
                %pre
                  copy_files
                  %span.o ()
                  %span.o {
                  = succeed "_source" do
                    %span.nb local
                  _target _file
                  %span.nv _force_flag
                  = succeed "0" do
                    %span.o =
                  %span.nv _files
                  %span.o =()
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${token}&quot;
                  in
                  to
                  %span.o )
                  %span.nv _target
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  from
                  %span.o )
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  \--force
                  %span.o )
                  %span.nv _force_flag
                  = succeed "1" do
                    %span.o =
                  ;;
                  
                  *
                  %span.o )
                  _files+
                  %span.o =(
                  %span.s2 &quot;${token}&quot;
                  %span.o )
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot copy files as no target path was given (eg. copy_files ... to {path}).&quot;
                  %span.k fi
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot copy files as no files were given to copy.&quot;
                  %span.k fi
                  = succeed "ensure_paths_exist" do
                    %span.k                   %span.s2 &quot;${_target}&quot;
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  = succeed "file_is_missing" do
                    %span.k if
                  %span.s2 &quot;${_file}&quot;
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot copy file ${_file} to ${_target} as the file does not exist.&quot;
                  %span.k else
                  %span.k if
                  %span.o ((
                  %span.nv _force_flag
                  %span.o ==
                  1
                  %span.o ))
                  %span.k then
                  = succeed "cp" do
                    %span.k                   \-f
                  %span.s2 &quot;${_file}&quot;
                  %span.s2 &quot;${_target}/${_file//*\/}&quot;
                  %span.k else
                  = succeed "cp" do
                    %span.k                   %span.s2 &quot;${_file}&quot;
                  %span.s2 &quot;${_target}/${_file//*\/}&quot;
                  %span.k fi
                  %span.k fi
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2
                copy
                %em> directories
                to
              %p Copys a given list of directories into the named path.
              %h3 Input Parameters
              %p
                The first parameter is the path to copy the directorys into.
                Remaining parameters are the directory name/path list.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p If successful, all named directories are copied into the target path.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if no target path is given.
                Fails if no directories are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ copy_directories_to "$HOME/backup/" "$HOME/bin" "$HOME/projects"
            %td.code
              .highlight
                %pre
                  copy_directories_to
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _directory
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Path was not given as the first parameter.&quot;
                  %span.k else
                  %span.k                   %span.nb shift
                  %span.nb                   %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _directories
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _directories
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;No directories were given in order to copy them into ${_path}.&quot;
                  %span.k fi
                  = succeed "ensure_paths_exist" do
                    %span.k                   %span.s2 &quot;${_path}&quot;
                  = succeed "_directory" do
                    %span.k for
                  in
                  %span.s2 &quot;${_directories[@]}&quot;
                  %span.k do
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${_directory}&quot;
                  %span.k then
                  = succeed "cp" do
                    %span.k                   \-Rf
                  %span.s2 &quot;${_directory}&quot;
                  %span.s2 &quot;${_path}/&quot;
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot copy directory ${_directory} to ${_path} as the directory '${_directory}' does not exist (in '$PWD').&quot;
                  %span.k fi
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 copy_directories to
              %p Copys a given list of directories into the named path.
              %h3 Input Parameters
              %p
                The first parameter is the path to copy the directorys into.
                Remaining parameters are the directory name/path list.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p If successful, all named directories are copied into the target path.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if no target path is given.
                Fails if no directories are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ copy_directories to "$HOME/backup/" "$HOME/bin" "$HOME/projects"
            %td.code
              .highlight
                %pre
                  copy_directories
                  %span.o ()
                  %span.o {
                  = succeed "_source" do
                    %span.nb local
                  _target _directory
                  %span.nv _force_flag
                  = succeed "0" do
                    %span.o =
                  %span.nv _directories
                  %span.o =()
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${token}&quot;
                  in
                  to
                  %span.o )
                  %span.nv _target
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  from
                  %span.o )
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  \--force
                  %span.o )
                  %span.nv _force_flag
                  = succeed "1" do
                    %span.o =
                  ;;
                  
                  *
                  %span.o )
                  _directories+
                  %span.o =(
                  %span.s2 &quot;${token}&quot;
                  %span.o )
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot copy directories as no target path was given (eg. copy_directories ... to {path}).&quot;
                  %span.k fi
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _directories
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot copy directories as no directories were given to copy.&quot;
                  %span.k fi
                  = succeed "ensure_paths_exist" do
                    %span.k                   %span.s2 &quot;${_target}&quot;
                  = succeed "_directory" do
                    %span.k for
                  in
                  %span.s2 &quot;${_directories[@]}&quot;
                  %span.k do
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${_directory}&quot;
                  %span.k then
                  = succeed "cp" do
                    %span.k                   \-Rf
                  %span.s2 &quot;${_directory}&quot;
                  %span.s2 &quot;${_target}/&quot;
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot copy directory ${_directory} to ${_target} as the directory '${_directory}' does not exist (in '$PWD').&quot;
                  %span.k fi
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 copy_directory
              %p
                Copys a directory from one location to another.
                (This is also used to rename a directory.)
              %h3 Input Parameters
              %p
                The first parameter is the source directory name
                The second parameter is the target directory name
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p If successful, a directory is renamed (copyd).
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if the source directory is not specified.
                Fails if the target directory is not specified.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ copy_directory "freetds-0.91rc"* to "freetds-0.91"
            %td.code
              .highlight
                %pre
                  copy_directory
                  %span.o ()
                  %span.o {
                  = succeed "_source" do
                    %span.nb local
                  _target
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${token}&quot;
                  in
                  to
                  %span.o )
                  %span.nv _target
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  from
                  %span.o )
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  *
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_source}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _source
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.nb shift
                  %span.nb                   %span.k elif
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _target
                  %span.o =
                  %span.s2 &quot;$token&quot;
                  %span.nb break
                  %span.nb                   %span.k fi
                  ;;
                  %span.k esac
                  %span.k done
                  = succeed "cp" do
                    %span.k                   \-Rf
                  %span.s2 &quot;${_source}&quot;
                  %span.s2 &quot;${_target}&quot;
                  %span.o }
          %tr
            %td.docs
              %h2
                move
                %em> files
                to
              %p Moves a given list of files into the named path.
              %h3 Input Parameters
              %p
                The first parameter is the path to move the files into.
                Remaining parameters are the file name/path list.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p If successful, all named files are copied into the target path.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if no target path is given.
                Fails if no files are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ move_files_to "$HOME/backup" "$HOME/.bashrc" "$HOME/.bash_profile"
            %td.code
              .highlight
                %pre
                  move_files_to
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _file
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Path was not given as the first parameter.&quot;
                  %span.k else
                  %span.k                   %span.nb shift
                  %span.nb                   %span.k fi
                  = succeed "log" do
                    %span.k                   %span.s2 &quot;DEPRECIATED, use 'move_files ... to _path' instead&quot;
                  %span.nb local
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;No files given in order to chmod ${_permissions} them.&quot;
                  %span.k fi
                  = succeed "ensure_paths_exist" do
                    %span.k                   %span.s2 &quot;${_path}&quot;
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  = succeed "file_exists" do
                    %span.k if
                  %span.s2 &quot;${_file}&quot;
                  %span.k then
                  = succeed "mv" do
                    %span.k                   %span.s2 &quot;${_file}&quot;
                  %span.s2 &quot;${_path}/${_file}&quot;
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot move file ${_file} to ${_path} as the file does not exist.&quot;
                  %span.k fi
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 move_files
              %p Moves a given list of files into the named path.
              %h3 Input Parameters
              %p
                Parameters are file name/path for one or more files
                Target directory is specified as 'to {{path}}'
                Optional source directory is specified as 'from {{path}}'
                Optional force flag '--force' may be specified
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p If successful, all named files are copied into the target path.
              %h3 Return Codes
              %p 0 for success.
              %h3 Failure Scenarios
              %p
                Fails if no target path is given.
                Fails if no files are given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$
              %p Alternatively,
              %pre
                %code
                  :preserve
                    user$ move_files ".bashrc" ".bash_profile" from "$HOME" to "$HOME/backup"
            %td.code
              .highlight
                %pre
                  move_files
                  %span.o ()
                  %span.o {
                  = succeed "_source" do
                    %span.nb local
                  _target _file
                  %span.nv _force_flag
                  = succeed "0" do
                    %span.o =
                  %span.nv _files
                  %span.o =()
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${token}&quot;
                  in
                  to
                  %span.o )
                  %span.nv _target
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  from
                  %span.o )
                  %span.nv _source
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  \--force
                  %span.o )
                  %span.nv _force_flag
                  = succeed "1" do
                    %span.o =
                  ;;
                  
                  *
                  %span.o )
                  _files+
                  %span.o =(
                  %span.s2 &quot;${token}&quot;
                  %span.o )
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_target}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_source}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _file
                  %span.o =
                  %span.s2 &quot;${_source}/${_file}&quot;
                  %span.k fi
                  = succeed "file_exists" do
                    %span.k if
                  %span.s2 &quot;${_file}&quot;
                  %span.k then
                  %span.k if
                  %span.o ((
                  %span.nv _force_flag
                  %span.o ==
                  1
                  %span.o ))
                  %span.k then
                  = succeed "mv" do
                    %span.k                   \-f
                  %span.s2 &quot;${_file}&quot;
                  %span.s2 &quot;${_target}/${_file//*\/}&quot;
                  %span.k else
                  = succeed "mv" do
                    %span.k                   %span.s2 &quot;${_file}&quot;
                  %span.s2 &quot;${_target}/${_file//*\/}&quot;
                  %span.k fi
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot move file ${_file} to ${_path} as the file does not exist.&quot;
                  %span.k fi
                  %span.k done
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot move files to '${_target}' as the directory does not exist&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot move files as no files were given to move.&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot move files as no target path was given (eg. move_files ... to {path}).&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 chown_files
              %p Change ownership of a list of files.
              %h3 Input Parameters
              %p
                First parameter is the new owner[:group] of the files.
                Remaining parameters are the file names/paths.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no new owner[:group] was specified.
                Fails if no list of files was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ chown_files $USER "$HOME/.bashrc" "$HOME/.bash_profile"
            %td.code
              .highlight
                %pre
                  chown_files
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _identity
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _file
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_identity}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;user[:group] not given as the first parameter.&quot;
                  %span.k else
                  %span.k                   %span.nb shift
                  %span.nb                   %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;No paths given to chmod ${_permissions}.&quot;
                  %span.k fi
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  = succeed "file_exists" do
                    %span.k if
                  %span.s2 &quot;${_file}&quot;
                  %span.k then
                  = succeed "chown" do
                    %span.k                   \-R
                  %span.k ${
                  %span.nv _identity
                  %span.k }
                  %span.s2 &quot;${_file}&quot;
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot chown file ${_file} to ${_identity} as the file does not exist.&quot;
                  %span.k fi
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 chown_paths
              %p Change ownership of a list of paths.
              %h3 Input Parameters
              %p
                First parameter is the new owner[:group] of the paths.
                Remaining parameters are the path names/paths.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no new owner[:group] was specified.
                Fails if no list of paths was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ chown_paths $USER "$HOME" "/usr/local"
            %td.code
              .highlight
                %pre
                  chown_paths
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _identity
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _path
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_identity}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;user[:group] not given as the first parameter.&quot;
                  %span.k else
                  %span.k                   %span.nb shift
                  %span.nb                   %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _paths
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _paths
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;No paths given to chmod ${_permissions}.&quot;
                  %span.k fi
                  = succeed "_path" do
                    %span.k for
                  in
                  %span.s2 &quot;${_paths[@]}&quot;
                  %span.k do
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${_path}&quot;
                  %span.k then
                  = succeed "chown" do
                    %span.k                   %span.k ${
                  %span.nv _identity
                  %span.k }
                  %span.s2 &quot;${_path}&quot;
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot chown path ${_path} to ${_identity} as the directory does not exist.&quot;
                  %span.k fi
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2
                chown
                %em> paths
                recursively
              %p Change ownership of a list of paths, recursively.
              %h3 Input Parameters
              %p
                First parameter is the new owner[:group] of the paths.
                Remaining parameters are the path names/paths.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no new owner[:group] was specified.
                Fails if no list of paths was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ chown_paths_recursively $USER "$HOME" "/usr/local"
            %td.code
              .highlight
                %pre
                  chown_paths_recursively
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _identity
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _path
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_identity}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;user[:group] not given as the first parameter!!&quot;
                  %span.k else
                  %span.k                   %span.nb shift
                  %span.nb                   %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _paths
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _paths
                  %span.p [@]
                  %span.k }
                  %span.o ==
                  0
                  %span.o ))
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;No paths given to chmod ${_permissions}.&quot;
                  %span.k fi
                  = succeed "_path" do
                    %span.k for
                  in
                  %span.s2 &quot;${_paths[@]}&quot;
                  %span.k do
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${_path}&quot;
                  %span.k then
                  = succeed "chown" do
                    %span.k                   \-R
                  %span.k ${
                  %span.nv _identity
                  %span.k }
                  %span.s2 &quot;${_path}&quot;
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot recursively chown ${_path} to ${_identity} as the directory does not exist.&quot;
                  %span.k fi
                  %span.k done
                  %span.o }
          %tr
            %td.docs
              %h2 chmod_files
              %p Change ownership of a list of files.
              %h3 Input Parameters
              %p
                First parameter is the new owner[:group] of the files.
                Remaining parameters are the file names/files.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no new owner[:group] was specified.
                Fails if no list of files was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ chmod_files $USER "$HOME" "/usr/local"
            %td.code
              .highlight
                %pre
                  chmod_files
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _permissions
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _file _message
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_permissions}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb local
                  %span.nv _files
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _files
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_file" do
                    %span.k for
                  in
                  %span.s2 &quot;${_files[@]}&quot;
                  %span.k do
                  = succeed "file_exists" do
                    %span.k if
                  %span.s2 &quot;${_file}&quot;
                  %span.k then
                  = succeed "chmod" do
                    %span.k                   %span.k ${
                  %span.nv _permissions
                  %span.k }
                  %span.s2 &quot;${_file}&quot;
                  %span.k else
                  %span.k                   %span.nv _message
                  %span.o =(
                  %span.s2 &quot;Cannot chmod file ${_file} to ${_permissions}&quot;
                  %span.s2 &quot; as the file does not exist.&quot;
                  %span.o )
                  error
                  %span.s2 &quot;${_message[*]}&quot;
                  %span.k fi
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;No files given to chmod ${_permissions}.&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Permissions not given as the first parameter!!&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 chmod_paths
              %p Change ownership of a list of paths.
              %h3 Input Parameters
              %p
                First parameter is the new owner[:group] of the paths.
                Remaining parameters are the path names/paths.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no new owner[:group] was specified.
                Fails if no list of paths was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ chmod_paths $USER "$HOME" "/usr/local"
            %td.code
              .highlight
                %pre
                  chmod_paths
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _permissions
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  _path _message
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_permissions}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb local
                  %span.nv _paths
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _paths
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_path" do
                    %span.k for
                  in
                  %span.s2 &quot;${_paths[@]}&quot;
                  %span.k do
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${_path}&quot;
                  %span.k then
                  = succeed "chmod" do
                    %span.k                   %span.k ${
                  %span.nv _permissions
                  %span.k }
                  %span.s2 &quot;${_path}&quot;
                  %span.k else
                  %span.k                   %span.nv _message
                  %span.o =(
                  %span.s2 &quot;Cannot chmod directory ${_path} to ${_permissions}&quot;
                  %span.s2 &quot; as the directory does not exist.&quot;
                  %span.o )
                  error
                  %span.s2 &quot;${_message[*]}&quot;
                  %span.k fi
                  %span.k done
                  %span.k else
                  %span.k                   %span.nv _message
                  %span.o =(
                  %span.s2 &quot;Cannot chmod_paths as no paths were given in &quot;
                  %span.s2 &quot;order to change permissions to ${_permissions}.&quot;
                  %span.o )
                  fail
                  %span.s2 &quot;${_message[*]}&quot;
                  %span.k fi
                  %span.k else
                  %span.k                   %span.nv _message
                  %span.o =(
                  %span.s2 &quot;Cannot chmod_paths as the permissions were &quot;
                  %span.s2 &quot;not given as the first parameter!!&quot;
                  %span.o )
                  fail
                  %span.s2 &quot;${_message[*]}&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                chmod
                %em> paths
                recursively
              %p Change ownership of a list of paths, recursively.
              %h3 Input Parameters
              %p
                First parameter is the new owner[:group] of the paths.
                Remaining parameters are the path names/paths.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no new owner[:group] was specified.
                Fails if no list of paths was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ chmod_paths_recursively $USER "$HOME" "/usr/local"
            %td.code
              .highlight
                %pre
                  chmod_paths_recursively
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _permissions
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _path _message
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_permissions}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb local
                  %span.nv _paths
                  %span.o =(
                  %span.s2 &quot;$@&quot;
                  %span.o )
                  %span.k if
                  %span.o ((
                  %span.k ${#
                  %span.nv _paths
                  %span.p [@]
                  %span.k }
                  \&gt; 0
                  %span.o ))
                  %span.k then
                  = succeed "_path" do
                    %span.k for
                  in
                  %span.s2 &quot;${_paths[@]}&quot;
                  %span.k do
                  = succeed "directory_exists" do
                    %span.k if
                  %span.s2 &quot;${_path}&quot;
                  %span.k then
                  = succeed "chmod" do
                    %span.k                   \-R
                  %span.k ${
                  %span.nv _permissions
                  %span.k }
                  %span.s2 &quot;${_path}&quot;
                  %span.k else
                  %span.k                   %span.nv _message
                  %span.o =(
                  %span.s2 &quot;Cannot chmod directory ${_path} to ${_permissions} &quot;
                  %span.s2 &quot;as the directory does not exist.&quot;
                  %span.o )
                  error
                  %span.s2 &quot;${_message[*]}&quot;
                  %span.k fi
                  %span.k done
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;No paths given to chmod ${_permissions}.&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Permissions not given as the first parameter!!&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 enter
              %p
                Changes the current working directory ($PWD) to the given directory with
                sanity checks.
              %h3 Input Parameters
              %p First parameter is the directory to change into.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                The current working directory (PWD) will become the given directory if
                successful.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no directory was given.
                Fails if the given directory does not exist.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ enter "/usr/local/src"
            %td.code
              .highlight
                %pre
                  enter
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  \!
                  %span.nb builtin cd
                  %span.s2 &quot;${_path}&quot;
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;There was an error ($?) while entering the directory '${_path}'.&quot;
                  %span.k fi
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Cannot enter the directory '${_path}' as it does not exist.&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot enter a directory as no directory was given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 hash_file
              %p Set and get key/value pairs from a given has file.
              %h3 Input Parameters
              %p
                The first parameter is the file name/path for the hash file.
                The second parameter is the key name.
                The third (optional) parameter is the value to assign to the given key.
              %h3 Stream Outputs
              %p The value of the key retrieved is printed if no value parameter was given.
              %h3 Environmental effects
              %p
                If a value parameter was given the key=value pair is written to the named
                hash file.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no file name/path was provided.
                Fails if no key name was given.
                Fails if the file path does not exist.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ hash_file /usr/local/bdsm/extensions/core/config/defaults website_url
                    https://bdsm.beginrescueend.com/
            %td.code
              .highlight
                %pre
                  hash_file
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _message
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;File path/name not given.\n =&gt; Usage: $0 &lt;filename&gt; &lt;key&gt; [value]&quot;
                  %span.k else
                  %span.k                   %span.nb shift
                  %span.nb                   %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _key
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_key}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Key not given.\n =&gt; Usage: $0 &lt;filename&gt; &lt;key&gt; [value]&quot;
                  %span.k else
                  %span.k                   %span.nb shift
                  %span.nb                   %span.k fi
                  %span.k                   %span.nb local
                  %span.nv _path
                  %span.o =
                  = succeed "dirname" do
                    %span.k $(
                  %span.s2 &quot;${_file}&quot;
                  %span.k )
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "ensure_files_exist" do
                    %span.k                   %span.s2 &quot;$_file&quot;
                  %span.k else
                  %span.k                   %span.nv _message
                  %span.o =(
                  %span.s2 &quot;Cannot access the database file '${_file}' &quot;
                  %span.s2 &quot;as the directory '${_file%\/*}' does not exist.&quot;
                  %span.o )
                  error
                  %span.s2 &quot;{$_message[*]}&quot;
                  %span.k fi
                  %span.k                   %span.nv value
                  %span.o =
                  %span.s2 &quot;$*&quot;
                  %span.k case
                  %span.s2 &quot;$value&quot;
                  in
                  = succeed "|delete" do
                    %span.nb unset
                  %span.o )
                  sed -i.tmp
                  %span.s2 &quot;s#^${_key}=.*\$##&quot;
                  %span.s2 &quot;${_file}&quot;
                  ;;
                  *
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${value}&quot;
                  %span.o ]]
                  %span.k then
                  %span.c # get
                  awk -F
                  %span.o =
                  %span.s1 '/^'
                  %span.s2 &quot;${_key}&quot;
                  %span.s1 '=/{print $2}'
                  %span.s2 &quot;$_file&quot;
                  %span.k else
                  %span.c # set
                  %span.k if
                  \! awk -F
                  %span.o =
                  %span.s2 &quot;/^'&quot;
                  %span.k ${
                  %span.nv _key
                  %span.k }
                  %span.s2 &quot;'=/{print $2}&quot;
                  %span.s2 &quot;${_file}&quot;
                  \&gt;/dev/null 2&gt;&amp;1
                  %span.k then
                  %span.k                   %span.nb echo
                  %span.s2 &quot;${_key}=$value&quot;
                  \&gt;&gt;
                  %span.s2 &quot;${_file}&quot;
                  %span.k else
                  %span.c # overwrite
                  sed -i.tmp
                  %span.s2 &quot;s#^${_key}=.*\$#${_key}=$value#&quot;
                  %span.s2 &quot;${_file}&quot;
                  %span.k fi
                  %span.k fi
                  ;;
                  %span.k esac
                  %span.o }
          %tr
            %td.docs
              %h2
                file
                %em> is
                executable
              %p Check if a file name/path is executable.
              %h3 Input Parameters
              %p First parameter is a file name/path.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the named file is executable.
                1 if the named file is not executable or does not exist.
              %h3 Failure Scenarios
              %p Fails if no file name/path was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ file_is_executable /bin/bash
                    user$ echo $?
                    0
                    
                    user$ file_is_executable /bin/asdfasdf
                    user$ echo $?
                    1
            %td.code
              .highlight
                %pre
                  file_is_executable
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-x
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check if a file is executable as no file path/name was given&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 file_exists
              %p Check if a file name/path exists.
              %h3 Input Parameters
              %p First parameter is a file name/path.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the named file exists.
                1 if the named file does not exist or does not exist.
              %h3 Failure Scenarios
              %p Fails if no file name/path was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ file_exists /bin/bash
                    user$ echo $?
                    0
                    
                    user$ file_exists /bin/asdfasdf
                    user$ echo $?
                    1
            %td.code
              .highlight
                %pre
                  file_exists
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-f
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check to see if a file exists as no file name/path was given&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                file
                %em> is
                nonempty
              %p Check if a file name/path is nonempty.
              %h3 Input Parameters
              %p First parameter is a file name/path.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the named file is nonempty.
                1 if the named file is empty or does not exist.
              %h3 Failure Scenarios
              %p Fails if no file name/path was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ file_is_nonempty /bin/bash
                    user$ echo $?
                    0
                    
                    user$ file_is_nonempty /bin/asdfasdf
                    user$ echo $?
                    1
            %td.code
              .highlight
                %pre
                  file_is_nonempty
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;When checking whether the file '${_file}' is nonempty, a directory was found in its place.&quot;
                  %span.k else
                  %span.k if
                  %span.o [[
                  \-s
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check if file is nonempty as no file path/name was given&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                file
                %em> is
                empty
              %p Check if a file name/path is empty.
              %h3 Input Parameters
              %p First parameter is a file name/path.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the named file is empty.
                1 if the named file is not empty or does not exist.
              %h3 Failure Scenarios
              %p Fails if no file name/path was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ file_is_empty /bin/bash
                    user$ echo $?
                    1
                    
                    user$ file_is_empty /bin/asdfasdf
                    user$ echo $?
                    0
            %td.code
              .highlight
                %pre
                  file_is_empty
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-f
                  %span.s2 &quot;${_file}&quot;
                  %span.o &amp;&amp;
                  \! -s
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check if a file is empty as no file path/name was given&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                file
                %em> is
                missing
              %p Check if a file name/path is missing.
              %h3 Input Parameters
              %p First parameter is a file name/path.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the named file is missing.
                1 if the named file is not missing or does not exist.
              %h3 Failure Scenarios
              %p Fails if no file name/path was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ file_is_missing /bin/bash
                    user$ echo $?
                    1
                    
                    user$ file_is_missing /bin/asdfasdf
                    user$ echo $?
                    0
            %td.code
              .highlight
                %pre
                  file_is_missing
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \! -f
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check if file is missing as no file path/name was given&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                file
                %em> is
                empty
                %em> or
                missing
              %p Check if a file name/path is empty or missing.
              %h3 Input Parameters
              %p First parameter is a file name/path.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the named file is empty or missing.
                1 if the named file exists or is nonempty.
              %h3 Failure Scenarios
              %p Fails if no file name/path was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ file_is_missing /bin/bash
                    user$ echo $?
                    1
                    
                    user$ file_is_missing /bin/asdfasdf
                    user$ echo $?
                    0
            %td.code
              .highlight
                %pre
                  file_is_empty_or_missing
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \! -f
                  %span.s2 &quot;${_file}&quot;
                  %span.o ||
                  \! -s
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check if file is empty or missing as no file path/name was given&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 file_contains()
              %p Checks if a named file contains a given string/unix regexp pattern.
              %h3 Input Parameters
              %p
                First parameter is the file name/path.
                Second parameter is the pattern to match.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the given file contains the given pattern.
                1 if the given file does not contain the given pattern.
              %h3 Failure Scenarios
              %p
                Fails if the file path/name was not given
                Fails if the pattern is not given.
                Fails if the file path/name given either does not exist or is not a file.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ cat "$HOME/test"
                    #!/usr/bin/env bash
                    source "/usr/local/bdsm/modules/bash/core/initialize" # Load BDSM framework core.
                    
                    modules filesystem
                    
                    if file_contains "$HOME/.bdsmrc" ".*w00t.*"
                    then
                      echo "w00t! "
                    else
                      echo "no w00t :("
                    fi
            %td.code
              .highlight
                %pre
                  file_contains
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _message
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb local
                  %span.nv _pattern
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_pattern}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-f
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "grep" do
                    %span.k if
                  %span.s2 &quot;${_pattern}&quot;
                  %span.s2 &quot;${_file}&quot;
                  \&gt;/dev/null 2&gt;&amp;1
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  %span.k                   %span.nv _message
                  %span.o =(
                  %span.s2 &quot;First parameter must be a file, '${_file}'&quot;
                  %span.s2 &quot; does not appear to be a file.&quot;
                  %span.o )
                  fail
                  %span.s2 &quot;${_message[*]}&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;String pattern for search was not given!&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;File path/name was not given!&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 symlink_exists
              %p Check if a symlink name/path exists.
              %h3 Input Parameters
              %p First parameter is a symlink name/path.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the named symlink exists.
                1 if the named symlink does not exist or does not exist.
              %h3 Failure Scenarios
              %p Fails if no symlink name/path was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ symlink_exists /usr/local/bin/bdsm
                    user$ echo $?
                    0
                    
                    user$ symlink_exists /bin/asdfasdf
                    user$ echo $?
                    1
            %td.code
              .highlight
                %pre
                  symlink_exists
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-L
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check if symlink exists as no path/name was given&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 directory_exists
              %p Check if a directory name/path exists.
              %h3 Input Parameters
              %p First parameter is a directory name/path.
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the named directory exists.
                1 if the named directory does not exist or does not exist.
              %h3 Failure Scenarios
              %p Fails if no directory name/path was given.
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ directory_exists /usr/local/bin/bdsm
                    user$ echo $?
                    0
                    
                    user$ directory_exists /bin/asdfasdf
                    user$ echo $?
                    1
            %td.code
              .highlight
                %pre
                  directory_exists
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _directory
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_directory}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;$_directory&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot check if directory exists as no name/path was given&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 function_name
              %p Function Description
              %h3 Input Parameters
              %p Positional Parameter listing and descriptions.
              %h3 Stream Outputs
              %p What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
              %h3 Environmental effects
              %p What, if any, environmental side effects this function causes. 'None.' for none.
              %h3 Return Codes
              %p
                0 if ...
                1 if ...
              %h3 Failure Scenarios
              %p Fails if ...
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ {{ setup the scenario }}
                    user$ function_name {{ parameters }}
                    user$ {{ demonstrate the results}}
            %td.code
              .highlight
                %pre
                  directories_in
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "find" do
                    %span.k if
                  %span.s2 &quot;${_path}&quot;
                  \-mindepth 1 -maxdepth 1 -type d
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;'${_path}' is not a directory!&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Directory name/path was not given!&quot;
                  %span.k fi
                  %span.o }
                  directories_in_matching
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.nv _pattern
                  %span.o =
                  %span.s2 &quot;${2:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_pattern}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "find" do
                    %span.k if
                  %span.s2 &quot;${_path}&quot;
                  \-mindepth 1 -maxdepth 1 -type d
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;'${_path}' is not a directory!&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;'${_path}' is not a directory!&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Directory name/path was not given!&quot;
                  %span.k fi
                  %span.o }
                  directories_under
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "find" do
                    %span.k if
                  %span.s2 &quot;${_path}&quot;
                  \-mindepth 1 -type d
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;'${_path}' is not a directory!&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Directory name/path was not given!&quot;
                  %span.k fi
                  %span.o }
                  directories_under_matching
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb local
                  %span.nv _pattern
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_pattern}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "find" do
                    %span.k if
                  %span.s2 &quot;${_path}&quot;
                  \-mindepth 1 -iname
                  %span.s2 &quot;${_pattern}&quot;
                  \-type d
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;'${_path}' is not a directory!&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;'${_path}' is not a directory!&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Directory name/path was not given!&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 function_name
              %p Function Description
              %h3 Input Parameters
              %p Positional Parameter listing and descriptions.
              %h3 Stream Outputs
              %p What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
              %h3 Environmental effects
              %p What, if any, environmental side effects this function causes. 'None.' for none.
              %h3 Return Codes
              %p
                0 if ...
                1 if ...
              %h3 Failure Scenarios
              %p Fails if ...
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ {{ setup the scenario }}
                    user$ function_name {{ parameters }}
                    user$ {{ demonstrate the results}}
            %td.code
              .highlight
                %pre
                  files_in
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "find" do
                    %span.k if
                  %span.s2 &quot;${_path}&quot;
                  \-mindepth 1 -maxdepth 1 -type f
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;'${_path}' is not a directory!&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Directory name/path was not given!&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 function_name
              %p Function Description
              %h3 Input Parameters
              %p Positional Parameter listing and descriptions.
              %h3 Stream Outputs
              %p What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
              %h3 Environmental effects
              %p What, if any, environmental side effects this function causes. 'None.' for none.
              %h3 Return Codes
              %p
                0 if ...
                1 if ...
              %h3 Failure Scenarios
              %p Fails if ...
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ {{ setup the scenario }}
                    user$ function_name {{ parameters }}
                    user$ {{ demonstrate the results}}
            %td.code
              .highlight
                %pre
                  files_under
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "find" do
                    %span.k if
                  %span.s2 &quot;${_path}&quot;
                  \-mindepth 1 -type f
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;'${_path}' is not a directory!&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Directory name/path was not given!&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                files
                %em> in
                path_matching
              %p Find all files in given path matching a given name glob pattern.
              %h3 Input Parameters
              %p
                First parameter is the path to search in
                Second parameter is the pattern to match in
              %h3 Stream Outputs
              %p What gets printed to STDOUT and STDERROR. 'None.' if nothing is output.
              %h3 Environmental effects
              %p What, if any, environmental side effects this function causes. 'None.' for none.
              %h3 Return Codes
              %p
                0 if ...
                1 if ...
              %h3 Failure Scenarios
              %p Fails if ...
              %h3 Usage Examples
              %pre
                %code
                  :preserve
                    user$ files_in_path_matching ...
            %td.code
              .highlight
                %pre
                  files_in_path_matching
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb                   %span.nv _pattern
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-d
                  %span.s2 &quot;${_path}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb                   %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_pattern}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "find" do
                    %span.k if
                  %span.s2 &quot;${_path}&quot;
                  \-mindepth 1 -iname
                  %span.s2 &quot;${_pattern}&quot;
                  \-type f
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot find files as a filename or pattern was not given.&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;'${_path}' is not a directory!&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Directory name/path was not given!&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2 replace_content
              %p
                Replaces a given (sed compatable) pattern with given replacement text in a
                file.
              %h3 Input Parameters
              %p
                First parameter is the pattern
                [optional 'with']
                Second parameter is the replacement content
                [optional 'in']
                Third parameter is the file name/path
              %h3 Stream Outputs
              %p None.
              %h3 Environmental effects
              %p
                The pattern will be matched against the file name/path content and the
                replacement text will be put in place.
              %h3 Return Codes
              %p 0 for success
              %h3 Failure Scenarios
              %p
                Fails if no pattern was given
                Fails if replacement content was not given
                Fails if filename was not given
                Fails if the file does not exist
              %h3 Usage Examples
              %h1 Replace contents in a file with a given (sed) regex pattern.
              %pre
                %code
                  :preserve
                    replace_content "^PREFIX =.*" with "${install_path}" in Makefile
            %td.code
              .highlight
                %pre
                  replace_content
                  %span.o ()
                  %span.o {
                  = succeed "_token" do
                    %span.nb local
                  _pattern _content _file _message
                  %span.k while
                  %span.o ((
                  = succeed "&amp;gt;" do
                    %span.nv $#
                  0
                  %span.o ))
                  %span.k do
                  %span.k                   %span.nv _token
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nb shift
                  %span.nb                   %span.k case
                  %span.s2 &quot;${_token}&quot;
                  in
                  = succeed "with" do
                    %span.o (
                  %span.o )
                  %span.nv _content
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.nb shift
                  ;;
                  = succeed "in" do
                    %span.o (
                  %span.o )
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1}&quot;
                  %span.nb shift
                  ;;
                  = succeed "*" do
                    %span.o (
                  %span.o )
                  %span.k if
                  %span.o [[
                  \-z
                  %span.s2 &quot;${_pattern}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _pattern
                  %span.o =
                  %span.s2 &quot;${_token}&quot;
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Unknown token '${_token}' passed as a parameter.'&quot;
                  %span.k fi
                  ;;
                  %span.k esac
                  %span.k done
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_pattern:-}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_content:-}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file:-}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-f
                  %span.s2 &quot;${_file:-}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "sed" do
                    %span.k if
                  \-i -e
                  %span.s2 &quot;s#${_pattern//\#/\\#}#${_content//\#/\\#}#g&quot;
                  %span.s2 &quot;${_file}&quot;
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Can not replace file content as the file does not exist.&quot;
                  %span.k fi
                  %span.k else
                  %span.k                   %span.nv _message
                  %span.o =(
                  %span.s2 &quot;Can not file content as the filename was not given,&quot;
                  %span.s2 &quot; specify by 'in \&quot;/path/to/filename\&quot;'&quot;
                  %span.o )
                  fail
                  %span.s2 &quot;${_message[*]}&quot;
                  %span.k fi
                  %span.k else
                  %span.k                   %span.nv _message
                  %span.o =(
                  %span.s2 &quot;Cannot replace content as the replacement content was not given, &quot;
                  %span.s2 &quot;specify by 'with \&quot;replacement text\&quot;'.&quot;
                  %span.o )
                  fail
                  %span.s2 &quot;${_message[*]}&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot replace content as not even a pattern was given.&quot;
                  %span.k fi
                  %span.o }
          %tr
            %td.docs
              %h2
                file
                %em> matches
                md5
              %p Checks to see if the given file matches the given md5 sum.
              %h3 Input Parameters
              %p None.
              %h3 Stream Outputs
              %p none.
              %h3 Environmental effects
              %p None.
              %h3 Return Codes
              %p
                0 if the file matches the md5sum
                1 if the file does not match the md5sum
                1 if the file is empty or missing
              %h3 Failure Scenarios
              %p
                Fails if no file name/path was given.
                Fails if no md5 string was given.
              %h3 Usage Examples
              %p Example Usage:
              %p
                user$ file
                %em> matches
                md5
              %h3 Notes
            %td.code
              .highlight
                %pre
                  file_matches_md5
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;$1&quot;
                  %span.nv _md5
                  %span.o =
                  %span.s2 &quot;$2&quot;
                  _file_md5
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_md5}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k if
                  %span.o [[
                  \-s
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nv _file_md5
                  %span.o =
                  %span.s2 &quot;$(file_md5 &quot;
                  %span.k ${
                  %span.nv _file
                  %span.k }
                  %span.s2 &quot;)&quot;
                  %span.k if
                  %span.o [[
                  %span.s2 &quot;${_file_md5// *}&quot;
                  %span.o =
                  %span.s2 &quot;$_md5&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "0" do
                    %span.k return
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot determine if file matches md5 as no md5 was given.&quot;
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot determine if file matches md5 as no file was given.&quot;
                  %span.k fi
                  %span.o }
                  extract_archive
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _archive
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_archive}&quot;
                  %span.o ]]
                  %span.k then
                  %span.k                   %span.nb shift
                  %span.nb local
                  %span.nv _path
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  %span.k case
                  %span.s2 &quot;${_archive}&quot;
                  in
                  *.tar.gz|*.tgz
                  %span.o )
                  %span.c # gzip
                  %span.k if
                  \! tar zxf
                  %span.s2 &quot;${_archive}&quot;
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;There was an error while extracting the archive '${_archive}'&quot;
                  %span.k fi
                  ;;
                  *tar.xz
                  %span.o )
                  %span.c # LZMA
          %tr
            %td.docs
              %p TODO: if 'xz' command exists, use that, otherwise use tar J
            %td.code
              .highlight
                %pre
                  %span.k if
                  \! tar Jxf
                  %span.s2 &quot;${_archive}&quot;
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;There was an error while extracting the archive '${_archive}'&quot;
                  %span.k fi
                  ;;
                  *.tar.bz2
                  %span.o )
                  %span.c # bzip
                  %span.k if
                  \! tar jxf
                  %span.s2 &quot;${_archive}&quot;
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;There was an error while extracting the archive '${_archive}'&quot;
                  %span.k fi
                  ;;
                  *.zip
                  %span.o )
                  %span.k if
                  \! unzip
                  %span.s2 &quot;${_archive}&quot;
                  \-d
                  %span.s2 &quot;${_path:-}&quot;
                  %span.k then
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;There was an error while extracting the archive '${_archive}'&quot;
                  %span.k fi
                  ;;
                  *
                  %span.o )
                  error
                  %span.s2 &quot;Unknown archive format for ${_archive}&quot;
                  ;;
                  %span.k esac
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot extract an archive to target location as no archive was given.&quot;
                  %span.k fi
                  %span.o }
                  file_md5
                  %span.o ()
                  %span.o {
                  %span.nb local
                  %span.nv _file
                  %span.o =
                  %span.s2 &quot;${1:-}&quot;
                  _command _md5
                  %span.k if
                  %span.o [[
                  \-n
                  %span.s2 &quot;${_file}&quot;
                  %span.o ]]
                  %span.k then
                  = succeed "os_is_darwin" do
                    %span.k if
                  %span.k then
                  %span.k                   %span.nv _command
                  %span.o =
                  %span.s2 &quot;/sbin/md5 -q&quot;
                  %span.k else
                  = succeed "command_exists" do
                    %span.k if
                  %span.s2 &quot;md5sum&quot;
                  %span.k then
                  %span.k                   %span.nv _command
                  %span.o =
                  %span.s2 &quot;md5sum&quot;
                  = succeed "command_exists" do
                    %span.k elif
                  md5
                  %span.k then
                  %span.k                   %span.nv _command
                  %span.o =
                  %span.s2 &quot;md5&quot;
                  %span.k else
                  = succeed "error" do
                    %span.k                   %span.s2 &quot;Could not find a suitable md5 command in the path.&quot;
                  %span.k fi
                  %span.k fi
                  %span.k if
                  %span.nv _md5
                  %span.o =
                  %span.s2 &quot;$(${_command} &quot;
                  %span.nv $_file
                  %span.s2 &quot; 2&gt;/dev/null)&quot;
                  %span.k then
                  %span.k                   %span.nb printf
                  %span.s2 &quot;${_md5// *}&quot;
                  %span.k else
                  %span.c # Should this be error ?
                  warn
                  %span.s2 &quot;There was an unknown error computing the md5&quot;
                  = succeed "1" do
                    %span.k return
                  %span.k fi
                  %span.k else
                  = succeed "fail" do
                    %span.k                   %span.s2 &quot;Cannot calculate md5 of a file as no file name/path was given.&quot;
                  %span.k fi
                  %span.o }
            %td.code
              .highlight
                %pre
                  :preserve
                    
          %tr
            %td.docs
    %tr
      %td.docs
      %td.code
        .highlight
          %pre
            :preserve
              
              
    %tr
      %td.docs
      %td.code
